import { ad as g, ae as f, af as D, ag as b, ah as H, W as se, s as z, g as l, I as Y, n as X, a9 as ie, K as oe } from "./color-scale-utils-faf67b75.mjs";
import { S as O, D as ae } from "./angle-utils-6b17e95b.mjs";
import { _ as B, e as u, i as k, S as d } from "./enums-a96ef472.mjs";
import { select as re, max as le, extent as q, scaleTime as ue, scaleLog as ce, scaleBand as me, scaleLinear as de, curveLinear as ge, curveLinearClosed as he, curveBasis as fe, curveBasisClosed as pe, curveBasisOpen as ve, curveBundle as xe, curveCardinal as De, curveCardinalClosed as ye, curveCardinalOpen as Oe, curveCatmullRom as Ae, curveCatmullRomClosed as Te, curveCatmullRomOpen as Me, curveMonotoneX as Se, curveMonotoneY as Pe, curveNatural as Re, curveStep as Be, curveStepAfter as Le, curveStepBefore as Ee } from "d3";
function J(i, e) {
  g(2, arguments);
  var t = f(i), n = D(e);
  return isNaN(n) ? /* @__PURE__ */ new Date(NaN) : (n && t.setDate(t.getDate() + n), t);
}
function C(i, e) {
  g(2, arguments);
  var t = f(i), n = D(e);
  if (isNaN(n))
    return /* @__PURE__ */ new Date(NaN);
  if (!n)
    return t;
  var s = t.getDate(), o = new Date(t.getTime());
  o.setMonth(t.getMonth() + n + 1, 0);
  var a = o.getDate();
  return s >= a ? o : (t.setFullYear(o.getFullYear(), o.getMonth(), s), t);
}
var Ie = 36e5;
function Q(i, e) {
  g(2, arguments);
  var t = D(e);
  return b(i, t * Ie);
}
function G(i) {
  g(1, arguments);
  var e = f(i);
  return e.setHours(0, 0, 0, 0), e;
}
var be = 864e5;
function Ce(i, e) {
  g(2, arguments);
  var t = G(i), n = G(e), s = t.getTime() - H(t), o = n.getTime() - H(n);
  return Math.round((s - o) / be);
}
var we = 6e4;
function E(i, e) {
  g(2, arguments);
  var t = D(e);
  return b(i, t * we);
}
function I(i, e) {
  g(2, arguments);
  var t = D(e);
  return b(i, t * 1e3);
}
function ee(i, e) {
  g(2, arguments);
  var t = D(e);
  return C(i, t * 12);
}
function M(i, e) {
  g(2, arguments);
  var t = f(i), n = f(e), s = t.getTime() - n.getTime();
  return s < 0 ? -1 : s > 0 ? 1 : s;
}
var Ze = 6e4, Ne = 36e5;
function Fe(i, e) {
  g(2, arguments);
  var t = f(i), n = f(e), s = t.getFullYear() - n.getFullYear(), o = t.getMonth() - n.getMonth();
  return s * 12 + o;
}
function Ve(i, e) {
  g(2, arguments);
  var t = f(i), n = f(e);
  return t.getFullYear() - n.getFullYear();
}
function _(i, e) {
  var t = i.getFullYear() - e.getFullYear() || i.getMonth() - e.getMonth() || i.getDate() - e.getDate() || i.getHours() - e.getHours() || i.getMinutes() - e.getMinutes() || i.getSeconds() - e.getSeconds() || i.getMilliseconds() - e.getMilliseconds();
  return t < 0 ? -1 : t > 0 ? 1 : t;
}
function He(i, e) {
  g(2, arguments);
  var t = f(i), n = f(e), s = _(t, n), o = Math.abs(Ce(t, n));
  t.setDate(t.getDate() - s * o);
  var a = +(_(t, n) === -s), r = s * (o - a);
  return r === 0 ? 0 : r;
}
function w(i, e) {
  return g(2, arguments), f(i).getTime() - f(e).getTime();
}
var U = {
  ceil: Math.ceil,
  round: Math.round,
  floor: Math.floor,
  trunc: function(e) {
    return e < 0 ? Math.ceil(e) : Math.floor(e);
  }
  // Math.trunc is not supported by IE
}, ze = "trunc";
function Z(i) {
  return i ? U[i] : U[ze];
}
function Ye(i, e, t) {
  g(2, arguments);
  var n = w(i, e) / Ne;
  return Z(t == null ? void 0 : t.roundingMethod)(n);
}
function $(i, e, t) {
  g(2, arguments);
  var n = w(i, e) / Ze;
  return Z(t == null ? void 0 : t.roundingMethod)(n);
}
function Xe(i) {
  g(1, arguments);
  var e = f(i);
  return e.setHours(23, 59, 59, 999), e;
}
function ke(i) {
  g(1, arguments);
  var e = f(i), t = e.getMonth();
  return e.setFullYear(e.getFullYear(), t + 1, 0), e.setHours(23, 59, 59, 999), e;
}
function Ge(i) {
  g(1, arguments);
  var e = f(i);
  return Xe(e).getTime() === ke(e).getTime();
}
function _e(i, e) {
  g(2, arguments);
  var t = f(i), n = f(e), s = M(t, n), o = Math.abs(Fe(t, n)), a;
  if (o < 1)
    a = 0;
  else {
    t.getMonth() === 1 && t.getDate() > 27 && t.setDate(30), t.setMonth(t.getMonth() - s * o);
    var r = M(t, n) === -s;
    Ge(f(i)) && o === 1 && M(i, n) === 1 && (r = !1), a = s * (o - Number(r));
  }
  return a === 0 ? 0 : a;
}
function j(i, e, t) {
  g(2, arguments);
  var n = w(i, e) / 1e3;
  return Z(t == null ? void 0 : t.roundingMethod)(n);
}
function Ue(i, e) {
  g(2, arguments);
  var t = f(i), n = f(e), s = M(t, n), o = Math.abs(Ve(t, n));
  t.setFullYear(1584), n.setFullYear(1584);
  var a = M(t, n) === -s, r = s * (o - Number(a));
  return r === 0 ? 0 : r;
}
function $e(i, e) {
  g(2, arguments);
  var t = D(e);
  return J(i, -t);
}
function je(i, e) {
  g(2, arguments);
  var t = D(e);
  return C(i, -t);
}
function Ke(i, e) {
  g(2, arguments);
  var t = D(e);
  return Q(i, -t);
}
function K(i, e) {
  g(2, arguments);
  var t = D(e);
  return E(i, -t);
}
function W(i, e) {
  g(2, arguments);
  var t = D(e);
  return I(i, -t);
}
function We(i, e) {
  g(2, arguments);
  var t = D(e);
  return ee(i, -t);
}
function qe(i) {
  var e = i == null ? 0 : i.length;
  return e ? se(i, 1) : [];
}
class it extends O {
  /**
   * focal:  object to zoom into
   * canvasElements: all the elements to translate and zoom on the chart area
   * zoomSettings: object containing duration, easing and zoomlevel for the zoom behaviours
   *  */
  zoomIn(e, t, n) {
    let s, o, a;
    const r = n || z;
    e && (s = e.x, o = e.y, a = 2);
    const { width: c, height: h } = ae.getSVGElementSize(this.services.domUtils.getHolder(), {
      useClientDimensions: !0
    });
    t.transition().duration(r.duration).ease(r.ease).attr(
      "transform",
      `translate(${c / 2}, ${h / 2}) scale(${a}) translate(${-s},${-o})`
    ), this.services.events.dispatchEvent(B.CanvasZoom.CANVAS_ZOOM_IN, {
      element: re(e)
    });
  }
  zoomOut(e, t) {
    const n = t || z;
    e.transition().duration(n.duration).ease(n.ease).attr("transform", ""), this.services.events.dispatchEvent(B.CanvasZoom.CANVAS_ZOOM_OUT);
  }
}
class ot extends O {
  init() {
    this.documentFragment = document.createDocumentFragment();
  }
  addEventListener(e, t) {
    this.documentFragment.addEventListener(e, t);
  }
  removeEventListener(e, t) {
    this.documentFragment.removeEventListener(e, t);
  }
  dispatchEvent(e, t) {
    let n;
    t ? n = new CustomEvent(e, {
      detail: t
    }) : (n = document.createEvent("Event"), n.initEvent(e, !1, !0)), this.documentFragment.dispatchEvent(n);
  }
}
class at extends O {
  constructor(e, t) {
    super(e, t);
  }
  downloadCSV(e, t) {
    const n = document.createElement("a"), s = "text/csv;encoding:utf-8";
    if (navigator.msSaveBlob)
      navigator.msSaveBlob(
        new Blob([e], {
          type: s
        }),
        t
      );
    else if (URL && "download" in n) {
      const o = URL.createObjectURL(
        new Blob([e], {
          type: s
        })
      );
      n.href = o, n.setAttribute("download", t), document.body.appendChild(n), n.click(), document.body.removeChild(n), URL.revokeObjectURL(o);
    } else
      location.href = `data:application/octet-stream,${encodeURIComponent(e)}`;
  }
  downloadImage(e, t) {
    const n = document.createElement("a");
    n.download = t, n.href = e, document.body.appendChild(n), n.click(), document.body.removeChild(n);
  }
}
class rt extends O {
  constructor() {
    super(...arguments), this.pendingTransitions = {};
  }
  init() {
    var e;
    (e = this.services.events) == null || e.addEventListener(B.Model.UPDATE, () => {
      this.pendingTransitions = {};
    });
  }
  setupTransition({ transition: e, name: t, animate: n }) {
    return this.pendingTransitions[e._id] = e, e.on("end interrupt cancel", () => {
      delete this.pendingTransitions[e._id];
    }), this.model.getOptions().animations === !1 || n === !1 ? e.duration(0) : e.duration(l(Y, t, "duration") || Y.default.duration);
  }
  getPendingTransitions() {
    return this.pendingTransitions;
  }
}
class lt extends O {
  constructor() {
    super(...arguments), this.scaleTypes = {
      top: null,
      right: null,
      bottom: null,
      left: null
    }, this.scales = {
      // null or function
      top: null,
      right: null,
      bottom: null,
      left: null
    };
  }
  getDomainAxisPosition({ datum: e = null } = {}) {
    if (this.dualAxes && e) {
      const t = this.model.getOptions(), { groupMapsTo: n } = t.data, s = l(t, "axes", this.secondaryDomainAxisPosition), o = e[n];
      if (s != null && s.correspondingDatasets && s.correspondingDatasets.includes(o))
        return this.secondaryDomainAxisPosition;
    }
    return this.domainAxisPosition;
  }
  getRangeAxisPosition({ datum: e = null, groups: t = null } = {}) {
    if (this.dualAxes) {
      const n = this.model.getOptions(), { groupMapsTo: s } = n.data, o = l(n, "axes", this.secondaryRangeAxisPosition);
      let a;
      if (e !== null ? a = e[s] : t && t.length > 0 && (a = t[0]), o != null && o.correspondingDatasets && o.correspondingDatasets.includes(a))
        return this.secondaryRangeAxisPosition;
    }
    return this.rangeAxisPosition;
  }
  getAxisOptions(e) {
    return l(this.model.getOptions(), "axes", e);
  }
  getDomainAxisOptions() {
    const e = this.getDomainAxisPosition();
    return this.getAxisOptions(e);
  }
  getRangeAxisOptions() {
    const e = this.getRangeAxisPosition();
    return this.getAxisOptions(e);
  }
  getScaleLabel(e) {
    const n = this.getAxisOptions(e).title;
    return n || (e === u.BOTTOM || e === u.TOP ? "x-value" : "y-value");
  }
  getDomainLabel() {
    return this.getScaleLabel(this.getDomainAxisPosition());
  }
  getRangeLabel() {
    return this.getScaleLabel(this.getRangeAxisPosition());
  }
  update() {
    this.determineAxisDuality(), this.findDomainAndRangeAxes(), this.determineOrientation(), Object.keys(u).map(
      (t) => u[t]
    ).forEach((t) => {
      this.scales[t] = this.createScale(t);
    });
  }
  findDomainAndRangeAxes() {
    const e = this.findVerticalAxesPositions(), t = this.findHorizontalAxesPositions(), n = this.findDomainAndRangeAxesPositions(
      e,
      t
    );
    this.domainAxisPosition = n.primaryDomainAxisPosition, this.rangeAxisPosition = n.primaryRangeAxisPosition, this.isDualAxes() && (this.secondaryDomainAxisPosition = n.secondaryDomainAxisPosition, this.secondaryRangeAxisPosition = n.secondaryRangeAxisPosition);
  }
  determineOrientation() {
    (this.rangeAxisPosition === u.LEFT || this.rangeAxisPosition === u.RIGHT) && (this.domainAxisPosition === u.BOTTOM || this.domainAxisPosition === u.TOP) ? this.orientation = k.VERTICAL : this.orientation = k.HORIZONTAL;
  }
  isDualAxes() {
    return this.dualAxes;
  }
  // if any of the axes objects have correspondingDatasets [] asserted we flag the chart as dual axes
  // it does not count as dual axes if it just has another axis turned on but is not actually using it to map a dataset
  determineAxisDuality() {
    var n, s, o, a;
    const e = this.model.getOptions(), t = l(e, "axes");
    ((n = t[u.LEFT]) != null && n.correspondingDatasets && t[u.RIGHT] || (s = t[u.RIGHT]) != null && s.correspondingDatasets && t[u.LEFT] || (o = t[u.TOP]) != null && o.correspondingDatasets && t[u.BOTTOM] || (a = t[u.BOTTOM]) != null && a.correspondingDatasets && t[u.TOP]) && (this.dualAxes = !0);
  }
  getCustomDomainValuesByposition(e) {
    const t = l(this.model.getOptions(), "axes", e, "domain");
    if (t && !Array.isArray(t))
      throw new Error(`Domain in ${e} axis is not a valid array`);
    if (Array.isArray(t) && (this.scaleTypes[e] === d.LINEAR || this.scaleTypes[e] === d.TIME) && t.length !== 2)
      throw new Error(
        `There can only be 2 elements in domain for scale type: ${this.scaleTypes[e]}`
      );
    return t;
  }
  getOrientation() {
    return this.orientation;
  }
  getScaleByPosition(e) {
    return this.scales[e];
  }
  getScaleTypeByPosition(e) {
    return this.scaleTypes[e];
  }
  getDomainAxisScaleType() {
    const e = this.getDomainAxisPosition();
    return this.getScaleTypeByPosition(e);
  }
  getRangeAxisScaleType() {
    const e = this.getRangeAxisPosition();
    return this.getScaleTypeByPosition(e);
  }
  getDomainScale() {
    return this.scales[this.domainAxisPosition];
  }
  getRangeScale() {
    return this.scales[this.rangeAxisPosition];
  }
  // Find the main x-axis out of the 2 x-axis on the chart (when 2D axis is used)
  getMainXAxisPosition() {
    const e = [u.BOTTOM, u.TOP];
    return [this.domainAxisPosition, this.rangeAxisPosition].find(
      (t) => e.indexOf(t) > -1
    );
  }
  // Find the main y-axis out of the 2 y-axis on the chart (when 2D axis is used)
  getMainYAxisPosition() {
    const e = [u.LEFT, u.RIGHT];
    return [this.domainAxisPosition, this.rangeAxisPosition].find(
      (t) => e.indexOf(t) > -1
    );
  }
  getMainXScale() {
    return this.scales[this.getMainXAxisPosition()];
  }
  getMainYScale() {
    return this.scales[this.getMainYAxisPosition()];
  }
  getValueFromScale(e, t, n, s) {
    const o = this.model.getOptions(), r = l(o, "axes")[n], { mapsTo: c } = r, h = l(s, c) !== null ? s[c] : s;
    let v;
    switch (t) {
      case d.LABELS:
        v = e(h) + e.step() / 2;
        break;
      case d.TIME:
        v = e(new Date(h));
        break;
      default:
        v = e(h);
    }
    return v;
  }
  getBoundedScaledValues(e) {
    const { bounds: t } = this.model.getOptions(), n = this.getRangeAxisPosition({ datum: e }), s = this.scales[n], o = this.model.getOptions(), r = l(o, "axes")[n], { mapsTo: c } = r, h = e[c] !== void 0 ? e[c] : e;
    return [
      s(
        l(e, t.upperBoundMapsTo) !== null ? e[t.upperBoundMapsTo] : h
      ),
      s(
        l(e, t.lowerBoundMapsTo) !== null ? e[t.lowerBoundMapsTo] : h
      )
    ];
  }
  getValueThroughAxisPosition(e, t) {
    const n = this.scaleTypes[e], s = this.scales[e];
    return this.getValueFromScale(s, n, e, t);
  }
  getDomainValue(e) {
    const t = this.getDomainAxisPosition({ datum: e });
    return this.getValueThroughAxisPosition(t, e);
  }
  getRangeValue(e) {
    const t = this.getRangeAxisPosition({ datum: e });
    return this.getValueThroughAxisPosition(t, e);
  }
  getMainXScaleType() {
    return this.getScaleTypeByPosition(this.getMainXAxisPosition());
  }
  getMainYScaleType() {
    return this.getScaleTypeByPosition(this.getMainYAxisPosition());
  }
  getDomainIdentifier(e) {
    const t = this.model.getOptions();
    return l(t, "axes", this.getDomainAxisPosition({ datum: e }), "mapsTo");
  }
  getRangeIdentifier(e) {
    const t = this.model.getOptions();
    return l(t, "axes", this.getRangeAxisPosition({ datum: e }), "mapsTo");
  }
  extendsDomain(e, t) {
    const n = this.model.getOptions(), s = l(n, "axes", e);
    if (s.scaleType === d.TIME) {
      const o = l(n, "timeScale", "addSpaceOnEdges");
      return Je(t, o);
    } else
      return Qe(t, X.paddingRatio, s.scaleType);
  }
  findVerticalAxesPositions() {
    const e = this.model.getOptions(), t = l(e, "axes"), n = this.isDualAxes();
    return l(t, u.LEFT) === null && l(t, u.RIGHT) !== null || l(t, u.RIGHT, "main") === !0 || n && l(t, u.LEFT, "correspondingDatasets") ? {
      primary: u.RIGHT,
      secondary: u.LEFT
    } : { primary: u.LEFT, secondary: u.RIGHT };
  }
  findHorizontalAxesPositions() {
    const e = this.model.getOptions(), t = l(e, "axes"), n = this.isDualAxes();
    return l(t, u.BOTTOM) === null && l(t, u.TOP) !== null || l(t, u.TOP, "main") === !0 || n && l(t, u.BOTTOM, "correspondingDatasets") ? {
      primary: u.TOP,
      secondary: u.BOTTOM
    } : { primary: u.BOTTOM, secondary: u.TOP };
  }
  findDomainAndRangeAxesPositions(e, t) {
    const n = this.model.getOptions(), s = l(n, "axes", e.primary), o = l(n, "axes", t.primary), a = s.scaleType || d.LINEAR, r = o.scaleType || d.LINEAR, c = {
      primaryDomainAxisPosition: null,
      secondaryDomainAxisPosition: null,
      primaryRangeAxisPosition: null,
      secondaryRangeAxisPosition: null
    };
    return c.primaryDomainAxisPosition = t.primary, c.primaryRangeAxisPosition = e.primary, c.secondaryDomainAxisPosition = t.secondary, c.secondaryRangeAxisPosition = e.secondary, (!(r === d.LABELS || r === d.TIME) && a === d.LABELS || a === d.TIME) && (c.primaryDomainAxisPosition = e.primary, c.primaryRangeAxisPosition = t.primary, c.secondaryDomainAxisPosition = e.secondary, c.secondaryRangeAxisPosition = t.secondary), c;
  }
  getScaleDomain(e) {
    const t = this.model.getOptions(), n = l(t, "axes", e), s = l(t, "bounds"), { includeZero: o } = n, a = l(n, "scaleType") || d.LINEAR;
    if (this.model.isDataEmpty())
      return [];
    if (n.binned) {
      const { bins: m } = this.model.getBinConfigurations();
      return [0, le(m, (p) => p.length)];
    } else if (n.limitDomainToBins) {
      const { bins: m } = this.model.getBinConfigurations(), p = this.model.getStackKeys({ bins: m });
      return [p[0].split("-")[0], p[p.length - 1].split("-")[1]];
    }
    const r = this.model.getDisplayData(), { extendLinearDomainBy: c, mapsTo: h, percentage: v, thresholds: y } = n, { reference: A, compareTo: S } = X.ratio;
    if (n.domain)
      return a === d.LABELS ? n.domain : (a === d.TIME && (n.domain = n.domain.map(
        (m) => m.getTime === void 0 ? new Date(m) : m
      )), this.extendsDomain(e, n.domain));
    if (v)
      return [0, 100];
    if (n && a === d.LABELS)
      return ie(r.map((m) => m[h]));
    let P, x;
    const L = this.model.getDataGroupNames();
    if (a === d.LABELS_RATIO)
      return r.map((m) => `${m[A]}/${m[S]}`);
    if (a === d.TIME)
      x = r.map((m) => +new Date(m[h]));
    else if (s && t.axes)
      x = [], r.forEach((m) => {
        x.push(m[h]), m[s.upperBoundMapsTo] && x.push(m[s.upperBoundMapsTo]), m[s.lowerBoundMapsTo] && x.push(m[s.lowerBoundMapsTo]);
      });
    else if (n.stacked === !0 && L && e === this.getRangeAxisPosition()) {
      const { groupMapsTo: m } = t.data, p = this.model.getDataValuesGroupedByKeys({
        groups: L
      }), te = r.filter(
        (T) => !L.includes(T[m])
      ), N = [];
      p.forEach((T) => {
        const { ...ne } = T;
        let F = 0, V = 0;
        Object.values(ne).forEach((R) => {
          isNaN(R) || (R < 0 ? V += R : F += R);
        }), N.push([V, F]);
      }), x = [
        ...qe(N),
        ...te.map((T) => T[h])
      ];
    } else
      x = [], r.forEach((m) => {
        const p = m[h];
        Array.isArray(p) && p.length === 2 ? (x.push(p[0]), x.push(p[1])) : (c && x.push(Math.max(m[h], m[c])), x.push(p));
      });
    return a !== d.TIME && a !== d.LOG && o && x.push(0), y && y.length > 0 && y.forEach((m) => {
      const p = l(m, "value");
      p !== null && x.push(p);
    }), P = q(x), P = this.extendsDomain(e, P), P;
  }
  createScale(e) {
    const t = this.model.getOptions(), n = l(t, "axes", e);
    if (!n)
      return null;
    const s = l(n, "scaleType") || d.LINEAR;
    this.scaleTypes[e] = s;
    let o;
    return s === d.TIME ? o = ue() : s === d.LOG ? o = ce().base(n.base || 10) : s === d.LABELS || s === d.LABELS_RATIO ? o = me() : o = de(), o.domain(this.getScaleDomain(e)), o;
  }
  getHighestDomainThreshold() {
    const e = l(this.model.getOptions(), "axes"), t = this.getDomainAxisPosition(), { thresholds: n } = e[t];
    if (!Array.isArray(n) || Array.isArray(n) && !n.length)
      return null;
    const s = this.getDomainScale(), o = n.sort((r, c) => c.value - r.value)[0];
    return this.getScaleTypeByPosition(t) === d.TIME && (typeof o.value == "string" || o.value.getTime === void 0) && (o.value = new Date(o.value)), {
      threshold: o,
      scaleValue: s(o.value)
    };
  }
  getHighestRangeThreshold() {
    const e = l(this.model.getOptions(), "axes"), t = this.getRangeAxisPosition(), { thresholds: n } = e[t];
    if (!Array.isArray(n) || Array.isArray(n) && !n.length)
      return null;
    const s = this.getRangeScale(), o = n.sort((a, r) => r.value - a.value)[0];
    return {
      threshold: o,
      scaleValue: s(o.value)
    };
  }
}
function Je(i, e) {
  const t = new Date(i[0]), n = new Date(i[1]);
  return Ue(n, t) > 1 ? [We(t, e), ee(n, e)] : _e(n, t) > 1 ? [je(t, e), C(n, e)] : He(n, t) > 1 ? [$e(t, e), J(n, e)] : Ye(n, t) > 1 ? [Ke(t, e), Q(n, e)] : $(n, t) > 30 ? [
    K(t, e * 30),
    E(n, e * 30)
  ] : $(n, t) > 1 ? [K(t, e), E(n, e)] : j(n, t) > 15 ? [
    W(t, e * 15),
    I(n, e * 15)
  ] : j(n, t) > 1 ? [W(t, e), I(n, e)] : [t, n];
}
function Qe([i, e], t, n) {
  const o = (e - i) * t, a = e <= 0 && e + o > 0 ? 0 : e + o;
  let r = i >= 0 && i - o < 0 ? 0 : i - o;
  if (n === d.LOG && r <= 0) {
    if (i <= 0)
      throw Error("Data must have values greater than 0 if log scale type is used.");
    r = i;
  }
  return [r, a];
}
class ut extends O {
  constructor() {
    super(...arguments), this.curveTypes = {
      curveLinear: ge,
      curveLinearClosed: he,
      curveBasis: fe,
      curveBasisClosed: pe,
      curveBasisOpen: ve,
      curveBundle: xe,
      curveCardinal: De,
      curveCardinalClosed: ye,
      curveCardinalOpen: Oe,
      curveCatmullRom: Ae,
      curveCatmullRomClosed: Te,
      curveCatmullRomOpen: Me,
      curveMonotoneX: Se,
      curveMonotoneY: Pe,
      curveNatural: Re,
      curveStep: Be,
      curveStepAfter: Le,
      curveStepBefore: Ee
    };
  }
  getD3Curve() {
    let e = "curveLinear";
    const t = this.model.getOptions().curve;
    if (t && (typeof t == "string" ? e = t : e = t.name), this.curveTypes[e]) {
      let n = this.curveTypes[e];
      return t && Object.keys(t).forEach((s) => {
        n[s] && (n = n[s](t[s]));
      }), n;
    }
    return console.warn(`The curve type '${e}' is invalid, using 'curveLinear' instead`), this.curveTypes.curveLinear;
  }
}
class ct extends O {
  isZoomBarEnabled() {
    if (!this.services.cartesianScales || !l(this.model.getOptions(), "zoomBar", "top", "enabled"))
      return !1;
    this.services.cartesianScales.findDomainAndRangeAxes();
    const e = this.services.cartesianScales.getMainXAxisPosition(), t = l(
      this.model.getOptions(),
      "axes",
      e,
      "scaleType"
    );
    return e === u.BOTTOM && t === d.TIME;
  }
  // get display data for zoom bar
  // basically it's sum of value grouped by time
  getZoomBarData() {
    const e = this.model.getZoomBarData();
    return e && e.length > 1 ? e : this.model.getDisplayData();
  }
  getDefaultZoomBarDomain(e) {
    if (!this.services.zoom)
      throw new Error("Services zoom not defined");
    const t = e || this.services.zoom.getZoomBarData(), { cartesianScales: n } = this.services;
    if (!n)
      throw new Error("Services cartesianScales undefined");
    const s = n.getMainXAxisPosition(), o = n.getDomainIdentifier(), a = l(this.model.getOptions(), "axes", s, "domain");
    if (Array.isArray(a) && a.length === 2)
      return a;
    if (!s)
      throw new Error("Not defined: mainXAxisPosition");
    return n.extendsDomain(
      s,
      q(t, (r) => r[o])
    );
  }
  handleDomainChange(e, t = { dispatchEvent: !0 }) {
    var n;
    this.model.set({ zoomDomain: e }, { animate: !1 }), t.dispatchEvent && ((n = this.services.events) == null || n.dispatchEvent(B.ZoomDomain.CHANGE, {
      newDomain: e
    }));
  }
  getZoomRatio() {
    return l(this.model.getOptions(), "zoomBar", "zoomRatio");
  }
  // filter out data not inside zoom domain
  // to get better range value for axis label
  filterDataForRangeAxis(e, t) {
    var a;
    const n = this.model.get("zoomDomain"), s = Object.assign(
      { stacked: !1 },
      // default configs
      t
    ), o = l(this.model.getOptions(), "zoomBar", "updateRangeAxis");
    if (this.isZoomBarEnabled() && o && n) {
      const r = s.stacked ? "sharedStackKey" : (a = this.services.cartesianScales) == null ? void 0 : a.getDomainIdentifier(), c = e.filter(
        (h) => new Date(h[r]) >= n[0] && new Date(h[r]) <= n[1]
      );
      if (c.length > 0)
        return c;
    }
    return e;
  }
  zoomIn(e = this.getZoomRatio()) {
    var S;
    const t = this.model.get("zoomDomain"), n = oe.handleWidth, s = (S = this.services.cartesianScales) == null ? void 0 : S.getMainXScale().copy();
    s.domain(this.getDefaultZoomBarDomain());
    const o = s(t[0]), a = s(t[1]);
    if (a - o < n + 1)
      return;
    const r = s.range(), c = a - o, h = Math.min((r[1] - r[0]) / 2 * (e / 2), c / 2);
    let v = o + h, y = a - h;
    v >= y && (v = o + c / 2 - n / 2, y = a - c / 2 + n / 2);
    const A = [s.invert(v), s.invert(y)];
    (t[0].valueOf() !== A[0].valueOf() || t[1].valueOf() !== A[1].valueOf()) && this.handleDomainChange(A);
  }
  zoomOut(e = this.getZoomRatio()) {
    const t = this.model.get("zoomDomain");
    if (!this.services.cartesianScales)
      throw new Error("Services cartesianScales undefined");
    const n = this.services.cartesianScales.getMainXScale().copy();
    n.domain(this.getDefaultZoomBarDomain());
    const s = n(t[0]), o = n(t[1]), a = n.range(), r = (a[1] - a[0]) / 2 * (e / 2), c = Math.max(s - r, a[0]), h = Math.min(o + r, a[1]), v = [n.invert(c), n.invert(h)];
    (t[0].valueOf() !== v[0].valueOf() || t[1].valueOf() !== v[1].valueOf()) && this.handleDomainChange(v);
  }
  resetZoomDomain() {
    const e = this.model.get("zoomDomain"), t = this.getDefaultZoomBarDomain();
    (e[0].valueOf() !== t[0].valueOf() || e[1].valueOf() !== t[1].valueOf()) && this.handleDomainChange(t);
  }
  // check if current zoom domain is already the min zoom domain
  // when toolbar is rendered, we don't render chart yet
  // don't depend on scale range
  isMinZoomDomain() {
    const e = this.model.get("zoomDomain"), t = this.getDefaultZoomBarDomain();
    if (!e || !t)
      return !1;
    const n = e[1].valueOf() - e[0].valueOf(), s = t[1].valueOf() - t[0].valueOf(), o = l(this.model.getOptions(), "zoomBar", "minZoomRatio");
    return n / s < o;
  }
  // check if current zoom domain is already the max zoom domain
  isMaxZoomDomain() {
    const e = this.model.get("zoomDomain"), t = this.getDefaultZoomBarDomain();
    return !!(e && t && e[0].valueOf() === t[0].valueOf() && e[1].valueOf() === t[1].valueOf());
  }
  isEmptyState() {
    return this.getZoomBarData().length === 0;
  }
  isZoomBarLoading(e) {
    return l(this.model.getOptions(), "zoomBar", e, "loading");
  }
  isZoomBarLocked(e) {
    return l(this.model.getOptions(), "zoomBar", e, "locked");
  }
}
export {
  it as C,
  ot as E,
  at as F,
  rt as T,
  ct as Z,
  lt as a,
  ut as b,
  qe as f
};
//# sourceMappingURL=index-b0e98af9.mjs.map
