import { S as z, V as F, ab as U, g as u, z as b, e as G, y as j, a9 as M, M as k, ac as L, f as _, v as V, a0 as K, a1 as y, O as R, _ as x } from "../color-scale-utils-faf67b75.mjs";
import { bin as Z, stack as A, stackOffsetDiverging as H, scaleOrdinal as $, quantile as E, ascending as Q, min as P, max as N, extent as W, scaleLinear as X, scaleQuantize as Y } from "d3";
import { S as D, _ as B, d as w, e as O, s as J } from "../enums-a96ef472.mjs";
import { b as tt } from "../_baseEach-76cda8a8.mjs";
function et(h, t, e, s) {
  for (var a = -1, o = h == null ? 0 : h.length; ++a < o; ) {
    var i = h[a];
    t(s, i, e(i), h);
  }
  return s;
}
function st(h, t, e, s) {
  return tt(h, function(a, o, i) {
    t(s, a, e(a), i);
  }), s;
}
function at(h, t) {
  return function(e, s) {
    var a = z(e) ? et : st, o = t ? t() : {};
    return a(e, h, F(s), o);
  };
}
function ot(h) {
  for (var t = -1, e = h == null ? 0 : h.length, s = {}; ++t < e; ) {
    var a = h[t];
    s[a[0]] = a[1];
  }
  return s;
}
var it = Object.prototype, nt = it.hasOwnProperty, rt = at(function(h, t, e) {
  nt.call(h, e) ? h[e].push(t) : U(h, e, [t]);
});
const lt = rt;
class m {
  constructor(t) {
    this.state = {
      options: {}
    }, this.colorScale = {}, this.colorClassNames = {}, this.services = t;
  }
  getAllDataFromDomain(t) {
    if (!this.getData())
      return null;
    const e = this.getOptions();
    let s = this.getData();
    const a = this.getDataGroups(), { groupMapsTo: o } = u(e, "data"), i = u(e, "axes");
    return t && (s = s.filter((n) => t.includes(n[o]))), i && Object.keys(i).forEach((n) => {
      const r = i[n].mapsTo, l = i[n].scaleType;
      if ((l === D.LINEAR || l === D.LOG) && (s = s.map((c) => ({
        ...c,
        [r]: c[r] === null ? c[r] : Number(c[r])
      }))), r && i[n].domain)
        if (l === D.LABELS)
          s = s.filter(
            (c) => i[n].domain.includes(c[r])
          );
        else {
          const [c, p] = i[n].domain;
          s = s.filter(
            (g) => !(r in g) || g[r] >= c && g[r] <= p
          );
        }
    }), s.filter((n) => a.find((r) => r.name === n[o]));
  }
  /**
   * Charts that have group configs passed into them, only want to retrieve the display data relevant to that chart
   * @param groups the included datasets for the particular chart
   */
  getDisplayData(t) {
    if (!this.get("data"))
      return null;
    const { ACTIVE: e } = b.items.status, s = this.getDataGroups(t), { groupMapsTo: a } = this.getOptions().data;
    return this.getAllDataFromDomain(t).filter((i) => s.find(
      (n) => n.name === i[a] && n.status === e
    ));
  }
  getData() {
    return this.get("data");
  }
  isDataEmpty() {
    return !this.getData().length;
  }
  /**
   *
   * @param newData The new raw data to be set
   */
  setData(t) {
    const e = this.sanitize(G(t)), s = this.generateDataGroups(e);
    return this.set({
      data: e,
      dataGroups: s
    }), e;
  }
  getDataGroups(t) {
    return u(this.getOptions(), "data", "loading") ? [] : t ? this.get("dataGroups").filter((s) => t.includes(s.name)) : this.get("dataGroups");
  }
  getActiveDataGroups(t) {
    const { ACTIVE: e } = b.items.status;
    return this.getDataGroups(t).filter((s) => s.status === e);
  }
  getDataGroupNames(t) {
    return this.getDataGroups(t).map((s) => s.name);
  }
  getActiveDataGroupNames(t) {
    return this.getActiveDataGroups(t).map((s) => s.name);
  }
  aggregateBinDataByGroup(t) {
    return lt(t, "group");
  }
  getBinConfigurations() {
    const t = this.getDisplayData(), e = this.getOptions(), s = this.services.cartesianScales.getMainXAxisPosition(), a = this.services.cartesianScales.getDomainIdentifier(), o = e.axes[s], { groupMapsTo: i } = e.data, { bins: n = j.defaultBins } = o, r = Array.isArray(n), l = Z().value((d) => d[a]).thresholds(n)(t);
    if (r)
      l[l.length - 1].x1 = n[n.length - 1];
    else {
      const d = l[0].x1 - l[0].x0;
      l[l.length - 1].x1 = +l[l.length - 1].x0 + d;
    }
    const c = r ? [n[0], n[n.length - 1]] : [l[0].x0, l[l.length - 1].x1], p = Array.from(new Set(t.map((d) => d[i]))), g = [];
    return l.forEach((d) => {
      const f = `${d.x0}-${d.x1}`, T = this.aggregateBinDataByGroup(d);
      p.forEach((C) => {
        g.push({
          group: C,
          key: f,
          value: T[C] || 0,
          bin: d.x0
        });
      });
    }), {
      bins: l,
      binsDomain: c
    };
  }
  getBinnedStackedData() {
    const t = this.getOptions(), { groupMapsTo: e } = t.data, s = this.getActiveDataGroupNames(), { bins: a } = this.getBinConfigurations(), o = this.getDataValuesGroupedByKeys({
      bins: a
    });
    return A().keys(s)(o).map((i, n) => Object.keys(i).filter((r) => !isNaN(r)).map((r) => {
      const l = i[r];
      return l[e] = s[n], l;
    }));
  }
  getGroupedData(t) {
    const e = this.getDisplayData(t), s = {}, { groupMapsTo: a } = this.getOptions().data;
    return e.map((o) => {
      const i = o[a];
      s[i] !== null && s[i] !== void 0 ? s[i].push(o) : s[i] = [o];
    }), Object.keys(s).map((o) => ({
      name: o,
      data: s[o]
    }));
  }
  getStackKeys({ bins: t = null, groups: e = null } = { bins: null, groups: null }) {
    const s = this.getOptions(), a = this.getDisplayData(e);
    let o;
    t ? o = t.map((r) => `${r.x0}-${r.x1}`) : o = M(
      a.map((r) => {
        const l = this.services.cartesianScales.getDomainIdentifier(r);
        return r[l] instanceof Date ? k(r[l]) : r[l] && typeof r[l].toString == "function" ? r[l].toString() : r[l];
      })
    );
    const i = this.services.cartesianScales.domainAxisPosition, n = s.axes[i].scaleType;
    return n === D.TIME ? o.sort((r, l) => {
      const c = new Date(r), p = new Date(l);
      return c - p;
    }) : (n === D.LOG || n === D.LINEAR) && o.sort((r, l) => r - l), o;
  }
  getDataValuesGroupedByKeys({ bins: t = null, groups: e = null }) {
    const s = this.getOptions(), { groupMapsTo: a } = s.data, o = this.getDisplayData(e), i = this.getDataGroupNames(), n = this.getStackKeys({ bins: t, groups: e });
    return t ? n.map((r) => {
      const [l, c] = r.split("-"), p = { x0: l, x1: c }, g = t.find((d) => d.x0.toString() === l.toString());
      return i.forEach((d) => {
        p[d] = g.filter(
          (f) => f[a] === d
        ).length;
      }), p;
    }) : n.map((r) => {
      const l = { sharedStackKey: r };
      return i.forEach((c) => {
        const p = o.find((d) => {
          const f = this.services.cartesianScales.getDomainIdentifier(d);
          return d[a] === c && Object.prototype.hasOwnProperty.call(d, f) && (d[f] instanceof Date ? k(d[f]) === r : d[f].toString() === r);
        }), g = this.services.cartesianScales.getRangeIdentifier(l);
        l[c] = p ? p[g] : null;
      }), l;
    });
  }
  getStackedData({ percentage: t = !1, groups: e = null, divergent: s = !1 }) {
    const a = this.getOptions(), { groupMapsTo: o } = a.data, i = this.getActiveDataGroupNames(e), n = this.getDataValuesGroupedByKeys({
      groups: e
    });
    if (t) {
      const l = ot(n.map((c) => [c.sharedStackKey, 0]));
      n.forEach((c) => {
        i.forEach((p) => {
          l[c.sharedStackKey] += c[p];
        });
      }), n.forEach((c) => {
        i.forEach((p) => {
          const g = l[c.sharedStackKey];
          l[c.sharedStackKey] ? c[p] = c[p] / g * 100 : c[p] = 0;
        });
      });
    }
    return (s ? A().offset(H) : A()).keys(i)(n).map((l, c) => Object.keys(l).filter((p) => !isNaN(p)).map((p) => {
      const g = l[p];
      return g[o] = i[c], g;
    }));
  }
  /**
   * @return {Object} The chart's options
   */
  getOptions() {
    return this.state.options;
  }
  set(t, e) {
    this.state = Object.assign({}, this.state, t);
    const s = Object.assign(
      { skipUpdate: !1, animate: !0 },
      // default configs
      e
    );
    s.skipUpdate || this.update(s.animate);
  }
  get(t) {
    return t ? this.state[t] : this.state;
  }
  /**
   *
   * @param newOptions New options to be set
   */
  setOptions(t) {
    const e = this.getOptions();
    L(e, t), this.set({
      options: _(e, t)
    });
  }
  /**
   *
   * Updates miscellanous information within the model
   * such as the color scales, or the legend data labels
   */
  update(t = !0) {
    this.getDisplayData() && (this.updateAllDataGroups(), this.setCustomColorScale(), this.setColorClassNames(), this.services.events.dispatchEvent(B.Model.UPDATE, { animate: t }));
  }
  /*
   * Data labels
   */
  toggleDataLabel(t) {
    const { ACTIVE: e, DISABLED: s } = b.items.status, a = this.getDataGroups(), o = a.some((c) => c.status === s), i = a.filter((c) => c.status === e);
    if (o)
      if (i.length === 1 && i[0].name === t)
        a.forEach((c, p) => {
          a[p].status = e;
        });
      else {
        const c = a.findIndex((p) => p.name === t);
        a[c].status = a[c].status === s ? e : s;
      }
    else
      a.forEach((c, p) => {
        a[p].status = c.name === t ? e : s;
      });
    const n = a.filter((c) => c.status === e), r = this.getOptions();
    a.some((c) => c.status === s) ? r.data.selectedGroups = n.map((c) => c.name) : r.data.selectedGroups = [], this.services.events.dispatchEvent(B.Legend.ITEMS_UPDATE, {
      dataGroups: a
    }), this.set({
      dataGroups: a
    });
  }
  /**
   * Should the data point be filled?
   * @param group
   * @param key
   * @param data
   * @param defaultFilled the default for this chart
   */
  getIsFilled(t, e, s, a) {
    const o = this.getOptions();
    return o.getIsFilled ? o.getIsFilled(t, e, s, a) : a;
  }
  getFillColor(t, e, s) {
    const a = this.getOptions(), o = u(this.colorScale, t);
    return a.getFillColor ? a.getFillColor(t, e, s, o) : o;
  }
  getStrokeColor(t, e, s) {
    const a = this.getOptions(), o = u(this.colorScale, t);
    return a.getStrokeColor ? a.getStrokeColor(t, e, s, o) : o;
  }
  isUserProvidedColorScaleValid() {
    const t = u(this.getOptions(), "color", "scale"), e = this.getDataGroups();
    return t == null || Object.keys(t).length == 0 ? !1 : e.some(
      (s) => Object.keys(t).includes(s.name)
    );
  }
  getColorClassName(t) {
    const e = this.colorClassNames(t.dataGroupName);
    let s = t.originalClassName;
    return t.classNameTypes.forEach(
      (a) => s = t.originalClassName ? `${s} ${a}-${e}` : `${a}-${e}`
    ), s || "";
  }
  /**
   * For charts that might hold an associated status for their dataset
   */
  getStatus() {
    return null;
  }
  getAllDataGroupsNames() {
    return this.allDataGroups;
  }
  /**
   * Converts data provided in the older format to tabular
   *
   */
  transformToTabularData(t) {
    console.warn(
      "We've updated the charting data format to be tabular by default. The current format you're using is deprecated and will be removed in v1.0, read more here https://carbon-design-system.github.io/carbon-charts/?path=/story/docs-tutorials--tabular-data-format"
    );
    const e = [], { datasets: s, labels: a } = t;
    return s.forEach((o) => {
      o.data.forEach((i, n) => {
        let r;
        const l = u(o, "label");
        if (l === null) {
          const p = u(a, n);
          p ? r = p : r = "Ungrouped";
        } else
          r = l;
        const c = {
          group: r,
          key: a[n]
        };
        isNaN(i) ? (c.value = i.value, c.date = i.date) : c.value = i, e.push(c);
      });
    }), e;
  }
  getTabularDataArray() {
    return [];
  }
  exportToCSV() {
    const t = this.getTabularDataArray().map(
      (a) => a.map((o) => `"${o === "&ndash;" ? "–" : o}"`)
    );
    let e = "", s = "";
    t.forEach(function(a, o) {
      s = a.join(","), e += o < t.length ? s + `
` : s;
    }), this.services.files.downloadCSV(e, "myChart.csv");
  }
  getTabularData(t) {
    return Array.isArray(t) ? t : this.transformToTabularData(t);
  }
  sanitize(t) {
    return t = this.getTabularData(t), t;
  }
  /*
   * Data groups
   */
  updateAllDataGroups() {
    this.allDataGroups ? this.getDataGroupNames().forEach((t) => {
      this.allDataGroups.indexOf(t) === -1 && this.allDataGroups.push(t);
    }) : this.allDataGroups = this.getDataGroupNames();
  }
  generateDataGroups(t) {
    const { groupMapsTo: e } = this.getOptions().data, { ACTIVE: s, DISABLED: a } = b.items.status, o = this.getOptions(), i = M(t.map((r) => r[e]));
    o.data.selectedGroups.length && (o.data.selectedGroups.every(
      (l) => i.includes(l)
    ) || (o.data.selectedGroups = []));
    const n = (r) => !o.data.selectedGroups.length || o.data.selectedGroups.includes(r) ? s : a;
    return i.map((r) => ({
      name: r,
      status: n(r)
    }));
  }
  /*
   * Fill scales
   */
  setCustomColorScale() {
    if (!this.isUserProvidedColorScaleValid())
      return;
    const t = this.getOptions(), e = u(t, "color", "scale");
    Object.keys(e).forEach((a) => {
      this.allDataGroups.includes(a) || console.warn(`"${a}" does not exist in data groups.`);
    }), this.allDataGroups.filter(
      (a) => e[a]
    ).forEach(
      (a) => this.colorScale[a] = e[a]
    );
  }
  /*
   * Color palette
   */
  setColorClassNames() {
    const t = u(this.getOptions(), "color", "pairing");
    let e = u(t, "numberOfVariants");
    (!e || e < this.allDataGroups.length) && (e = this.allDataGroups.length);
    let s = u(t, "option");
    const a = V.pairingOptions, o = e > 5 ? 14 : e, i = `${o}-color`;
    s = s <= a[i] ? s : 1;
    const n = this.allDataGroups.map(
      (r, l) => `${o}-${s}-${l % 14 + 1}`
    );
    this.colorClassNames = $().range(n).domain(this.allDataGroups);
  }
}
class S extends m {
  // can't be protected as it's used by two-dimensional-axes.ts
  constructor(t) {
    super(t), this.axisFlavor = w.DEFAULT;
  }
  // get the scales information
  // needed for getTabularArray()
  assignRangeAndDomains() {
    const { cartesianScales: t } = this.services, e = this.getOptions(), s = t.isDualAxes(), a = {
      primaryDomain: t.domainAxisPosition,
      primaryRange: t.rangeAxisPosition,
      secondaryDomain: null,
      secondaryRange: null
    };
    return s && (a.secondaryDomain = t.secondaryDomainAxisPosition, a.secondaryRange = t.secondaryRangeAxisPosition), Object.keys(a).forEach((o) => {
      const i = a[o];
      t.scales[i] ? a[o] = {
        position: i,
        label: t.getScaleLabel(i),
        identifier: u(e, "axes", i, "mapsTo")
      } : a[o] = null;
    }), a;
  }
  getTabularDataArray() {
    const t = this.getDisplayData(), e = this.getOptions(), { groupMapsTo: s } = e.data, { cartesianScales: a } = this.services, { primaryDomain: o, primaryRange: i, secondaryDomain: n, secondaryRange: r } = this.assignRangeAndDomains(), l = a.getDomainAxisScaleType();
    let c;
    return l === D.TIME && (c = (g) => K(g, "MMM d, yyyy")), [
      [
        "Group",
        o.label,
        i.label,
        ...n ? [n.label] : [],
        ...r ? [r.label] : []
      ],
      ...t.map((g) => [
        g[s],
        g[o.identifier] === null ? "&ndash;" : c ? c(g[o.identifier]) : g[o.identifier],
        g[i.identifier] === null || isNaN(g[i.identifier]) ? "&ndash;" : g[i.identifier].toLocaleString(),
        ...n ? [
          g[n.identifier] === null ? "&ndash;" : g[n.identifier]
        ] : [],
        ...r ? [
          g[r.identifier] === null || isNaN(g[r.identifier]) ? "&ndash;" : g[r.identifier]
        ] : []
      ])
    ];
  }
  setData(t) {
    let e;
    if (t && (e = super.setData(t), u(this.getOptions(), "zoomBar", O.TOP, "enabled"))) {
      const s = u(
        this.getOptions(),
        "zoomBar",
        O.TOP,
        "data"
      );
      this.setZoomBarData(s);
    }
    return e;
  }
  /**
   * @param zoomBarData any special zoom bar data to use instead of the model data
   */
  setZoomBarData(t) {
    const e = t ? this.sanitize(G(t)) : this.getDisplayData();
    let s = e;
    const { cartesianScales: a } = this.services;
    if (e && a.domainAxisPosition && a.rangeAxisPosition) {
      const o = a.getDomainIdentifier(), i = a.getRangeIdentifier();
      let n = e.map((r) => r[o].getTime());
      n = M(n).sort(), s = n.map((r) => {
        let l = 0;
        const c = {};
        return e.forEach((p) => {
          p[o].getTime() === r && (l += p[i]);
        }), c[o] = new Date(r), c[i] = l, c;
      });
    }
    this.set({ zoomBarData: s });
  }
  getZoomBarData() {
    return this.get("zoomBarData");
  }
  sanitizeDateValues(t) {
    const e = this.getOptions();
    if (!e.axes)
      return t;
    const s = [];
    return Object.keys(O).forEach((a) => {
      const o = O[a], i = e.axes[o];
      if (i && i.scaleType === D.TIME) {
        const n = i.mapsTo;
        (n !== null || n !== void 0) && s.push(n);
      }
    }), s.length > 0 && t.forEach((a) => {
      s.forEach((o) => {
        u(a, o, "getTime") === null && (a[o] = new Date(a[o]));
      });
    }), t;
  }
  sanitize(t) {
    return t = super.sanitize(t), t = this.sanitizeDateValues(t), t;
  }
}
class gt extends S {
  constructor(t) {
    super(t);
  }
  getTabularDataArray() {
    const t = this.getDisplayData();
    return t.sort((s, a) => s.source.localeCompare(a.source)), [
      ["Source", "Target", "Value"],
      ...t.map((s) => [s.source, s.target, s.value])
    ];
  }
}
class dt extends S {
  constructor(t) {
    super(t);
  }
  getBoxQuartiles(t) {
    return {
      q_25: E(t, 0.25),
      q_50: E(t, 0.5),
      q_75: E(t, 0.75)
    };
  }
  getBoxplotData() {
    const t = this.getOptions(), { groupMapsTo: e } = t.data, s = this.getGroupedData(), a = [];
    for (const { name: o, data: i } of s) {
      const n = this.services.cartesianScales.getRangeIdentifier(), r = i.map((v) => v[n]).sort(Q), l = {
        [e]: o,
        counts: r,
        quartiles: this.getBoxQuartiles(r),
        outliers: null,
        whiskers: null
      }, c = l.quartiles.q_25, p = l.quartiles.q_75, g = (p - c) * 1.5, d = c - g, f = p + g, T = [], C = [];
      for (const v of r)
        v < d || v > f ? T.push(v) : C.push(v);
      l.outliers = T;
      const I = P(C), q = N(C);
      l.whiskers = {
        min: I || P([l.quartiles.q_25, l.quartiles.q_50, l.quartiles.q_75]),
        max: q || N([l.quartiles.q_25, l.quartiles.q_50, l.quartiles.q_75])
      }, a.push(l);
    }
    return a;
  }
  getTabularDataArray() {
    const t = this.getOptions(), { groupMapsTo: e } = t.data, s = this.getBoxplotData();
    return [
      ["Group", "Minimum", "Q1", "Median", "Q3", "Maximum", "IQR", "Outlier(s)"],
      ...s.map((o) => {
        let i = u(o, "outliers");
        return (i === null || i.length === 0) && (i = ["&ndash;"]), [
          o[e],
          u(o, "whiskers", "min") !== null ? u(o, "whiskers", "min").toLocaleString() : "&ndash;",
          u(o, "quartiles", "q_25") !== null ? u(o, "quartiles", "q_25").toLocaleString() : "&ndash;",
          u(o, "quartiles", "q_50") !== null ? u(o, "quartiles", "q_50").toLocaleString() : "&ndash;",
          u(o, "quartiles", "q_75") !== null ? u(o, "quartiles", "q_75").toLocaleString() : "&ndash;",
          u(o, "whiskers", "max") !== null ? u(o, "whiskers", "max").toLocaleString() : "&ndash;",
          u(o, "quartiles", "q_75") !== null && u(o, "quartiles", "q_25") !== null ? (u(o, "quartiles", "q_75") - u(o, "quartiles", "q_25")).toLocaleString() : "&ndash;",
          i.map((n) => n.toLocaleString()).join(",")
        ];
      })
    ];
  }
  setColorClassNames() {
    const e = u(this.getOptions(), "color", "pairing");
    let s = u(e, "option");
    const a = V.pairingOptions;
    s = s <= a["1-color"] ? s : 1;
    const o = this.allDataGroups.map(() => `1-${s}-1`);
    this.colorClassNames = $().range(o).domain(this.allDataGroups);
  }
}
class Dt extends S {
  constructor(t) {
    super(t);
  }
  /**
   * Determines the index of the performance area titles to use
   * @param datum
   * @returns number
   */
  getMatchingRangeIndexForDatapoint(t) {
    let e;
    for (let s = t.ranges.length - 1; s > 0; s--) {
      const a = t.ranges[s];
      if (t.value >= a)
        return e = s, e;
    }
    return 0;
  }
  getTabularDataArray() {
    const t = this.getDisplayData(), e = this.getOptions(), { groupMapsTo: s } = e.data, a = this.services.cartesianScales.getRangeIdentifier(), o = u(e, "bullet", "performanceAreaTitles");
    return [
      ["Title", "Group", "Value", "Target", "Percentage", "Performance"],
      ...t.map((n) => [
        n.title,
        n[s],
        n.value === null ? "&ndash;" : n.value,
        u(n, "marker") === null ? "&ndash;" : n.marker,
        u(n, "marker") === null ? "&ndash;" : `${Math.floor(n[a] / n.marker * 100)}%`,
        o[this.getMatchingRangeIndexForDatapoint(n)]
      ])
    ];
  }
}
class ft extends m {
  constructor(t) {
    super(t), this._colorScale = void 0, this._matrix = {};
  }
  /**
   * @override
   * @param value
   * @returns string
   */
  getFillColor(t) {
    return this._colorScale(t);
  }
  /**
   * Helper function that will generate a dictionary
   */
  getCombinedData() {
    if (y(this._matrix)) {
      const t = this.getOptions(), e = this.getDisplayData();
      !y(e) && !y(t.geoData.objects.countries) && (t.geoData.objects.countries.geometries.forEach((s) => {
        this._matrix[s.properties.NAME] = s;
      }), e.forEach((s) => {
        this._matrix[s.name] ? this._matrix[s.name].value = s.value || null : console.warn(`Data point ${s} is missing geographical data.`);
      }));
    }
    return this._matrix;
  }
  /**
   * Generate tabular data from display data
   * @returns Array<Object>
   */
  getTabularDataArray() {
    const t = this.getDisplayData();
    return [
      ["Country ID", "Country Name", "Value"],
      ...t.map((s) => [
        s.id === null ? "&ndash;" : s.id,
        s.name,
        s.value
      ])
    ];
  }
  // Uses quantize scale to return class names
  getColorClassName(t) {
    return `${t.originalClassName} ${this._colorScale(t.value)}`;
  }
  setColorClassNames() {
    const t = u(this.getOptions(), "color");
    this._colorScale = R(this.getDisplayData(), t);
  }
}
class mt extends m {
  constructor(t) {
    super(t), this.parentNode = !1, this.set({ depth: 2 }, { skipUpdate: !0 });
  }
  setData(t) {
    super.setData(t), this.setDataGroups(), t.length === 1 && (this.parentNode = !0), this.setZoom();
  }
  setOptions(t) {
    const e = this.getOptions(), s = _({}, t, this.getZoomOptions(t));
    L(e, s);
    const a = this.getHierarchyLevel(), o = u(e, "circlePack", "hierarchyLevel");
    this.set({
      options: _(e, s),
      depth: o && o < 4 ? o : a
    });
  }
  getZoomOptions(t) {
    if (!this.getDisplayData())
      return {};
    const e = this.getDisplayData(), s = t || this.getOptions(), a = e.length === 1 && u(e, 0, "children") ? u(e, 0, "children") : e;
    let o = this.getHierarchyLevel();
    return a.some((i) => {
      if (i.children && i.children.some((n) => n.children))
        return o = 3, !1;
    }), u(s, "canvasZoom", "enabled") === !0 && o > 2 ? {
      legend: {
        additionalItems: [
          {
            type: J.ZOOM,
            name: "Click to zoom"
          }
        ]
      }
    } : null;
  }
  setZoom(t) {
    this.setOptions(this.getZoomOptions(t));
  }
  // update the hierarchy level
  updateHierarchyLevel(t) {
    this.set({ depth: t });
  }
  getHierarchyLevel() {
    return this.get("depth");
  }
  hasParentNode() {
    return this.parentNode;
  }
  // set the datagroup name on the items that are it's children
  setDataGroups() {
    const t = this.getData(), e = this.getOptions(), { groupMapsTo: s } = e.data, a = t.map((o) => {
      const i = o[s];
      return this.setChildrenDataGroup(o, i);
    });
    this.set(
      {
        data: a
      },
      { skipUpdate: !0 }
    );
  }
  // sets name recursively down the node tree
  setChildrenDataGroup(t, e) {
    return t.children ? {
      ...t,
      dataGroupName: e,
      children: t.children.map((s) => this.setChildrenDataGroup(s, e))
    } : { ...t, dataGroupName: e };
  }
  getTabularDataArray() {
    const t = this.getDisplayData(), e = [["Child", "Parent", "Value"]];
    return t.forEach((s) => {
      let a = s.value ? s.value : 0;
      s.children && (a += this.getChildrenDatums(s.children, s.name, e, 0)), e.push(["&ndash;", s.name, a]);
    }), e;
  }
  /**
   * Recursively determine the relationship between all the nested elements in the child
   * @param children: Object
   * @param parent: String
   * @param result: Array<Object>
   * @param totalSum: number
   * @returns: number
   */
  getChildrenDatums(t, e, s = [], a = 0) {
    const o = e;
    return t.forEach((i) => {
      const n = i.name;
      let r = 0;
      if (i.children)
        i.children.length > 0 && (typeof i.value == "number" && (a += i.value), r += this.getChildrenDatums(i.children, n, s, r), s.push([n, o, r]), a += r);
      else {
        let l = 0;
        typeof i.value == "number" && (l = i.value, a += i.value), s.push([i.name, o, l]);
      }
    }), a;
  }
}
class yt extends m {
  constructor(t) {
    super(t);
  }
  getTabularData(t) {
    const e = super.getTabularData(t);
    return t !== e && e.forEach((s) => {
      s.key && s.key !== s.group && (s.group = s.key);
    }), e;
  }
  getTabularDataArray() {
    const t = this.getDisplayData(), e = this.getOptions(), { groupMapsTo: s } = e.data;
    return [
      ["Group", "Value"],
      ...t.map((o) => [
        o[s],
        o.value === null ? "&ndash;" : o.value.toLocaleString()
      ])
    ];
  }
  sanitize(t) {
    return this.getTabularData(t).sort((s, a) => a.value - s.value);
  }
}
class vt extends m {
  constructor(t) {
    super(t);
  }
  getDataGroups() {
    return super.getDataGroups().filter((t) => t.name !== "delta");
  }
  getTabularDataArray() {
    const t = this.getDisplayData(), e = this.getOptions(), { groupMapsTo: s } = e.data;
    return [
      ["Group", "Value"],
      ...t.map((o) => [
        o[s],
        o.value === null ? "&ndash;" : o.value.toLocaleString()
      ])
    ];
  }
}
class xt extends S {
  constructor(t) {
    super(t), this.axisFlavor = w.HOVERABLE, this._colorScale = void 0, this._domains = [], this._ranges = [], this._matrix = {};
    const e = u(this.getOptions(), "axes");
    if (u(e, "left", "scaleType") && u(e, "left", "scaleType") !== D.LABELS || u(e, "right", "scaleType") && u(e, "right", "scaleType") !== D.LABELS || u(e, "top", "scaleType") && u(e, "top", "scaleType") !== D.LABELS || u(e, "bottom", "scaleType") && u(e, "bottom", "scaleType") !== D.LABELS)
      throw Error("Heatmap only supports label scaletypes.");
  }
  /**
   * Get min and maximum value of the display data
   * @returns Array consisting of smallest and largest values in  data
   */
  getValueDomain() {
    const t = W(this.getDisplayData(), (s) => s.value), e = X().domain(t).nice().domain();
    if (e[0] > 0)
      e[0] = 0;
    else if (e[0] === 0 && e[1] === 0)
      return [0, 1];
    return e[0] < 0 && e[1] > 0 && (Math.abs(e[0]) > e[1] ? e[1] = Math.abs(e[0]) : e[0] = -e[1]), e;
  }
  /**
   * @override
   * @param value
   * @returns string
   */
  getFillColor(t) {
    return this._colorScale(t);
  }
  /**
   * Generate a list of all unique domains
   * @returns String[]
   */
  getUniqueDomain() {
    if (y(this._domains)) {
      const t = this.getDisplayData(), { cartesianScales: e } = this.services, s = e.getDomainIdentifier(), a = e.getMainXAxisPosition(), o = e.getCustomDomainValuesByposition(a);
      if (o)
        return o;
      this._domains = Array.from(
        new Set(
          t.map((i) => i[s])
        )
      );
    }
    return this._domains;
  }
  /**
   * Generates a list of all unique ranges
   * @returns String[]
   */
  getUniqueRanges() {
    if (y(this._ranges)) {
      const t = this.getDisplayData(), { cartesianScales: e } = this.services, s = e.getRangeIdentifier(), a = e.getMainYAxisPosition(), o = e.getCustomDomainValuesByposition(a);
      if (o)
        return o;
      this._ranges = Array.from(
        new Set(
          t.map((i) => i[s])
        )
      );
    }
    return this._ranges;
  }
  /**
   * Generates a matrix (If doesn't exist) and returns it
   * @returns Object
   */
  getMatrix() {
    if (y(this._matrix)) {
      const t = this.getUniqueDomain(), e = this.getUniqueRanges(), s = this.services.cartesianScales.getDomainIdentifier(), a = this.services.cartesianScales.getRangeIdentifier(), o = {};
      e.forEach((i) => {
        o[i] = {
          value: null,
          index: -1
        };
      }), t.forEach((i) => {
        this._matrix[i] = G(o);
      }), this.getDisplayData().forEach((i, n) => {
        this._matrix[i[s]][i[a]] = {
          value: i.value,
          index: n
        };
      });
    }
    return this._matrix;
  }
  /**
   *
   * @param newData The new raw data to be set
   */
  setData(t) {
    const e = this.sanitize(G(t)), s = this.generateDataGroups(e);
    return this.set({
      data: e,
      dataGroups: s
    }), this._domains = [], this._ranges = [], this._matrix = {}, e;
  }
  /**
   * Converts Object matrix into a single array
   * @returns object[]
   */
  getMatrixAsArray() {
    y(this._matrix) && this.getMatrix();
    const t = this.getUniqueDomain(), e = this.getUniqueRanges(), s = this.services.cartesianScales.getDomainIdentifier(), a = this.services.cartesianScales.getRangeIdentifier(), o = [];
    return t.forEach((i) => {
      e.forEach((n) => {
        const r = {
          value: this._matrix[i][n].value,
          index: this._matrix[i][n].index
        };
        r[s] = i, r[a] = n, o.push(r);
      });
    }), o;
  }
  /**
   * Generate tabular data from display data
   * @returns Array<Object>
   */
  getTabularDataArray() {
    const t = this.getDisplayData(), { primaryDomain: e, primaryRange: s } = this.assignRangeAndDomains();
    return [
      [e.label, s.label, "Value"],
      ...t.map((o) => [
        o[e.identifier] === null ? "&ndash;" : o[e.identifier],
        o[s.identifier] === null ? "&ndash;" : o[s.identifier].toLocaleString(),
        o.value
      ])
    ];
  }
  // Uses quantize scale to return class names
  getColorClassName(t) {
    return `${t.originalClassName} ${this._colorScale(t.value)}`;
  }
  setColorClassNames() {
    const t = this.getOptions(), e = u(t, "color", "gradient", "colors"), s = !y(e);
    let a = u(t, "color", "pairing", "option");
    const o = this.getValueDomain(), i = o[0] < 0 && o[1] > 0 ? "diverge" : "mono";
    (a < 1 && a > 4 && i === "mono" || a < 1 && a > 2 && i === "diverge") && (a = 1);
    const n = s ? e : [];
    if (!s) {
      const l = i === "diverge" ? 17 : 11;
      for (let c = 1; c < l + 1; c++)
        n.push(`fill-${i}-${a}-${c}`);
    }
    this._colorScale = Y().domain(o).range(n);
    const r = u(this.getOptions(), "color");
    this._colorScale = R(this.getDisplayData(), r);
  }
}
class Ct extends S {
  getTabularDataArray() {
    const t = this.getOptions(), { groupMapsTo: e } = t.data, s = this.getBinnedStackedData();
    return [
      [
        x(t, "bins.rangeLabel") || "Range",
        ...s.map((o) => x(o, `0.${e}`))
      ],
      ...x(s, 0).map((o, i) => [
        `${x(o, "data.x0")} – ${x(o, "data.x1")}`,
        ...s.map((n) => x(n[i], `data.${x(n[i], e)}`))
      ])
    ];
  }
}
class St extends m {
  constructor(t) {
    super(t);
  }
  getMaximumDomain(t) {
    return t.reduce((s, a) => s + a.value, 0);
  }
  /**
   * Use a provided color for the bar or default to carbon color if no status provided.
   * Defaults to carbon color otherwise.
   * @param group dataset group label
   */
  getFillColor(t) {
    const e = this.getOptions(), s = u(e, "color", "scale"), a = this.getStatus();
    return s || !a ? super.getFillColor(t) : null;
  }
  /**
   * Get the associated status for the data by checking the ranges
   */
  getStatus() {
    const t = this.getOptions(), e = u(this.getDisplayData()), s = (e == null ? void 0 : e.reduce((i, n) => i + n.value, 0)) ?? 0, a = u(t, "meter", "proportional") ? s : s > 100 ? 100 : s, o = u(t, "meter", "status", "ranges");
    if (o) {
      const i = o.filter(
        (n) => n.range[0] <= a && a <= n.range[1]
      );
      if (i.length > 0)
        return i[0].status;
    }
    return null;
  }
  getTabularDataArray() {
    const t = this.getDisplayData(), e = this.getOptions(), { groupMapsTo: s } = e.data, a = this.getStatus(), o = u(e, "meter", "proportional");
    let i = [], n;
    if (o === null) {
      n = 100;
      const r = t[0];
      i = [
        ["Group", "Value", ...a ? ["Status"] : []],
        [r[s], r.value, ...a ? [a] : []]
      ];
    } else {
      const r = u(o, "total");
      n = r || this.getMaximumDomain(t), i = [
        ["Group", "Value", "Percentage of total"],
        ...t.map((l) => [
          l[s],
          l.value,
          (l.value / n * 100).toFixed(2) + " %"
        ])
      ];
    }
    return i;
  }
}
class Tt extends S {
  constructor(t) {
    super(t);
  }
  getTabularDataArray() {
    const t = this.getOptions(), e = this.getGroupedData(), { angle: s, value: a } = u(t, "radar", "axes"), o = u(e, "0", "data").map((n) => n[s]);
    return [
      ["Group", ...o],
      ...e.map((n) => [
        n.name,
        ...o.map(
          (r, l) => u(n, "data", l, a) !== null ? u(n, "data", l, a).toLocaleString() : "&ndash;"
        )
      ])
    ];
  }
}
class bt extends m {
  constructor(t) {
    super(t);
  }
  getTabularDataArray() {
    const t = this.getDisplayData(), e = [["Child", "Parent"]];
    return t.forEach((s) => {
      this.getChildrenDatums(s, e), e.push([s.name, "&ndash;"]);
    }), e;
  }
  /**
   * Determine the child parent relationship in nested data
   * @param datum: Object
   * @param result: Array<Object>
   */
  getChildrenDatums(t, e = []) {
    t.children && t.children.length > 0 && t.children.forEach((s) => {
      this.getChildrenDatums(s, e), e.push([s.name, t.name]);
    });
  }
}
class Ot extends m {
  constructor(t) {
    super(t);
  }
  getTabularDataArray() {
    const t = this.getDisplayData(), e = [["Child", "Group", "Value"]];
    return t.forEach((s) => {
      Array.isArray(s.children) ? s.children.forEach((a) => {
        e.push([a.name, s.name, a.value]);
      }) : u(s.name) !== null && u(s.value) && e.push(["–", s.name, s.value]);
    }), e;
  }
}
class Gt extends m {
  constructor(t) {
    super(t);
  }
  getTabularDataArray() {
    const t = this.getDisplayData(), e = this.getOptions(), { fontSizeMapsTo: s, wordMapsTo: a } = e.wordCloud, { groupMapsTo: o } = e.data;
    return [
      [e.tooltip.wordLabel, "Group", e.tooltip.valueLabel],
      ...t.map((n) => [
        n[a],
        n[o],
        n[s]
      ])
    ];
  }
}
export {
  gt as AlluvialChartModel,
  dt as BoxplotChartModel,
  Dt as BulletChartModel,
  m as ChartModel,
  Ct as ChartModelBinned,
  S as ChartModelCartesian,
  ft as ChoroplethModel,
  mt as CirclePackChartModel,
  vt as GaugeChartModel,
  xt as HeatmapModel,
  St as MeterChartModel,
  yt as PieChartModel,
  Tt as RadarChartModel,
  bt as TreeChartModel,
  Ot as TreemapChartModel,
  Gt as WordCloudModel
};
//# sourceMappingURL=index.mjs.map
