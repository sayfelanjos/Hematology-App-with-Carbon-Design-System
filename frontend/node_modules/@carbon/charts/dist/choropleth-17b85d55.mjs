import { select as x, pointer as Je, brushX as ms, scaleTime as qs, extent as Qe, area as kt, line as It, axisBottom as Rt, axisLeft as fs, axisTop as Ks, axisRight as Js, scaleLinear as Oe, arc as $e, easeLinear as Qs, path as Dt, interpolateNumber as vs, quantize as en, scaleBand as _t, hierarchy as Pt, pack as tn, pie as sn, interpolate as nn, interpolateRound as an, min as ht, max as Nt, lineRadial as rn, curveLinearClosed as on, cluster as ln, tree as cn, linkHorizontal as dn, treemap as hn, hsl as ys, color as bs, geoPath as un, geoNaturalEarth1 as pn, geoMercator as gn, geoEquirectangular as mn, geoConicEquidistant as fn, geoConicEqualArea as vn, geoAlbers as yn, geoEqualEarth as bn } from "d3";
import { t as Es, i as En, S as Ss, U as Sn, V as xs, W as xn, X as On, Y as Tn, Z as Ln, g as y, d as he, f as Re, F as Ht, _ as Q, z as K, $ as Ge, a0 as Ut, K as de, H as wn, a1 as Os, e as Mn, a2 as ve, L as ut, N as pt, j as pe, a3 as Ve, a4 as ge, l as fe, A as me, a5 as An, n as ke, R as Cn, C as Z, q as ce, a6 as ie, a7 as kn, P as In, B as se, u as Pe, s as He, a8 as zt, a9 as Rn, aa as Ft, D as Ee } from "./color-scale-utils-faf67b75.mjs";
import { y as H, _ as f, K as ee, r as ye, q as Te, L as Dn, A as ue, m as $, s as Se, V as Ie, S as te, e as V, Z as Le, i as le, f as Wt, J as nt, d as _n, F as Ue, n as at, H as it, C as rt, p as ze, b as jt, D as ot, Q as Pn, x as xe, $ as Fe, N as lt } from "./enums-a96ef472.mjs";
import { R as U } from "./a11y-7bad4f48.mjs";
import { t as ct, D as E, c as gt, G as Zt, a as Vn, p as Y, r as Xt, b as Bn } from "./angle-utils-6b17e95b.mjs";
import { sankey as $n, sankeyLinkHorizontal as Gn, sankeyJustify as Nn, sankeyLeft as Hn, sankeyRight as Un } from "d3-sankey";
import { b as Ts } from "./_baseEach-76cda8a8.mjs";
import zn from "d3-cloud";
function Fn(o, e, t, s) {
  var n = -1, a = o == null ? 0 : o.length;
  for (s && a && (t = o[++n]); ++n < a; )
    t = e(t, o[n], n, o);
  return t;
}
function Wn(o) {
  return function(e) {
    return o == null ? void 0 : o[e];
  };
}
var jn = {
  // Latin-1 Supplement block.
  À: "A",
  Á: "A",
  Â: "A",
  Ã: "A",
  Ä: "A",
  Å: "A",
  à: "a",
  á: "a",
  â: "a",
  ã: "a",
  ä: "a",
  å: "a",
  Ç: "C",
  ç: "c",
  Ð: "D",
  ð: "d",
  È: "E",
  É: "E",
  Ê: "E",
  Ë: "E",
  è: "e",
  é: "e",
  ê: "e",
  ë: "e",
  Ì: "I",
  Í: "I",
  Î: "I",
  Ï: "I",
  ì: "i",
  í: "i",
  î: "i",
  ï: "i",
  Ñ: "N",
  ñ: "n",
  Ò: "O",
  Ó: "O",
  Ô: "O",
  Õ: "O",
  Ö: "O",
  Ø: "O",
  ò: "o",
  ó: "o",
  ô: "o",
  õ: "o",
  ö: "o",
  ø: "o",
  Ù: "U",
  Ú: "U",
  Û: "U",
  Ü: "U",
  ù: "u",
  ú: "u",
  û: "u",
  ü: "u",
  Ý: "Y",
  ý: "y",
  ÿ: "y",
  Æ: "Ae",
  æ: "ae",
  Þ: "Th",
  þ: "th",
  ß: "ss",
  // Latin Extended-A block.
  Ā: "A",
  Ă: "A",
  Ą: "A",
  ā: "a",
  ă: "a",
  ą: "a",
  Ć: "C",
  Ĉ: "C",
  Ċ: "C",
  Č: "C",
  ć: "c",
  ĉ: "c",
  ċ: "c",
  č: "c",
  Ď: "D",
  Đ: "D",
  ď: "d",
  đ: "d",
  Ē: "E",
  Ĕ: "E",
  Ė: "E",
  Ę: "E",
  Ě: "E",
  ē: "e",
  ĕ: "e",
  ė: "e",
  ę: "e",
  ě: "e",
  Ĝ: "G",
  Ğ: "G",
  Ġ: "G",
  Ģ: "G",
  ĝ: "g",
  ğ: "g",
  ġ: "g",
  ģ: "g",
  Ĥ: "H",
  Ħ: "H",
  ĥ: "h",
  ħ: "h",
  Ĩ: "I",
  Ī: "I",
  Ĭ: "I",
  Į: "I",
  İ: "I",
  ĩ: "i",
  ī: "i",
  ĭ: "i",
  į: "i",
  ı: "i",
  Ĵ: "J",
  ĵ: "j",
  Ķ: "K",
  ķ: "k",
  ĸ: "k",
  Ĺ: "L",
  Ļ: "L",
  Ľ: "L",
  Ŀ: "L",
  Ł: "L",
  ĺ: "l",
  ļ: "l",
  ľ: "l",
  ŀ: "l",
  ł: "l",
  Ń: "N",
  Ņ: "N",
  Ň: "N",
  Ŋ: "N",
  ń: "n",
  ņ: "n",
  ň: "n",
  ŋ: "n",
  Ō: "O",
  Ŏ: "O",
  Ő: "O",
  ō: "o",
  ŏ: "o",
  ő: "o",
  Ŕ: "R",
  Ŗ: "R",
  Ř: "R",
  ŕ: "r",
  ŗ: "r",
  ř: "r",
  Ś: "S",
  Ŝ: "S",
  Ş: "S",
  Š: "S",
  ś: "s",
  ŝ: "s",
  ş: "s",
  š: "s",
  Ţ: "T",
  Ť: "T",
  Ŧ: "T",
  ţ: "t",
  ť: "t",
  ŧ: "t",
  Ũ: "U",
  Ū: "U",
  Ŭ: "U",
  Ů: "U",
  Ű: "U",
  Ų: "U",
  ũ: "u",
  ū: "u",
  ŭ: "u",
  ů: "u",
  ű: "u",
  ų: "u",
  Ŵ: "W",
  ŵ: "w",
  Ŷ: "Y",
  ŷ: "y",
  Ÿ: "Y",
  Ź: "Z",
  Ż: "Z",
  Ž: "Z",
  ź: "z",
  ż: "z",
  ž: "z",
  Ĳ: "IJ",
  ĳ: "ij",
  Œ: "Oe",
  œ: "oe",
  ŉ: "'n",
  ſ: "s"
}, Zn = Wn(jn);
const Xn = Zn;
var Yn = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, qn = "\\u0300-\\u036f", Kn = "\\ufe20-\\ufe2f", Jn = "\\u20d0-\\u20ff", Qn = qn + Kn + Jn, ea = "[" + Qn + "]", ta = RegExp(ea, "g");
function sa(o) {
  return o = Es(o), o && o.replace(Yn, Xn).replace(ta, "");
}
var na = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
function aa(o) {
  return o.match(na) || [];
}
var ia = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
function ra(o) {
  return ia.test(o);
}
var Ls = "\\ud800-\\udfff", oa = "\\u0300-\\u036f", la = "\\ufe20-\\ufe2f", ca = "\\u20d0-\\u20ff", da = oa + la + ca, ws = "\\u2700-\\u27bf", Ms = "a-z\\xdf-\\xf6\\xf8-\\xff", ha = "\\xac\\xb1\\xd7\\xf7", ua = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", pa = "\\u2000-\\u206f", ga = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", As = "A-Z\\xc0-\\xd6\\xd8-\\xde", ma = "\\ufe0e\\ufe0f", Cs = ha + ua + pa + ga, ks = "['’]", Yt = "[" + Cs + "]", fa = "[" + da + "]", Is = "\\d+", va = "[" + ws + "]", Rs = "[" + Ms + "]", Ds = "[^" + Ls + Cs + Is + ws + Ms + As + "]", ya = "\\ud83c[\\udffb-\\udfff]", ba = "(?:" + fa + "|" + ya + ")", Ea = "[^" + Ls + "]", _s = "(?:\\ud83c[\\udde6-\\uddff]){2}", Ps = "[\\ud800-\\udbff][\\udc00-\\udfff]", Ce = "[" + As + "]", Sa = "\\u200d", qt = "(?:" + Rs + "|" + Ds + ")", xa = "(?:" + Ce + "|" + Ds + ")", Kt = "(?:" + ks + "(?:d|ll|m|re|s|t|ve))?", Jt = "(?:" + ks + "(?:D|LL|M|RE|S|T|VE))?", Vs = ba + "?", Bs = "[" + ma + "]?", Oa = "(?:" + Sa + "(?:" + [Ea, _s, Ps].join("|") + ")" + Bs + Vs + ")*", Ta = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", La = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", wa = Bs + Vs + Oa, Ma = "(?:" + [va, _s, Ps].join("|") + ")" + wa, Aa = RegExp([
  Ce + "?" + Rs + "+" + Kt + "(?=" + [Yt, Ce, "$"].join("|") + ")",
  xa + "+" + Jt + "(?=" + [Yt, Ce + qt, "$"].join("|") + ")",
  Ce + "?" + qt + "+" + Kt,
  Ce + "+" + Jt,
  La,
  Ta,
  Is,
  Ma
].join("|"), "g");
function Ca(o) {
  return o.match(Aa) || [];
}
function ka(o, e, t) {
  return o = Es(o), e = t ? void 0 : e, e === void 0 ? ra(o) ? Ca(o) : aa(o) : o.match(e) || [];
}
var Ia = "['’]", Ra = RegExp(Ia, "g");
function Da(o) {
  return function(e) {
    return Fn(ka(sa(e).replace(Ra, "")), o, "");
  };
}
function _a(o, e, t) {
  return o === o && (t !== void 0 && (o = o <= t ? o : t), e !== void 0 && (o = o >= e ? o : e)), o;
}
function $s(o, e, t) {
  return t === void 0 && (t = e, e = void 0), t !== void 0 && (t = ct(t), t = t === t ? t : 0), e !== void 0 && (e = ct(e), e = e === e ? e : 0), _a(ct(o), e, t);
}
function Pa(o, e) {
  var t = -1, s = En(o) ? Array(o.length) : [];
  return Ts(o, function(n, a, i) {
    s[++t] = e(n, a, i);
  }), s;
}
function Va(o, e) {
  var t = Ss(o) ? Sn : Pa;
  return t(o, xs(e));
}
var Ba = 1 / 0;
function $a(o, e) {
  return xn(Va(o, e), Ba);
}
function Gs(o, e) {
  return On(o, e);
}
var Ga = Da(function(o, e, t) {
  return o + (t ? "-" : "") + e.toLowerCase();
});
const we = Ga;
function Na(o, e) {
  var t;
  return Ts(o, function(s, n, a) {
    return t = e(s, n, a), !t;
  }), !!t;
}
function Ha(o, e, t) {
  var s = Ss(o) ? Tn : Na;
  return t && Ln(o, e, t) && (e = void 0), s(o, xs(e));
}
class z {
  constructor(e, t, s) {
    if (this.type = "", this.renderType = H.HTML, this.id = "", this.parent = void 0, this.configs = {}, this.model = e, this.services = t, s && (this.configs = s, this.configs.id)) {
      const n = y(this.model.getOptions(), "style", "prefix");
      this.id = `${n}--${this.configs.id}`;
    }
    this.parent || this.setParent(x(this.services.domUtils.getMainContainer()));
  }
  init() {
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(e = !0) {
    console.error("Error: Component did not provide the required render function.");
  }
  destroy() {
  }
  // Used to pass down information to the components
  setModel(e) {
    this.model = e;
  }
  // Used to pass down information to the components
  setServices(e) {
    this.services = e;
  }
  setParent(e) {
    var s;
    const t = this.parent;
    if (this.parent = e, !(t && t.node() === e.node()) && this.type) {
      const n = y(this.model.getOptions(), "style", "prefix");
      (s = this.parent) == null || s.classed(`${he}--${n}--${this.type}`, !0), t && t.classed(`${he}--${n}--${this.type}`, !1);
    }
  }
  getParent() {
    return this.parent;
  }
  getComponentContainer(e = { withinChartClip: !1 }) {
    if (this.type) {
      const t = y(this.model.getOptions(), "style", "prefix"), s = this.id ? `#${this.id}` : "", n = E.appendOrSelect(
        this.parent,
        `${this.renderType === H.SVG ? "svg" : "div"}${s}.${he}--${t}--${this.type}`
      );
      if (e.withinChartClip) {
        const a = this.model.get("chartClipId");
        if (a) {
          const r = x(`#${a}`).select("rect");
          r.size() !== 0 && parseFloat(r.attr("height")) > 0 && n.attr("clip-path", `url(#${a})`);
        }
      }
      return n.attr("width", "100%").attr("height", "100%");
    }
    return this.parent;
  }
  /**
   * graphs used in combo charts share a model with global options but can receive their own local options.
   * this function retrieves the global options and merges it with any options passed into this
   * component's config.options object.
   */
  getOptions() {
    return this.configs.options ? Re({}, this.model.getOptions(), this.configs.options) : this.model.getOptions();
  }
}
const Ns = class Hs extends z {
  constructor() {
    super(...arguments), this.type = "toolbar", this.renderType = H.HTML;
  }
  init() {
    const e = () => this.updateOverflowMenu(!1);
    this.services.events.addEventListener(f.Toolbar.SHOW_OVERFLOW_MENU, () => {
      this.renderOverflowMenu(), document.body.addEventListener("click", e);
    }), this.services.events.addEventListener(f.Toolbar.HIDE_OVERFLOW_MENU, () => {
      document.body.removeEventListener("click", e);
    });
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(e = !0) {
    const t = this.getComponentContainer().attr("role", "toolbar").attr("aria-label", `chart-${this.services.domUtils.getChartID()} toolbar`);
    if (y(this.getOptions(), "data", "loading"))
      t.html(""), this.overflowMenu = null;
    else {
      this.overflowMenu || (this.overflowMenu = t.append("div").attr(
        "class",
        "cds--overflow-menu-options cds--overflow-menu--flip cds--overflow-menu-options cds--overflow-menu--flip"
      ).attr("tabindex", -1).html("<ul role='menu'></ul>"));
      const { buttonList: n, overflowMenuItemList: a } = this.getControlConfigs();
      a && n.push(this.getOverflowButtonConfig());
      const i = t.selectAll("div.toolbar-control").data(n, (c) => c.id);
      i.exit().remove();
      const r = i.enter().append("div").attr("class", "toolbar-control cds--overflow-menu cds--overflow-menu").attr("role", "button"), l = this;
      r.merge(i).classed("disabled", (c) => c.shouldBeDisabled()).attr("aria-disabled", (c) => c.shouldBeDisabled()).attr("aria-label", (c) => c.title).html(
        (c) => `
			<button
				class="cds--overflow-menu__trigger cds--overflow-menu__trigger"
				aria-haspopup="true" aria-expanded="false" id="${this.services.domUtils.generateElementIDString(
          `control-${c.id}`
        )}" aria-label="${c.title}">
				<svg focusable="false" preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg" class="cds--overflow-menu__icon cds--overflow-menu__icon" viewBox="0 0 32 32" aria-hidden="true">
					${c.iconSVG.content}
				</svg>
			</button>`
      ).each(function(c, d) {
        x(this).select("svg").style("will-change", "transform").style("width", c.iconSVG.width !== void 0 ? c.iconSVG.width : "20px").style("height", c.iconSVG.height !== void 0 ? c.iconSVG.height : "20px"), x(this).select("button").on("click", (p) => {
          c.shouldBeDisabled() || l.triggerFunctionAndEvent(c, p, this);
        }).on("keydown", (p) => {
          p.key && p.key === "Enter" || p.key === " " ? (p.preventDefault(), l.triggerFunctionAndEvent(c, p, this)) : p.key && p.key === "ArrowLeft" ? l.focusOnPreviousEnabledToolbarItem(d) : p.key && p.key === "ArrowRight" && l.focusOnNextEnabledToolbarItem(d);
        });
      }), this.overflowButton = this.getComponentContainer().select(
        `button.cds--overflow-menu__trigger#${this.services.domUtils.generateElementIDString(
          "control-toolbar-overflow-menu"
        )}`
      );
    }
  }
  renderOverflowMenu() {
    const { overflowMenuItemList: e } = this.getControlConfigs(), t = this.overflowMenu.select("ul").selectAll("li.cds--overflow-menu-options__option").data(e, (n) => y(n, "id"));
    t.exit().remove();
    const s = t.enter().append("li").attr("id", (n) => this.services.domUtils.generateElementIDString(`control-${n.id}`)).attr("class", "cds--overflow-menu-options__option cds--overflow-menu-options__option").attr("role", "menuitem").attr("tabindex", 1);
    s.append("button").attr("class", "cds--overflow-menu-options__btn cds--overflow-menu-options__btn"), s.merge(t).classed("cds--overflow-menu-options__option--disabled", (n) => n.shouldBeDisabled()).classed("cds--overflow-menu-options__option--disabled", (n) => n.shouldBeDisabled()).attr("aria-disabled", (n) => n.shouldBeDisabled()).selectAll("button").text((n) => n.text);
  }
  isOverflowMenuOpen() {
    return this.overflowMenu.classed("is-open");
  }
  // show/hide overflow menu
  updateOverflowMenu(e) {
    this.overflowMenu && (this.overflowMenu.classed("is-open", e), this.overflowButton && (this.overflowButton.attr("aria-expanded", e), x(this.overflowButton.node().parentNode).classed("cds--overflow-menu--open", e).classed("cds--overflow-menu--open", e)), e ? this.services.events.dispatchEvent(f.Toolbar.SHOW_OVERFLOW_MENU) : this.services.events.dispatchEvent(f.Toolbar.HIDE_OVERFLOW_MENU));
  }
  // Toolbar controllers
  focusOnPreviousEnabledToolbarItem(e) {
    const t = this.getToolbarButtonItems();
    let s = t.length;
    for (let n = e - 1; n >= 0; n--)
      if (!t[n].shouldBeDisabled()) {
        s = n;
        break;
      }
    if (s < t.length) {
      const n = x(
        `button#${this.services.domUtils.generateElementIDString(
          `control-${t[s].id}`
        )}`
      ).node();
      "focus" in n && n.focus();
    }
  }
  focusOnNextEnabledToolbarItem(e) {
    const t = this.getToolbarButtonItems();
    let s = -1;
    for (let n = e + 1; n < t.length; n++)
      if (!t[n].shouldBeDisabled()) {
        s = n;
        break;
      }
    if (s > -1) {
      const n = x(
        `button#${this.services.domUtils.generateElementIDString(
          `control-${t[s].id}`
        )}`
      ).node();
      "focus" in n && n.focus();
    }
  }
  focusOnPreviousEnabledMenuItem(e) {
    const t = this.getOverflowMenuItems();
    let s = t.length;
    for (let n = e - 1; n >= 0; n--)
      if (!t[n].shouldBeDisabled()) {
        s = n;
        break;
      }
    if (s < t.length) {
      const n = x(
        `#${this.services.domUtils.generateElementIDString(
          `control-${t[s].id}`
        )} button`
      ).node();
      "focus" in n && n.focus();
    }
  }
  focusOnNextEnabledMenuItem(e) {
    const t = this.getOverflowMenuItems();
    let s = -1;
    for (let n = e + 1; n < t.length; n++)
      if (!t[n].shouldBeDisabled()) {
        s = n;
        break;
      }
    if (s > -1) {
      const n = x(
        `#${this.services.domUtils.generateElementIDString(
          `control-${t[s].id}`
        )} button`
      ).node();
      "focus" in n && n.focus();
    }
  }
  toggleOverflowMenu(e) {
    if (this.isOverflowMenuOpen())
      this.updateOverflowMenu(!1);
    else {
      this.updateOverflowMenu(!0);
      const t = this;
      this.getOverflowMenuItems().forEach((n, a) => {
        const i = x(
          `#${this.services.domUtils.generateElementIDString(`control-${n.id}`)}`
        );
        i !== null && (i.on("click", () => {
          t.triggerFunctionAndEvent(n, e, i.node()), t.updateOverflowMenu(!1);
        }), i.on("keydown", (r) => {
          r && r.key === "Enter" ? t.triggerFunctionAndEvent(n, e, i.node()) : r && r.key === "ArrowUp" ? t.focusOnPreviousEnabledMenuItem(a) : r && r.key === "ArrowDown" ? t.focusOnNextEnabledMenuItem(a) : r && r.key === "Escape" && t.updateOverflowMenu(!1), r.preventDefault();
        }));
      }), t.focusOnNextEnabledMenuItem(-1);
    }
    e && e.stopImmediatePropagation();
  }
  // Calls passed function && dispatches event
  triggerFunctionAndEvent(e, t, s) {
    typeof e.shouldBeDisabled == "function" && e.shouldBeDisabled() || (typeof e.clickFunction == "function" && e.clickFunction(t), this.services.events.dispatchEvent(f.Toolbar.BUTTON_CLICK, {
      control: e,
      event: t,
      element: s
    }));
  }
  getControlConfigs() {
    const e = y(this.getOptions(), "toolbar", "numberOfIcons") - 1, t = y(this.getOptions(), "toolbar", "controls"), s = [], n = [], a = [];
    return t.forEach((i) => {
      let r = null;
      i.type === ee.CUSTOM ? (y(i, "id") === null && (i.id = `toolbar-button-${Hs.buttonID++}`), y(i, "shouldBeDisabled") === null && (i.shouldBeDisabled = () => !1), r = i) : r = this.getControlConfigByType(i.type), r && (r.text = i.text ? i.text : i.type, r.id.indexOf("toolbar-export") !== -1 ? s.push(r) : n.length < e ? y(r, "iconSVG", "content") === null ? a.push(r) : n.push(r) : a.push(r));
    }), a.push(...s), a.length ? {
      buttonList: n,
      overflowMenuItemList: a
    } : {
      buttonList: n
    };
  }
  getToolbarButtonItems() {
    const { buttonList: e, overflowMenuItemList: t } = this.getControlConfigs();
    return t && e.push(this.getOverflowButtonConfig()), e || [];
  }
  getOverflowMenuItems() {
    const { overflowMenuItemList: e } = this.getControlConfigs();
    return e || [];
  }
  // special button config for overflow button
  getOverflowButtonConfig() {
    return {
      id: "toolbar-overflow-menu",
      title: "More options",
      shouldBeDisabled: () => !1,
      iconSVG: {
        content: `<circle cx="16" cy="8" r="2"></circle>
				<circle cx="16" cy="16" r="2"></circle>
				<circle cx="16" cy="24" r="2"></circle>`
      },
      clickFunction: (e) => this.toggleOverflowMenu(e)
    };
  }
  getControlConfigByType(e) {
    const t = this.services.zoom && this.services.zoom.isZoomBarEnabled() && !this.services.zoom.isEmptyState(), s = this.model.getDisplayData();
    let n;
    switch (e) {
      case ee.ZOOM_IN:
        t && (n = {
          id: "toolbar-zoomIn",
          title: "Zoom in",
          shouldBeDisabled: () => this.services.zoom.isMinZoomDomain(),
          iconSVG: {
            content: this.getControlIconByType(e)
          },
          clickFunction: () => this.services.zoom.zoomIn()
        });
        break;
      case ee.ZOOM_OUT:
        t && (n = {
          id: "toolbar-zoomOut",
          title: "Zoom out",
          shouldBeDisabled: () => this.services.zoom.isMaxZoomDomain(),
          iconSVG: {
            content: this.getControlIconByType(e)
          },
          clickFunction: () => this.services.zoom.zoomOut()
        });
        break;
      case ee.RESET_ZOOM:
        t && (n = {
          id: "toolbar-resetZoom",
          title: "Reset zoom",
          shouldBeDisabled: () => this.services.zoom.isMaxZoomDomain(),
          iconSVG: {
            content: this.getControlIconByType(e)
          },
          clickFunction: () => this.services.zoom.resetZoomDomain()
        });
        break;
      case ee.MAKE_FULLSCREEN:
        n = {
          id: "toolbar-makefullscreen",
          iconSVG: {
            content: this.getControlIconByType(e),
            width: "15px",
            height: "15px"
          },
          title: "Make fullscreen",
          shouldBeDisabled: () => !1,
          clickFunction: () => {
            this.services.domUtils.toggleFullscreen();
          }
        };
        break;
      case ee.SHOW_AS_DATATABLE:
        n = {
          id: "toolbar-showasdatatable",
          iconSVG: {
            content: this.getControlIconByType(e)
          },
          title: "Show as table",
          shouldBeDisabled: () => s.length === 0,
          clickFunction: () => this.services.events.dispatchEvent(f.Modal.SHOW)
        };
        break;
      case ee.EXPORT_CSV:
        n = {
          id: "toolbar-export-CSV",
          title: "Export as CSV",
          shouldBeDisabled: () => !1,
          iconSVG: {
            content: this.getControlIconByType(e)
          },
          clickFunction: () => this.model.exportToCSV()
        };
        break;
      case ee.EXPORT_PNG:
        n = {
          id: "toolbar-export-PNG",
          title: "Export as PNG",
          shouldBeDisabled: () => !1,
          iconSVG: {
            content: this.getControlIconByType(e)
          },
          clickFunction: () => this.services.domUtils.exportToPNG()
        };
        break;
      case ee.EXPORT_JPG:
        n = {
          id: "toolbar-export-JPG",
          title: "Export as JPG",
          shouldBeDisabled: () => !1,
          iconSVG: {
            content: this.getControlIconByType(e)
          },
          clickFunction: () => this.services.domUtils.exportToJPG()
        };
        break;
      default:
        throw Error("Not supported toolbar control type: " + e);
    }
    return n;
  }
  getControlIconByType(e) {
    switch (e) {
      case ee.ZOOM_IN:
        return `<polygon points="19 13 15 13 15 9 13 9 13 13 9 13 9 15 13 15 13 19 15 19 15 15 19 15 19 13"/>
						<path d="M22.45,21A10.87,10.87,0,0,0,25,14,11,11,0,1,0,14,25a10.87,10.87,0,0,0,7-2.55L28.59,30,30,28.59ZM14,23a9,9,0,1,1,9-9A9,9,0,0,1,14,23Z"/>`;
      case ee.ZOOM_OUT:
        return `<rect x="9" y="13" width="10" height="2"/>
						<path d="M22.45,21A10.87,10.87,0,0,0,25,14,11,11,0,1,0,14,25a10.87,10.87,0,0,0,7-2.55L28.59,30,30,28.59ZM14,23a9,9,0,1,1,9-9A9,9,0,0,1,14,23Z"/>`;
      case ee.RESET_ZOOM:
        return '<path d="M22.4478,21A10.855,10.855,0,0,0,25,14,10.99,10.99,0,0,0,6,6.4658V2H4v8h8V8H7.332a8.9768,8.9768,0,1,1-2.1,8H3.1912A11.0118,11.0118,0,0,0,14,25a10.855,10.855,0,0,0,7-2.5522L28.5859,30,30,28.5859Z"/>';
      case ee.MAKE_FULLSCREEN:
        return '<polygon points="21 2 21 4 26.59 4 17 13.58 18.41 15 28 5.41 28 11 30 11 30 2 21 2"/><polygon points="15 18.42 13.59 17 4 26.59 4 21 2 21 2 30 11 30 11 28 5.41 28 15 18.42"/>';
      case ee.SHOW_AS_DATATABLE:
        return '<rect x="4" y="6" width="18" height="2"/><rect x="4" y="12" width="18" height="2"/><rect x="4" y="18" width="18" height="2"/><rect x="4" y="24" width="18" height="2"/><rect x="26" y="6" width="2" height="2"/><rect x="26" y="12" width="2" height="2"/><rect x="26" y="18" width="2" height="2"/><rect x="26" y="24" width="2" height="2"/>';
      case ee.EXPORT_CSV:
        return '<path d="M22.4478,21A10.855,10.855,0,0,0,25,14,10.99,10.99,0,0,0,6,6.4658V2H4v8h8V8H7.332a8.9768,8.9768,0,1,1-2.1,8H3.1912A11.0118,11.0118,0,0,0,14,25a10.855,10.855,0,0,0,7-2.5522L28.5859,30,30,28.5859Z"/>';
      case ee.EXPORT_JPG:
        return '<path d="M22.4478,21A10.855,10.855,0,0,0,25,14,10.99,10.99,0,0,0,6,6.4658V2H4v8h8V8H7.332a8.9768,8.9768,0,1,1-2.1,8H3.1912A11.0118,11.0118,0,0,0,14,25a10.855,10.855,0,0,0,7-2.5522L28.5859,30,30,28.5859Z"/>';
      case ee.EXPORT_PNG:
        return '<path d="M22.4478,21A10.855,10.855,0,0,0,25,14,10.99,10.99,0,0,0,6,6.4658V2H4v8h8V8H7.332a8.9768,8.9768,0,1,1-2.1,8H3.1912A11.0118,11.0118,0,0,0,14,25a10.855,10.855,0,0,0,7-2.5522L28.5859,30,30,28.5859Z"/>';
      default:
        throw Error("Not supported toolbar control type: " + e);
    }
  }
};
Ns.buttonID = 0;
let nc = Ns;
const Us = class zs extends z {
  constructor(e, t, s, n) {
    super(e, t, n), this.type = "layout", this.configs = n, this.children = s, this._instanceID = zs.instanceID++, this.init();
  }
  init() {
    this.children.forEach((e) => {
      e.components.forEach((t) => {
        t.init();
      });
    });
  }
  getPreferedAndFixedSizeSum() {
    const e = this.parent;
    let t = 0;
    return e.selectAll(`div.layout-child-${this._instanceID}`).filter((s) => {
      const n = y(s, "growth");
      return n === ye.PREFERRED || n === ye.FIXED;
    }).each(function(s) {
      t += s.size;
    }), t;
  }
  getNumOfStretchChildren() {
    return this.parent.selectAll(`div.layout-child-${this._instanceID}`).filter((t) => y(t, "growth") === ye.STRETCH).size();
  }
  render(e = !0) {
    const t = this.parent, { width: s, height: n } = E.getHTMLElementSize(t.node()), a = this.configs.direction === Te.ROW || this.configs.direction === Te.ROW_REVERSE, i = y(this.model.getOptions(), "style", "prefix"), r = t.classed(
      `${he}--${i}--layout-row`,
      this.configs.direction === Te.ROW
    ).classed(
      `${he}--${i}--layout-row-reverse`,
      this.configs.direction === Te.ROW_REVERSE
    ).classed(
      `${he}--${i}--layout-column`,
      this.configs.direction === Te.COLUMN
    ).classed(
      `${he}--${i}--layout-column-reverse`,
      this.configs.direction === Te.COLUMN_REVERSE
    ).classed(
      `${he}--${i}--layout-alignitems-center`,
      this.configs.alignItems === Dn.CENTER
    ).selectAll(`div.layout-child-${this._instanceID}`).data(this.children, (d) => d.id);
    r.enter().append("div").merge(t.selectAll(`div.layout-child-${this._instanceID}`)).attr("class", (d) => `layout-child layout-child-${this._instanceID} ${d.id}`).each(function(d) {
      d.components.forEach((p) => {
        const h = x(this), g = y(d, "renderType") === H.SVG;
        p.setParent(
          g ? E.appendOrSelect(h, "svg.layout-svg-wrapper").attr("width", "100%").attr("height", "100%") : h
        );
        const m = y(d, "growth");
        (m === ye.PREFERRED || m === ye.FIXED) && p.render(e);
      });
    }), t.selectAll(`div.layout-child-${this._instanceID}`).style("height", null).style("width", null).each(function(d) {
      const p = y(d, "growth"), u = y(d, "renderType") === H.SVG ? E.getSVGElementSize(x(this).select("svg.layout-svg-wrapper"), {
        useBBox: !0
      }) : E.getHTMLElementSize(this);
      if (p === ye.PREFERRED) {
        const g = a ? u.width : u.height, m = a ? s : n;
        d.size = g / m * 100;
      }
    }), r.exit().remove(), this.children.filter((d) => y(d, "growth") === ye.STRETCH).forEach((d) => {
      d.size = (100 - +this.getPreferedAndFixedSizeSum()) / +this.getNumOfStretchChildren();
    });
    const c = t.selectAll(`div.layout-child-${this._instanceID}`).data(this.children, (d) => d.id);
    a ? c.style("width", (d) => `${d.size / 100 * s}px`).style("height", "100%") : c.style("height", (d) => `${d.size / 100 * n}px`).style("width", "100%"), c.each(function(d) {
      d.components.forEach((p) => {
        y(d, "growth") === ye.STRETCH && p.render(e);
      });
    });
  }
  // Pass on model to children as well
  setModel(e) {
    super.setModel(e), this.children.forEach((t) => {
      t.components.forEach((s) => s.setModel(e));
    });
  }
  // Pass on essentials to children as well
  setServices(e) {
    super.setServices(e), this.children.forEach((t) => {
      t.components.forEach((s) => s.setServices(e));
    });
  }
  destroy() {
    this.children.forEach((e) => {
      e.components.forEach((t) => t.destroy());
    });
  }
};
Us.instanceID = Math.floor(Math.random() * 99999999999);
let ac = Us;
class ic extends z {
  constructor() {
    super(...arguments), this.type = "spacer";
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(e = !1) {
    this.getComponentContainer().style("width", `${this.configs.size || Ht.default.size}px`).style("height", `${this.configs.size || Ht.default.size}px`).attr("opacity", 0);
  }
}
var Ua = {
  prefix: "bx",
  selectorTabbable: `
    a[href], area[href], input:not([disabled]):not([tabindex='-1']),
    button:not([disabled]):not([tabindex='-1']),select:not([disabled]):not([tabindex='-1']),
    textarea:not([disabled]):not([tabindex='-1']),
    iframe, object, embed, *[tabindex]:not([tabindex='-1']), *[contenteditable=true]
  `,
  selectorFocusable: `
    a[href], area[href], input:not([disabled]),
    button:not([disabled]),select:not([disabled]),
    textarea:not([disabled]),
    iframe, object, embed, *[tabindex], *[contenteditable=true]
  `
}, dt = Ua;
function Qt(o, e) {
  for (var t = 0; t < e.length; t++) {
    var s = e[t];
    s.enumerable = s.enumerable || !1, s.configurable = !0, "value" in s && (s.writable = !0), Object.defineProperty(o, s.key, s);
  }
}
function za(o, e, t) {
  return e && Qt(o.prototype, e), t && Qt(o, t), Object.defineProperty(o, "prototype", {
    writable: !1
  }), o;
}
function Fa(o, e) {
  if (!(o instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function Wa(o) {
  return Ya(o) || Xa(o) || Za(o) || ja();
}
function ja() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Za(o, e) {
  if (o) {
    if (typeof o == "string")
      return mt(o, e);
    var t = Object.prototype.toString.call(o).slice(8, -1);
    if (t === "Object" && o.constructor && (t = o.constructor.name), t === "Map" || t === "Set")
      return Array.from(o);
    if (t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t))
      return mt(o, e);
  }
}
function Xa(o) {
  if (typeof Symbol < "u" && o[Symbol.iterator] != null || o["@@iterator"] != null)
    return Array.from(o);
}
function Ya(o) {
  if (Array.isArray(o))
    return mt(o);
}
function mt(o, e) {
  (e == null || e > o.length) && (e = o.length);
  for (var t = 0, s = new Array(e); t < e; t++)
    s[t] = o[t];
  return s;
}
function Fs(o) {
  return o.reduce(function(e, t) {
    return Array.isArray(t) ? e.push.apply(e, Wa(Fs(t))) : e.push(t), e;
  }, []);
}
function qa() {
  for (var o = arguments.length, e = new Array(o), t = 0; t < o; t++)
    e[t] = arguments[t];
  return Fs(e).reduce(function(s, n) {
    return n(s);
  }, /* @__PURE__ */ function() {
    function s() {
      Fa(this, s);
    }
    return za(s);
  }());
}
function ft(o) {
  "@babel/helpers - typeof";
  return ft = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, ft(o);
}
function Ka(o, e) {
  if (!(o instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function es(o, e) {
  for (var t = 0; t < e.length; t++) {
    var s = e[t];
    s.enumerable = s.enumerable || !1, s.configurable = !0, "value" in s && (s.writable = !0), Object.defineProperty(o, s.key, s);
  }
}
function Ja(o, e, t) {
  return e && es(o.prototype, e), t && es(o, t), Object.defineProperty(o, "prototype", {
    writable: !1
  }), o;
}
function Qa(o, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Super expression must either be null or a function");
  o.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: o,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(o, "prototype", {
    writable: !1
  }), e && vt(o, e);
}
function vt(o, e) {
  return vt = Object.setPrototypeOf || function(s, n) {
    return s.__proto__ = n, s;
  }, vt(o, e);
}
function ei(o) {
  var e = si();
  return function() {
    var s = Ze(o), n;
    if (e) {
      var a = Ze(this).constructor;
      n = Reflect.construct(s, arguments, a);
    } else
      n = s.apply(this, arguments);
    return ti(this, n);
  };
}
function ti(o, e) {
  if (e && (ft(e) === "object" || typeof e == "function"))
    return e;
  if (e !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return Ws(o);
}
function Ws(o) {
  if (o === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return o;
}
function si() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function Ze(o) {
  return Ze = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, Ze(o);
}
function ni(o) {
  var e = /* @__PURE__ */ function(t) {
    Qa(n, t);
    var s = ei(n);
    function n(a) {
      var i, r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (Ka(this, n), i = s.call(this, a, r), i.children = [], !a || a.nodeType !== Node.ELEMENT_NODE)
        throw new TypeError("DOM element should be given to initialize this widget.");
      return i.element = a, i.options = Object.assign(Object.create(i.constructor.options), r), i.constructor.components.set(i.element, Ws(i)), i;
    }
    return Ja(n, [{
      key: "release",
      value: (
        /**
         * Releases this component's instance from the associated element.
         */
        function() {
          for (var i = this.children.pop(); i; i = this.children.pop())
            i.release();
          return this.constructor.components.delete(this.element), null;
        }
      )
    }], [{
      key: "create",
      value: function(i, r) {
        return this.components.get(i) || new this(i, r);
      }
    }]), n;
  }(o);
  return e;
}
function yt(o) {
  "@babel/helpers - typeof";
  return yt = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, yt(o);
}
function ai(o, e) {
  if (!(o instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function ts(o, e) {
  for (var t = 0; t < e.length; t++) {
    var s = e[t];
    s.enumerable = s.enumerable || !1, s.configurable = !0, "value" in s && (s.writable = !0), Object.defineProperty(o, s.key, s);
  }
}
function ii(o, e, t) {
  return e && ts(o.prototype, e), t && ts(o, t), Object.defineProperty(o, "prototype", {
    writable: !1
  }), o;
}
function We() {
  return typeof Reflect < "u" && Reflect.get ? We = Reflect.get : We = function(e, t, s) {
    var n = ri(e, t);
    if (n) {
      var a = Object.getOwnPropertyDescriptor(n, t);
      return a.get ? a.get.call(arguments.length < 3 ? e : s) : a.value;
    }
  }, We.apply(this, arguments);
}
function ri(o, e) {
  for (; !Object.prototype.hasOwnProperty.call(o, e) && (o = De(o), o !== null); )
    ;
  return o;
}
function oi(o, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Super expression must either be null or a function");
  o.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: o,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(o, "prototype", {
    writable: !1
  }), e && bt(o, e);
}
function bt(o, e) {
  return bt = Object.setPrototypeOf || function(s, n) {
    return s.__proto__ = n, s;
  }, bt(o, e);
}
function li(o) {
  var e = hi();
  return function() {
    var s = De(o), n;
    if (e) {
      var a = De(this).constructor;
      n = Reflect.construct(s, arguments, a);
    } else
      n = s.apply(this, arguments);
    return ci(this, n);
  };
}
function ci(o, e) {
  if (e && (yt(e) === "object" || typeof e == "function"))
    return e;
  if (e !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return di(o);
}
function di(o) {
  if (o === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return o;
}
function hi() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function De(o) {
  return De = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, De(o);
}
function ui(o) {
  var e = /* @__PURE__ */ function(t) {
    oi(n, t);
    var s = li(n);
    function n() {
      var a;
      ai(this, n);
      for (var i = arguments.length, r = new Array(i), l = 0; l < i; l++)
        r[l] = arguments[l];
      return a = s.call.apply(s, [this].concat(r)), a.handles = /* @__PURE__ */ new Set(), a;
    }
    return ii(n, [{
      key: "manage",
      value: (
        /**
         * Manages the given handle.
         * @param {Handle} handle The handle to manage.
         * @returns {Handle} The given handle.
         */
        function(i) {
          return this.handles.add(i), i;
        }
      )
      /**
       * Stop managing the given handle.
       * @param {Handle} handle The handle to stop managing.
       * @returns {Handle} The given handle.
       */
    }, {
      key: "unmanage",
      value: function(i) {
        return this.handles.delete(i), i;
      }
    }, {
      key: "release",
      value: function() {
        var i = this;
        return this.handles.forEach(function(r) {
          r.release(), i.handles.delete(r);
        }), We(De(n.prototype), "release", this).call(this);
      }
    }]), n;
  }(o);
  return e;
}
function Be(o) {
  for (var e = arguments.length, t = new Array(e > 1 ? e - 1 : 0), s = 1; s < e; s++)
    t[s - 1] = arguments[s];
  return o.addEventListener.apply(o, t), {
    release: function() {
      return o.removeEventListener.apply(o, t), null;
    }
  };
}
function Et(o) {
  "@babel/helpers - typeof";
  return Et = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Et(o);
}
function pi(o) {
  return vi(o) || fi(o) || mi(o) || gi();
}
function gi() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function mi(o, e) {
  if (o) {
    if (typeof o == "string")
      return St(o, e);
    var t = Object.prototype.toString.call(o).slice(8, -1);
    if (t === "Object" && o.constructor && (t = o.constructor.name), t === "Map" || t === "Set")
      return Array.from(o);
    if (t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t))
      return St(o, e);
  }
}
function fi(o) {
  if (typeof Symbol < "u" && o[Symbol.iterator] != null || o["@@iterator"] != null)
    return Array.from(o);
}
function vi(o) {
  if (Array.isArray(o))
    return St(o);
}
function St(o, e) {
  (e == null || e > o.length) && (e = o.length);
  for (var t = 0, s = new Array(e); t < e; t++)
    s[t] = o[t];
  return s;
}
function yi(o, e) {
  if (!(o instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function ss(o, e) {
  for (var t = 0; t < e.length; t++) {
    var s = e[t];
    s.enumerable = s.enumerable || !1, s.configurable = !0, "value" in s && (s.writable = !0), Object.defineProperty(o, s.key, s);
  }
}
function bi(o, e, t) {
  return e && ss(o.prototype, e), t && ss(o, t), Object.defineProperty(o, "prototype", {
    writable: !1
  }), o;
}
function Ei(o, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Super expression must either be null or a function");
  o.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: o,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(o, "prototype", {
    writable: !1
  }), e && xt(o, e);
}
function xt(o, e) {
  return xt = Object.setPrototypeOf || function(s, n) {
    return s.__proto__ = n, s;
  }, xt(o, e);
}
function Si(o) {
  var e = Ti();
  return function() {
    var s = Xe(o), n;
    if (e) {
      var a = Xe(this).constructor;
      n = Reflect.construct(s, arguments, a);
    } else
      n = s.apply(this, arguments);
    return xi(this, n);
  };
}
function xi(o, e) {
  if (e && (Et(e) === "object" || typeof e == "function"))
    return e;
  if (e !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return Oi(o);
}
function Oi(o) {
  if (o === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return o;
}
function Ti() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function Xe(o) {
  return Xe = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, Xe(o);
}
function Li(o) {
  var e = /* @__PURE__ */ function(t) {
    Ei(n, t);
    var s = Si(n);
    function n() {
      return yi(this, n), s.apply(this, arguments);
    }
    return bi(n, [{
      key: "_changeState",
      value: (
        /* eslint-disable jsdoc/check-param-names */
        /**
         * The internal implementation for {@link EventedState#changeState `.changeState()`}, performing actual change in state.
         * @param {string} [state] The new state. Can be an omitted, which means toggling.
         * @param {object} [detail]
         *   The object that should be put to event details that is fired before/after changing state.
         *   Can have a `group` property, which specifies what state to be changed.
         * @param {EventedState~changeStateCallback} callback The callback called once changing state is finished or is canceled.
         * @private
         */
        function() {
          throw new Error("_changeState() should be overridden to perform actual change in state.");
        }
      )
      /**
       * Changes the state of this component.
       * @param {string} [state] The new state. Can be an omitted, which means toggling.
       * @param {object} [detail]
       *   The object that should be put to event details that is fired before/after changing state.
       *   Can have a `group` property, which specifies what state to be changed.
       * @param {EventedState~changeStateCallback} [callback] The callback called once changing state is finished or is canceled.
       */
    }, {
      key: "changeState",
      value: function() {
        for (var i = this, r = arguments.length, l = new Array(r), c = 0; c < r; c++)
          l[c] = arguments[c];
        var d = typeof l[0] == "string" ? l.shift() : void 0, p = Object(l[0]) === l[0] && typeof l[0] != "function" ? l.shift() : void 0, h = typeof l[0] == "function" ? l.shift() : void 0;
        if (typeof this.shouldStateBeChanged == "function" && !this.shouldStateBeChanged(d, p)) {
          h && h(null, !0);
          return;
        }
        var u = {
          group: p && p.group,
          state: d
        }, g = [u.group, d].filter(Boolean).join("-").split("-").map(function(w) {
          return w[0].toUpperCase() + w.substr(1);
        }).join(""), m = new CustomEvent(this.options["eventBefore".concat(g)], {
          bubbles: !0,
          cancelable: !0,
          detail: p
        }), b = p && p.delegatorNode || this.element, v = !b.dispatchEvent(m);
        if (v) {
          if (h) {
            var S = new Error("Changing state (".concat(JSON.stringify(u), ") has been canceled."));
            S.canceled = !0, h(S);
          }
        } else {
          var T = [d, p].filter(Boolean);
          this._changeState.apply(this, pi(T).concat([function() {
            b.dispatchEvent(new CustomEvent(i.options["eventAfter".concat(g)], {
              bubbles: !0,
              cancelable: !0,
              detail: p
            })), h && h();
          }]));
        }
      }
      /* eslint-enable jsdoc/check-param-names */
      /**
       * Tests if change in state should happen or not.
       * Classes inheriting {@link EventedState `EventedState`} should override this function.
       * @function EventedState#shouldStateBeChanged
       * @param {string} [state] The new state. Can be an omitted, which means toggling.
       * @param {object} [detail]
       *   The object that should be put to event details that is fired before/after changing state.
       *   Can have a `group` property, which specifies what state to be changed.
       * @returns {boolean}
       *   `false` if change in state shouldn't happen, e.g. when the given new state is the same as the current one.
       */
    }]), n;
  }(o);
  return e;
}
function Ot(o, e) {
  var t = o.target, s = o.currentTarget;
  if (typeof t.matches == "function") {
    if (t.matches(e))
      return t;
    if (t.matches("".concat(e, " *"))) {
      var n = t.closest(e);
      if ((s.nodeType === Node.DOCUMENT_NODE ? s.documentElement : s).contains(n))
        return n;
    }
  }
}
function ns(o) {
  if (!o || typeof o == "function")
    return {
      launchingElement: null,
      launchingEvent: null
    };
  var e = o.delegateTarget || o.currentTarget || o, t = o.currentTarget && o;
  if (e && !e.nodeType)
    throw new TypeError("DOM Node should be given for launching element.");
  if (t && !t.type)
    throw new TypeError("DOM event should be given for launching event.");
  return {
    launchingElement: e,
    launchingEvent: t
  };
}
function Tt(o) {
  "@babel/helpers - typeof";
  return Tt = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Tt(o);
}
function wi(o, e) {
  if (!(o instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function as(o, e) {
  for (var t = 0; t < e.length; t++) {
    var s = e[t];
    s.enumerable = s.enumerable || !1, s.configurable = !0, "value" in s && (s.writable = !0), Object.defineProperty(o, s.key, s);
  }
}
function Mi(o, e, t) {
  return e && as(o.prototype, e), t && as(o, t), Object.defineProperty(o, "prototype", {
    writable: !1
  }), o;
}
function Ai(o, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Super expression must either be null or a function");
  o.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: o,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(o, "prototype", {
    writable: !1
  }), e && Lt(o, e);
}
function Lt(o, e) {
  return Lt = Object.setPrototypeOf || function(s, n) {
    return s.__proto__ = n, s;
  }, Lt(o, e);
}
function Ci(o) {
  var e = Ri();
  return function() {
    var s = Ye(o), n;
    if (e) {
      var a = Ye(this).constructor;
      n = Reflect.construct(s, arguments, a);
    } else
      n = s.apply(this, arguments);
    return ki(this, n);
  };
}
function ki(o, e) {
  if (e && (Tt(e) === "object" || typeof e == "function"))
    return e;
  if (e !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return Ii(o);
}
function Ii(o) {
  if (o === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return o;
}
function Ri() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function Ye(o) {
  return Ye = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, Ye(o);
}
function Di(o) {
  var e = /* @__PURE__ */ function(t) {
    Ai(n, t);
    var s = Ci(n);
    function n() {
      return wi(this, n), s.apply(this, arguments);
    }
    return Mi(n, [{
      key: "show",
      value: (
        /**
         */
        /**
         * Switch to 'shown' state.
         * @param [evtOrElem] The launching event or element.
         * @param {EventedState~changeStateCallback} [callback] The callback.
         */
        function(i, r) {
          (!i || typeof i == "function") && (r = i), this.changeState("shown", ns(i), r);
        }
      )
      /**
       * Switch to 'hidden' state.
       * @param [evtOrElem] The launching event or element.
       * @param {EventedState~changeStateCallback} [callback] The callback.
       */
    }, {
      key: "hide",
      value: function(i, r) {
        (!i || typeof i == "function") && (r = i), this.changeState("hidden", ns(i), r);
      }
    }]), n;
  }(o);
  return e;
}
var _i = [Li, Di];
const Pi = _i;
function Vi(o) {
  return o && o.__esModule && Object.prototype.hasOwnProperty.call(o, "default") ? o.default : o;
}
var js = function() {
};
process.env.NODE_ENV !== "production" && (js = function(o, e, t) {
  var s = arguments.length;
  t = new Array(s > 2 ? s - 2 : 0);
  for (var n = 2; n < s; n++)
    t[n - 2] = arguments[n];
  if (e === void 0)
    throw new Error(
      "`warning(condition, format, ...args)` requires a warning message argument"
    );
  if (e.length < 10 || /^[s\W]*$/.test(e))
    throw new Error(
      "The warning format should be able to uniquely identify this warning. Please, use a more descriptive format than: " + e
    );
  if (!o) {
    var a = 0, i = "Warning: " + e.replace(/%s/g, function() {
      return t[a++];
    });
    typeof console < "u" && console.error(i);
    try {
      throw new Error(i);
    } catch {
    }
  }
});
var Bi = js;
const $i = /* @__PURE__ */ Vi(Bi);
function wt(o) {
  "@babel/helpers - typeof";
  return wt = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, wt(o);
}
function Gi(o, e) {
  if (!(o instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function is(o, e) {
  for (var t = 0; t < e.length; t++) {
    var s = e[t];
    s.enumerable = s.enumerable || !1, s.configurable = !0, "value" in s && (s.writable = !0), Object.defineProperty(o, s.key, s);
  }
}
function Ni(o, e, t) {
  return e && is(o.prototype, e), t && is(o, t), Object.defineProperty(o, "prototype", {
    writable: !1
  }), o;
}
function Hi(o, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Super expression must either be null or a function");
  o.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: o,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(o, "prototype", {
    writable: !1
  }), e && Mt(o, e);
}
function Mt(o, e) {
  return Mt = Object.setPrototypeOf || function(s, n) {
    return s.__proto__ = n, s;
  }, Mt(o, e);
}
function Ui(o) {
  var e = Wi();
  return function() {
    var s = qe(o), n;
    if (e) {
      var a = qe(this).constructor;
      n = Reflect.construct(s, arguments, a);
    } else
      n = s.apply(this, arguments);
    return zi(this, n);
  };
}
function zi(o, e) {
  if (e && (wt(e) === "object" || typeof e == "function"))
    return e;
  if (e !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return Fi(o);
}
function Fi(o) {
  if (o === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return o;
}
function Wi() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function qe(o) {
  return qe = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, qe(o);
}
function ji(o) {
  var e = /* @__PURE__ */ function(t) {
    Hi(n, t);
    var s = Ui(n);
    function n() {
      return Gi(this, n), s.apply(this, arguments);
    }
    return Ni(n, null, [{
      key: "init",
      value: (
        /**
         * `true` suggests that this component is lazily initialized upon an action/event, etc.
         * @type {boolean}
         */
        /**
         * Instantiates this component in the given element.
         * If the given element indicates that it's an component of this class, instantiates it.
         * Otherwise, instantiates this component by clicking on launcher buttons
         * (buttons with attribute that `options.attribInitTarget` points to) of this component in the given node.
         * @param {Node} target The DOM node to instantiate this component in. Should be a document or an element.
         * @param {object} [options] The component options.
         * @param {string} [options.selectorInit] The CSS selector to find this component.
         * @param {string} [options.attribInitTarget] The attribute name in the launcher buttons to find target component.
         * @returns {Handle} The handle to remove the event listener to handle clicking.
         */
        function() {
          var i = this, r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : document, l = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, c = Object.assign(Object.create(this.options), l);
          if (!r || r.nodeType !== Node.ELEMENT_NODE && r.nodeType !== Node.DOCUMENT_NODE)
            throw new TypeError("DOM document or DOM element should be given to search for and initialize this widget.");
          if (r.nodeType === Node.ELEMENT_NODE && r.matches(c.selectorInit))
            this.create(r, l);
          else {
            var d = c.initEventNames.map(function(p) {
              return Be(r, p, function(h) {
                var u = Ot(h, "[".concat(c.attribInitTarget, "]"));
                if (u) {
                  h.delegateTarget = u;
                  var g = u.ownerDocument.querySelectorAll(u.getAttribute(c.attribInitTarget));
                  if (g.length > 1)
                    throw new Error("Target widget must be unique.");
                  if (g.length === 1) {
                    u.tagName === "A" && h.preventDefault();
                    var m = i.create(g[0], l);
                    typeof m.createdByLauncher == "function" && m.createdByLauncher(h);
                  }
                }
              });
            });
            return {
              release: function() {
                for (var h = d.pop(); h; h = d.pop())
                  h.release();
              }
            };
          }
          return "";
        }
      )
    }]), n.forLazyInit = !0, n;
  }(o);
  return e;
}
function At(o) {
  "@babel/helpers - typeof";
  return At = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, At(o);
}
function Zi(o, e) {
  if (!(o instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function rs(o, e) {
  for (var t = 0; t < e.length; t++) {
    var s = e[t];
    s.enumerable = s.enumerable || !1, s.configurable = !0, "value" in s && (s.writable = !0), Object.defineProperty(o, s.key, s);
  }
}
function Xi(o, e, t) {
  return e && rs(o.prototype, e), t && rs(o, t), Object.defineProperty(o, "prototype", {
    writable: !1
  }), o;
}
function Yi(o, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Super expression must either be null or a function");
  o.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: o,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(o, "prototype", {
    writable: !1
  }), e && Ct(o, e);
}
function Ct(o, e) {
  return Ct = Object.setPrototypeOf || function(s, n) {
    return s.__proto__ = n, s;
  }, Ct(o, e);
}
function qi(o) {
  var e = Qi();
  return function() {
    var s = Ke(o), n;
    if (e) {
      var a = Ke(this).constructor;
      n = Reflect.construct(s, arguments, a);
    } else
      n = s.apply(this, arguments);
    return Ki(this, n);
  };
}
function Ki(o, e) {
  if (e && (At(e) === "object" || typeof e == "function"))
    return e;
  if (e !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return Ji(o);
}
function Ji(o) {
  if (o === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return o;
}
function Qi() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function Ke(o) {
  return Ke = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, Ke(o);
}
var er = /* @__PURE__ */ function(o) {
  Yi(t, o);
  var e = qi(t);
  function t(s, n) {
    var a;
    return Zi(this, t), a = e.call(this, s, n), a._handleFocusinListener = void 0, a._handleKeydownListener = void 0, a._handleFocusin = function(i) {
      var r = a.element.querySelector(a.options.selectorModalContainer) || a.element;
      a.element.classList.contains(a.options.classVisible) && !r.contains(i.target) && a.options.selectorsFloatingMenus.every(function(l) {
        return !Ot(i, l);
      }) && a.element.querySelector(dt.selectorTabbable).focus();
    }, a._hookCloseActions(), a;
  }
  return Xi(t, [{
    key: "createdByLauncher",
    value: (
      /**
       * A method that runs when `.init()` is called from `initComponentByLauncher`.
       * @param {Event} evt The event fired on the launcher button.
       */
      function(n) {
        this.show(n);
      }
    )
    /**
     * Determines whether or not to emit events and callback function when `.changeState()` is called from `eventedState`.
     * @param {string} state The new state.
     * @returns {boolean} `true` if the given `state` is different from current state.
     */
  }, {
    key: "shouldStateBeChanged",
    value: function(n) {
      return n === "shown" ? !this.element.classList.contains(this.options.classVisible) : this.element.classList.contains(this.options.classVisible);
    }
    /**
     * Changes the shown/hidden state.
     * @private
     * @param {string} state The new state.
     * @param {object} detail The detail data to be included in the event that will be fired.
     * @param {Function} callback Callback called when change in state completes.
     */
  }, {
    key: "_changeState",
    value: function(n, a, i) {
      var r = this, l, c = function() {
        if (l && (l = r.unmanage(l).release()), n === "shown" && r.element.offsetWidth > 0 && r.element.offsetHeight > 0) {
          r.previouslyFocusedNode = r.element.ownerDocument.activeElement;
          var u = r.element.querySelector(r.options.selectorPrimaryFocus) || r.element.querySelector(dt.selectorTabbable);
          u.focus(), process.env.NODE_ENV !== "production" && process.env.NODE_ENV !== "production" && $i(u, "Modals need to contain a focusable element by either using " + "`".concat(r.options.selectorPrimaryFocus, "` or settings.selectorTabbable."));
        }
        i();
      };
      if (this._handleFocusinListener && (this._handleFocusinListener = this.unmanage(this._handleFocusinListener).release()), n === "shown") {
        var d = "onfocusin" in this.element.ownerDocument.defaultView, p = d ? "focusin" : "focus";
        this._handleFocusinListener = this.manage(Be(this.element.ownerDocument, p, this._handleFocusin, !d));
      }
      n === "hidden" ? (this.element.classList.toggle(this.options.classVisible, !1), this.element.ownerDocument.body.classList.toggle(this.options.classBody, !1), (this.options.selectorFocusOnClose || this.previouslyFocusedNode) && (this.element.ownerDocument.querySelector(this.options.selectorFocusOnClose) || this.previouslyFocusedNode).focus()) : n === "shown" && (this.element.classList.toggle(this.options.classVisible, !0), this.element.ownerDocument.body.classList.toggle(this.options.classBody, !0)), l = this.manage(Be(this.element, "transitionend", c));
    }
  }, {
    key: "_hookCloseActions",
    value: function() {
      var n = this;
      this.manage(Be(this.element, "click", function(a) {
        var i = Ot(a, n.options.selectorModalClose);
        i && (a.delegateTarget = i), (i || a.target === n.element) && n.hide(a);
      })), this._handleKeydownListener && (this._handleKeydownListener = this.unmanage(this._handleKeydownListener).release()), this._handleKeydownListener = this.manage(Be(this.element.ownerDocument.body, "keydown", function(a) {
        a.which === 27 && n.shouldStateBeChanged("hidden") && (a.stopPropagation(), n.hide(a));
      }));
    }
    /**
     * Handles `focusin` (or `focus` depending on browser support of `focusin`) event to do wrap-focus behavior.
     * @param {Event} evt The event.
     * @private
     */
  }], [{
    key: "options",
    get: (
      /**
       * The component options.
       * If `options` is specified in the constructor, {@linkcode Modal.create .create()}, or {@linkcode Modal.init .init()},
       * properties in this object are overridden for the instance being create and how {@linkcode Modal.init .init()} works.
       * @member Modal.options
       * @type {object}
       * @property {string} selectorInit The CSS class to find modal dialogs.
       * @property {string} [selectorModalClose] The selector to find elements that close the modal.
       * @property {string} [selectorPrimaryFocus] The CSS selector to determine the element to put focus when modal gets open.
       * @property {string} [selectorFocusOnClose] The CSS selector to determine the element to put focus when modal closes.
       *   If undefined, focus returns to the previously focused element prior to the modal opening.
       * @property {string} [selectorModalContainer] The CSS selector for the content container of the modal for focus wrap feature.
       * @property {string} attribInitTarget The attribute name in the launcher buttons to find target modal dialogs.
       * @property {string[]} [selectorsFloatingMenu]
       *   The CSS selectors of floating menus.
       *   Used for detecting if focus-wrap behavior should be disabled temporarily.
       * @property {string} [classVisible] The CSS class for the visible state.
       * @property {string} [classBody] The CSS class for `<body>` with open modal.
       * @property {string} [classNoScroll] The CSS class for hiding scroll bar in body element while modal is shown.
       * @property {string} [eventBeforeShown]
       *   The name of the custom event fired before this modal is shown.
       *   Cancellation of this event stops showing the modal.
       * @property {string} [eventAfterShown]
       *   The name of the custom event telling that modal is sure shown
       *   without being canceled by the event handler named by `eventBeforeShown` option (`modal-beingshown`).
       * @property {string} [eventBeforeHidden]
       *   The name of the custom event fired before this modal is hidden.
       *   Cancellation of this event stops hiding the modal.
       * @property {string} [eventAfterHidden]
       *   The name of the custom event telling that modal is sure hidden
       *   without being canceled by the event handler named by `eventBeforeHidden` option (`modal-beinghidden`).
       */
      function() {
        var n = dt.prefix;
        return {
          selectorInit: "[data-modal]",
          selectorModalClose: "[data-modal-close]",
          selectorPrimaryFocus: "[data-modal-primary-focus]",
          selectorsFloatingMenus: [".".concat(n, "--overflow-menu-options"), ".".concat(n, "--tooltip"), ".flatpickr-calendar"],
          selectorModalContainer: ".".concat(n, "--modal-container"),
          classVisible: "is-visible",
          classBody: "".concat(n, "--body--with-modal-open"),
          attribInitTarget: "data-modal-target",
          initEventNames: ["click"],
          eventBeforeShown: "modal-beingshown",
          eventAfterShown: "modal-shown",
          eventBeforeHidden: "modal-beinghidden",
          eventAfterHidden: "modal-hidden"
        };
      }
    )
  }]), t.components = /* @__PURE__ */ new WeakMap(), t;
}(qa(ni, ji, Pi, ui));
const tr = er;
class rc extends z {
  constructor(e, t, s) {
    super(e, t, s), this.type = "modal", this.isEventListenerAdded = !1, this.handleShowModal = () => {
      this.modal.html(this.getModalHTML()), this.modal.select("div.cds--modal-footer button.cds--btn").on("click", () => this.model.exportToCSV()), tr.create(this.modal.node()).show();
    }, this.init();
  }
  addEventListeners() {
    this.services.events.addEventListener(f.Modal.SHOW, this.handleShowModal);
  }
  removeEventListeners() {
    this.services.events.removeEventListener(f.Modal.SHOW, this.handleShowModal);
  }
  getModalHTML() {
    const e = this.model.getOptions(), t = y(e, "style", "prefix"), s = this.model.getTabularDataArray();
    return `
		<div class="cds--modal-container cds--modal-container">
			<div class="cds--modal-header cds--modal-header">
				<p class="cds--modal-header__label cds--type-delta cds--modal-header__label cds--type-delta" id="modal-title">Tabular representation</p>

				<p class="cds--modal-header__heading cds--type-beta cds--modal-header__heading cds--type-beta" id="modal-description">${e.title}</p>

				<button class="cds--modal-close cds--modal-close" type="button" data-modal-close aria-label="close modal"  data-modal-primary-focus>
					<svg focusable="false" preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg" fill="currentColor" aria-label="Close" width="20" height="20" viewBox="0 0 32 32" role="img" class="cds--modal-close__icon cds--modal-close__icon">
						<path d="M24 9.4L22.6 8 16 14.6 9.4 8 8 9.4 14.6 16 8 22.6 9.4 24 16 17.4 22.6 24 24 22.6 17.4 16 24 9.4z"></path>
					</svg>
				</button>
			</div>

			<div class="cds--modal-content cds--modal-content">
				<table class="cds--data-table cds--data-table--no-border cds--data-table cds--data-table--no-border">
					<thead>
						<tr>
							${Q(s, 0).map(
      (n) => `<th scope="col">
								<div class="cds--table-header-label cds--table-header-label">${n}</div>
							</th>`
    ).join("")}
						</tr>
					</thead>

					<tbody>${s.slice(1).map(
      (n) => `
							<tr>
								${n.map((a) => `<td>${a}</td>`).join("")}
							</tr>`
    ).join("")}
					</tbody>
				</table>
			</div>

			<div class="cds--modal-footer cds--modal-footer">
			  <div class="${he}--${t}-modal-footer-spacer"></div>
			  <button class="cds--btn cds--btn--primary cds--btn cds--btn--primary" type="button" data-modal-primary-focus>Download as CSV</button>
			</div>
		</div>`;
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(e = !1) {
    const t = this.model.getOptions();
    if (!this.isEventListenerAdded) {
      const s = x(this.services.domUtils.getHolder()), n = y(t, "style", "prefix");
      this.modal = E.appendOrSelect(s, `div.${he}--${n}--modal`), this.addEventListeners(), this.isEventListenerAdded = !0, this.modal.attr("data-modal", !0).attr("class", "cds--modal cds--modal").attr("role", "dialog").attr("aria-modal", !0).attr("aria-labelledby", "modal-title").attr("aria-describedby", "modal-description").attr("tabindex", -1);
    }
  }
  destroy() {
    this.removeEventListeners(), this.isEventListenerAdded = !1;
  }
}
class sr extends z {
  constructor() {
    super(...arguments), this.type = "title", this.renderType = H.HTML;
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(e = !1) {
    const t = this.getComponentContainer(), s = y(this.getOptions(), "title"), n = t.selectAll("p.title").data([s]);
    if (n.enter().append("p").classed("title", !0).attr("role", "heading").attr("aria-level", 2).merge(n).html((a) => a), n.node() && n.node().offsetWidth < n.node().scrollWidth) {
      const a = this;
      n.on("mouseover", function(i) {
        a.services.events.dispatchEvent(f.Tooltip.SHOW, {
          event: i,
          hoveredElement: n,
          content: n.text()
        });
      }).on("mousemove", function(i) {
        a.services.events.dispatchEvent(f.Tooltip.MOVE, {
          event: i
        });
      }).on("mouseout", function() {
        a.services.events.dispatchEvent(f.Tooltip.HIDE);
      });
    }
    n.exit().remove();
  }
  /**
   * Truncates title creating ellipses and attaching tooltip for exposing full title.
   */
  truncateTitle(e, t) {
    if (t <= 0)
      return;
    const s = e.text();
    if (e.node().getComputedTextLength() > t) {
      e.append("tspan").text("...");
      const n = E.appendOrSelect(e, "tspan").node().getComputedTextLength(), a = e.text(), i = this.getSubstringIndex(
        e.node(),
        0,
        a.length - 1,
        t - n
      );
      e.html(a.substring(0, i - 1)).append("tspan").text("...");
      const r = this;
      e.on("mouseover", function(l) {
        r.services.events.dispatchEvent(f.Tooltip.SHOW, {
          event: l,
          hoveredElement: e,
          content: s
        });
      }).on("mousemove", function(l) {
        r.services.events.dispatchEvent(f.Tooltip.MOVE, {
          event: l
        });
      }).on("mouseout", function() {
        r.services.events.dispatchEvent(f.Tooltip.HIDE);
      });
    }
  }
  // computes the maximum space a title can take
  getMaxTitleWidth() {
    return E.getSVGElementSize(this.parent.node(), {
      useAttrs: !0
    }).width;
  }
  /**
   * Returns the index for a maximum length substring that is less than the width parameter.
   * @param title the title node used for getting the text lengths of substrings
   * @param start the start index for the binary search
   * @param end the end index for the binary search
   * @param width the width of the svg container that holds the title
   */
  getSubstringIndex(e, t, s, n) {
    const a = Math.floor((s + t) / 2);
    return e.getSubStringLength(0, a) > n ? this.getSubstringIndex(e, t, a, n) : e.getSubStringLength(0, a) < n ? e.getSubStringLength(0, a + 1) > n ? a : this.getSubstringIndex(e, a, s, n) : a;
  }
}
class nr extends z {
  constructor() {
    super(...arguments), this.type = "legend", this.renderType = H.HTML;
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(e = !1) {
    const t = this.getOptions(), s = y(t, "legend"), n = y(s, "alignment"), a = y(t, "legend", "orientation");
    let i = this.model.getDataGroups();
    const { DISABLED: r } = K.items.status, l = i.some((S) => S.status === r), c = y(s, "order"), d = this.getComponentContainer().classed("center-aligned", n === ue.CENTER).classed("right-aligned", n === ue.RIGHT).classed(a, !0).classed("has-deactivated-items", l).attr("role", U.GROUP).attr("aria-label", "Data groups").attr("data-name", "legend-items");
    c && (i = this.sortDataGroups(i, c));
    const p = d.selectAll("div.legend-item").data(i, (S) => S.name), h = p.enter().append("div").attr("class", "legend-item");
    h.merge(d.selectAll("div.legend-item")).classed("active", function(S) {
      return S.status === K.items.status.ACTIVE;
    });
    const u = y(this.getOptions(), "legend", "clickable");
    d.classed("clickable", u && i.length > 1);
    const g = K.checkbox.radius, m = h.append("div").classed("checkbox", !0), b = m.merge(p.select("div.checkbox")).attr("role", U.CHECKBOX).attr("tabindex", u ? 0 : -1).attr(
      "aria-labelledby",
      (S, T) => this.services.domUtils.generateElementIDString(`legend-datagroup-${T}-title`)
    ).attr("aria-checked", ({ status: S }) => S === K.items.status.ACTIVE).attr("width", g * 2).attr("height", g * 2).attr(
      "class",
      (S) => this.model.getColorClassName({
        classNameTypes: [$.BACKGROUND],
        dataGroupName: S.name,
        originalClassName: "checkbox"
      })
    ).style(
      "background",
      (S) => S.status === K.items.status.ACTIVE ? this.model.getFillColor(S.name) || this.model.getStrokeColor(S.name) : null
    ).classed("active", function(S) {
      return S.status === K.items.status.ACTIVE;
    });
    m.append("svg").attr("focusable", !1).attr("preserveAspectRatio", "xMidYMid meet").attr("xmlns", "http://www.w3.org/2000/svg").attr("width", "11").attr("height", "11").attr("viewBox", "0 0 31 28").attr("aria-hidden", !0).style("will-change", "transform").append("path").attr("d", "M13 21.2l-7.1-7.1-1.4 1.4 7.1 7.1L13 24 27.1 9.9l-1.4-1.5z"), h.append("p").merge(p.select("p"));
    const v = y(t, "legend", "additionalItems");
    if (v && i.length) {
      const S = this, T = d.selectAll("div.additional-item").data(v);
      T.exit().remove();
      const w = T.enter().append("div").merge(T).classed("legend-item", !0).classed("additional", !0).attr(
        "aria-labelledby",
        (k, I) => this.services.domUtils.generateElementIDString(
          `legend-datagroup-${b.size() + I}-title`
        )
      );
      w.selectAll("*").remove();
      let L, O = 1;
      w.append("svg").classed("icon", !0).each(function(k) {
        const I = x(this);
        !L || L != k.type ? (L = k.type, O = 1) : O++, S.addAdditionalItem(I, k, O);
      }), w.append("p").merge(w.select("p")), this.truncateLegendText();
    }
    p.exit().on("mouseover", null).on("click", null).on("mouseout", null).remove(), u && h.size() > 1 && this.addEventListeners();
  }
  sortDataGroups(e, t) {
    if (e.sort(
      (s, n) => t.indexOf(s.name) - t.indexOf(n.name)
    ), t.length < e.length) {
      const s = e.length - t.length;
      return e.slice(s).concat(e.slice(0, s));
    }
    return e;
  }
  addAdditionalItem(e, t, s) {
    const { width: n, height: a } = K.area;
    if (t.type === Se.RADIUS ? e.style("width", `${a}px`).style("height", `${a}px`) : e.style("width", `${n}px`).style("height", `${a}px`), t.type === Se.RADIUS) {
      const { iconData: i, fill: r, stroke: l } = K.radius;
      e.attr("fill", "none").selectAll("circle").data(i).enter().append("circle").classed("radius", !0).attr("role", U.IMG).attr("aria-label", "radius").attr("cx", (d) => d.cx).attr("cy", (d) => d.cy).attr("r", (d) => d.r).style("fill", t.fill ? t.fill : r).style("stroke", t.stroke ? t.stroke : l);
    } else if (t.type === Se.LINE) {
      const i = K.line;
      e.select("line.line").empty() && e.append("line").classed(`line-${s}`, !0).attr("role", U.IMG).attr("aria-label", "line").attr("x1", 0).attr("y1", i.yPosition).attr("x2", n).attr("y2", i.yPosition).style("stroke", t.stroke ? t.stroke : i.stroke).style("stroke-width", i.strokeWidth);
    } else if (t.type === Se.AREA)
      e.select("rect.area").empty() && e.append("rect").classed(`area-${s}`, !0).attr("role", U.IMG).attr("aria-label", "area").attr("width", n).attr("height", a).style(
        "fill",
        s > 3 && !t.fill ? K.area.fill : t.fill
      ).style("stroke", t.stroke);
    else if (t.type === Se.SIZE) {
      const { iconData: i, fill: r, stroke: l } = K.size;
      e.attr("fill", "none").attr("role", U.IMG).attr("aria-label", "size").selectAll("rect").data(i).enter().append("rect").classed("size", !0).attr("width", (d) => d.width).attr("height", (d) => d.height).attr("y", () => 0).style("fill", t.fill ? t.fill : r).style("stroke", t.stroke ? t.stroke : l).style("stroke-width", 1);
    } else if (t.type === Se.QUARTILE) {
      const { iconData: i } = K.quartile;
      e.selectAll("rect").attr("role", U.IMG).attr("aria-label", "quartile").data(i).enter().append("rect").attr("class", (l, c) => `quartile-${c === 0 ? "wrapper" : "line"}`).attr("x", (l) => l.x).attr("y", (l) => l.y).attr("width", (l) => l.width).attr("height", (l) => l.height);
    } else if (t.type === Se.ZOOM) {
      const { iconData: i, color: r } = y(K, "zoom"), l = e.attr("role", U.IMG).attr("aria-label", "zoom").selectAll("g.icon").data(i).enter();
      l.append("g").attr("x", (c) => c.x).attr("y", (c) => c.y).attr("width", (c) => c.width).attr("height", (c) => c.height).append("polygon").attr(
        "points",
        "7.7 4.82 5.78 4.82 5.78 2.89 4.82 2.89 4.82 4.82 2.89 4.82 2.89 5.78 4.82 5.78 4.82 7.7 5.78 7.7 5.78 5.78 7.7 5.78 7.7 4.82"
      ).attr("fill", () => t.color ? t.color : r), l.append("path").attr(
        "d",
        "M9.36,8.67A5.22,5.22,0,0,0,10.59,5.3,5.3,5.3,0,1,0,5.3,10.59,5.22,5.22,0,0,0,8.67,9.36L12.32,13l.68-.68Zm-4.06,1A4.34,4.34,0,1,1,9.63,5.3,4.33,4.33,0,0,1,5.3,9.63Z"
      ).attr("fill", () => t.color ? t.color : r);
    }
  }
  truncateLegendText() {
    const e = this.getComponentContainer(), t = y(this.getOptions(), "legend", "truncation"), s = y(t, "type"), n = y(t, "threshold"), a = y(t, "numCharacter"), i = e.selectAll("div.legend-item p");
    i.attr("id", function() {
      return (this.parentNode.querySelector("div.checkbox") || this.parentNode).getAttribute("aria-labelledby");
    }), s !== Ie.NONE ? i.html(function(r) {
      return r.name.length > n ? Ge(r.name, s, a) : r.name;
    }) : i.html((r) => r.name);
  }
  addEventListeners() {
    const e = this, t = this.getComponentContainer(), s = this.getOptions(), n = y(s, "legend"), a = y(n, "truncation");
    t.selectAll("div.legend-item").on("mouseover", function(i) {
      e.services.events.dispatchEvent(f.Legend.ITEM_HOVER, {
        hoveredElement: x(this)
      });
      const r = x(this);
      r.select("div.checkbox").classed("hovered", !0);
      const l = r.datum();
      l.name.length > a.threshold && a.type !== Ie.NONE && e.services.events.dispatchEvent(f.Tooltip.SHOW, {
        event: i,
        hoveredElement: r,
        content: l.name
      });
    }).on("mousemove", function(i) {
      x(this).datum().name.length > a.threshold && a.type !== Ie.NONE && e.services.events.dispatchEvent(f.Tooltip.MOVE, {
        event: i
      });
    }).on("click", function() {
      e.services.events.dispatchEvent(f.Legend.ITEM_CLICK, {
        clickedElement: x(this)
      });
      const r = x(this).datum();
      e.model.toggleDataLabel(r.name);
    }).on("mouseout", function() {
      const i = x(this);
      i.select("div.checkbox").classed("hovered", !1), i.datum().name.length > a.threshold && a.type !== Ie.NONE && e.services.events.dispatchEvent(f.Tooltip.HIDE), e.services.events.dispatchEvent(f.Legend.ITEM_MOUSEOUT, {
        hoveredElement: i
      });
    }), t.selectAll("div.legend-item div.checkbox").on("keyup", function(i) {
      i.key && i.key === "Tab" && e.services.events.dispatchEvent(f.Legend.ITEM_HOVER, {
        hoveredElement: x(this)
      });
    }), t.selectAll("div.legend-item div.checkbox").on("keydown", function(i, r) {
      i.key && i.key === " " ? (i.preventDefault(), e.model.toggleDataLabel(r.name)) : i.key && i.key === "Tab" && e.services.events.dispatchEvent(f.Legend.ITEM_MOUSEOUT, {
        hoveredElement: x(this)
      });
    }), t.selectAll("g.additional-item").on("mouseover", function(i) {
      const r = x(this), l = r.datum();
      l.name.length > a.threshold && e.services.events.dispatchEvent(f.Tooltip.SHOW, {
        event: i,
        hoveredElement: r,
        content: l.name
      });
    });
  }
}
class ar extends z {
  constructor(e, t, s) {
    super(e, t, s), this.type = "chart-clip", this.renderType = H.SVG, this.chartClipId = "chart-clip-id-" + Math.floor(Math.random() * 99999999999), this.init();
  }
  init() {
    this.model.set({ chartClipId: this.chartClipId }, { skipUpdate: !0 });
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(e = !0) {
    this.createClipPath();
  }
  createClipPath() {
    const e = this.parent, { cartesianScales: t } = this.services;
    if (!t)
      throw new Error("Service cartesianScales was undefined");
    const s = t.getMainXScale(), n = t.getMainYScale(), [a, i] = s.range(), [r, l] = n.range();
    if (!e)
      throw new Error("svg is undefined");
    this.chartClipPath = E.appendOrSelect(e, `clipPath.${this.type}`).attr(
      "id",
      this.chartClipId
    );
    const c = E.appendOrSelect(this.chartClipPath, `rect.${this.type}`);
    i - a > 0 && c.attr("x", a).attr("y", l).attr("width", i - a).attr("height", r - l), this.chartClipPath.merge(c).lower();
  }
}
class oc extends ar {
  constructor() {
    super(...arguments), this.type = "canvas-chart-clip", this.chartClipId = "canvas-chart-clip-id-" + Math.floor(Math.random() * 99999999999);
  }
  createClipPath() {
    const e = this.parent, { width: t, height: s } = E.getSVGElementSize(this.parent, {
      useAttrs: !0
    });
    this.chartClipPath = E.appendOrSelect(e, `clipPath.${this.type}`).attr(
      "id",
      this.chartClipId
    );
    const n = E.appendOrSelect(this.chartClipPath, `rect.${this.type}`);
    n.attr("x", 0).attr("y", 0).attr("width", t).attr("height", s), this.chartClipPath.merge(n).lower();
  }
}
var Me, ne;
(function(o) {
  o.LEFT = "left", o.RIGHT = "right", o.TOP = "top", o.BOTTOM = "bottom";
})(ne || (ne = {}));
var os = (Me = {}, Me[ne.LEFT] = function(o, e, t) {
  return {
    top: o.top - Math.round(e.offsetHeight / 2) + Math.round(t.height / 2),
    left: Math.round(o.left - e.offsetWidth)
  };
}, Me[ne.RIGHT] = function(o, e, t) {
  return {
    top: o.top - Math.round(e.offsetHeight / 2) + Math.round(t.height / 2),
    left: Math.round(o.left + t.width)
  };
}, Me[ne.TOP] = function(o, e, t) {
  return {
    top: Math.round(o.top - e.offsetHeight),
    left: o.left - Math.round(e.offsetWidth / 2) + Math.round(t.width / 2)
  };
}, Me[ne.BOTTOM] = function(o, e, t) {
  return {
    top: Math.round(o.top + t.height),
    left: o.left - Math.round(e.offsetWidth / 2) + Math.round(t.width / 2)
  };
}, Me), ls = typeof window < "u" ? window : {
  innerHeight: 0,
  scrollY: 0,
  innerWidth: 0,
  scrollX: 0
}, et = (
  /** @class */
  function() {
    function o(e) {
      e === void 0 && (e = {}), this.positions = os, this.positions = Object.assign({}, os, e);
    }
    return o.prototype.getRelativeOffset = function(e) {
      for (var t = {
        left: e.offsetLeft,
        top: e.offsetTop
      }; e.offsetParent && getComputedStyle(e.offsetParent).position === "static"; )
        t.left += e.offsetLeft, t.top += e.offsetTop, e = e.offsetParent;
      return t;
    }, o.prototype.getAbsoluteOffset = function(e) {
      for (var t = e, s = {
        top: 0,
        left: 0
      }; t.offsetParent; ) {
        var n = getComputedStyle(t.offsetParent);
        n.position === "static" && n.marginLeft && n.marginTop && (parseInt(n.marginTop, 10) && (s.top += parseInt(n.marginTop, 10)), parseInt(n.marginLeft, 10) && (s.left += parseInt(n.marginLeft, 10))), t = t.offsetParent;
      }
      var a = e.getBoundingClientRect(), i = document.body.getBoundingClientRect();
      return {
        top: a.top - i.top + s.top,
        left: a.left - i.left + s.left
      };
    }, o.prototype.findRelative = function(e, t, s) {
      var n = this.getRelativeOffset(e), a = e.getBoundingClientRect();
      return this.calculatePosition(n, a, t, s);
    }, o.prototype.findAbsolute = function(e, t, s) {
      var n = this.getAbsoluteOffset(e), a = e.getBoundingClientRect();
      return this.calculatePosition(n, a, t, s);
    }, o.prototype.findPosition = function(e, t, s, n) {
      n === void 0 && (n = this.getAbsoluteOffset.bind(this));
      var a = n(e), i = e.getBoundingClientRect();
      return this.calculatePosition(a, i, t, s);
    }, o.prototype.findPositionAt = function(e, t, s) {
      return this.calculatePosition(e, { top: 0, left: 0, height: 0, width: 0 }, t, s);
    }, o.prototype.getPlacementBox = function(e, t) {
      var s = e.offsetHeight + t.top, n = e.offsetWidth + t.left;
      return {
        top: t.top,
        bottom: s,
        left: t.left,
        right: n
      };
    }, o.prototype.addOffset = function(e, t, s) {
      return t === void 0 && (t = 0), s === void 0 && (s = 0), Object.assign({}, e, {
        top: e.top + t,
        left: e.left + s
      });
    }, o.prototype.setElement = function(e, t) {
      e.style.top = t.top + "px", e.style.left = t.left + "px";
    }, o.prototype.findBestPlacement = function(e, t, s, n, a) {
      var i = this;
      n === void 0 && (n = this.defaultContainerFunction.bind(this)), a === void 0 && (a = this.findPosition.bind(this));
      var r = s.map(function(l) {
        var c = a(e, t, l), d = i.getPlacementBox(t, c), p = 0, h = 0, u = n();
        d.top < u.top ? p = u.top - d.top : d.bottom > u.height && (p = d.bottom - u.height), d.left < u.left ? h = u.left - d.left : d.right > u.width && (h = d.right - u.width), p && !h ? h = 1 : h && !p && (p = 1);
        var g = t.offsetHeight * t.offsetWidth, m = p * h, b = g - m, v = b / g;
        return {
          placement: l,
          weight: v
        };
      });
      return r.sort(function(l, c) {
        return c.weight - l.weight;
      }), r[0].placement;
    }, o.prototype.findBestPlacementAt = function(e, t, s, n) {
      var a = this;
      n === void 0 && (n = this.defaultContainerFunction.bind(this));
      var i = function(r, l, c) {
        return a.findPositionAt(e, l, c);
      };
      return this.findBestPlacement(null, t, s, n, i);
    }, o.prototype.defaultContainerFunction = function() {
      return {
        // we go with window here, because that's going to be the simple/common case
        top: 0,
        left: 0,
        height: ls.innerHeight,
        width: ls.innerWidth
      };
    }, o.prototype.calculatePosition = function(e, t, s, n) {
      return this.positions[n] ? this.positions[n](e, s, t) : (console.error("No function found for placement, defaulting to 0,0"), { left: 0, top: 0 });
    }, o;
  }()
);
new et();
class ir extends z {
  constructor(e, t, s) {
    super(e, t, s), this.type = "tooltip", this.renderType = H.HTML, this.isEventListenerAdded = !1, this.positionService = new et(), this.handleShowTooltip = (n) => {
      const a = n.detail.data || n.detail.items;
      let i;
      const r = this.formatItems(this.getItems(n));
      n.detail.content ? i = `<div class="title-tooltip"><p>${n.detail.content}</p></div>` : i = this.getTooltipHTML(r);
      const l = E.appendOrSelect(this.tooltip, "div.content-box");
      if (y(this.getOptions(), "tooltip", "customHTML"))
        if (n.detail.content) {
          const c = `<div class="title-tooltip"><p>${n.detail.content}</p></div>`;
          l.html(c);
        } else
          l.html(this.model.getOptions().tooltip.customHTML(a, i));
      else
        l.html(i);
      l.selectAll(".datapoint-tooltip").each(function(c, d) {
        const p = r[d];
        r[d] && r[d].color && x(this).select(".tooltip-color").attr("class", "tooltip-color").style("background-color", p.color);
      }), this.positionTooltip(n), this.tooltip.classed("hidden", !1).attr("aria-hidden", !1);
    }, this.handleHideTooltip = () => {
      this.tooltip.classed("hidden", !0).attr("aria-hidden", !0);
    }, this.init();
  }
  addTooltipEventListener() {
    this.services.events.addEventListener(f.Tooltip.MOVE, (e) => {
      this.tooltip.classed("hidden") === !1 && this.positionTooltip(e);
    }), this.services.events.addEventListener(f.Tooltip.SHOW, this.handleShowTooltip), this.services.events.addEventListener(f.Tooltip.HIDE, this.handleHideTooltip), this.services.events.addEventListener(f.Chart.MOUSEOUT, this.handleHideTooltip);
  }
  removeTooltipEventListener() {
    this.services.events.removeEventListener(f.Tooltip.MOVE, null), this.services.events.removeEventListener(f.Tooltip.SHOW, this.handleShowTooltip), this.services.events.removeEventListener(f.Tooltip.HIDE, this.handleHideTooltip), this.services.events.removeEventListener(f.Chart.MOUSEOUT, this.handleHideTooltip);
  }
  getItems(e) {
    return e.detail.items ? e.detail.items : [];
  }
  formatItems(e) {
    const t = this.getOptions(), s = y(t, "tooltip", "truncation", "type"), n = y(t, "tooltip", "truncation", "threshold"), a = y(t, "tooltip", "truncation", "numCharacter");
    return s !== Ie.NONE ? e.map((i) => {
      const r = i.labelIcon ? 12 : 0;
      return i.value = i.value ? this.valueFormatter(i.value, i.label) : i.value, i.label && i.label.length + r > n && (i.label = Ge(i.label, s, a)), i.value && i.value.length > n && (i.value = Ge(i.value, s, a)), i;
    }) : e;
  }
  getTooltipHTML(e) {
    return '<ul class="multi-tooltip">' + e.map(
      (t) => `<li>
					<div class="datapoint-tooltip${t.bold ? " bold" : ""}">
						${t.class || t.color ? `<div class="tooltip-color ${t.class}"></div>` : ""}
						<div class="label">
						<p>${t.label || ""}</p>
						${t.labelIcon ? `<span class="label-icon"/>${t.labelIcon}</span>` : ""}
						</div>
						${t.value === void 0 || t.value === null ? "" : `<p class="value"/>${t.value}</p>`}
					</div>
				</li>`
    ).join("") + "</ul>";
  }
  valueFormatter(e, t) {
    const s = this.getOptions(), n = y(s, "tooltip", "valueFormatter");
    if (n)
      return n(e, t);
    if (typeof e.getTime == "function")
      return Ut(e, "MMM d, yyyy");
    try {
      if (typeof e == "string" && /\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}.\d{3}Z/.test(e))
        return Ut(Date.parse(e), "MMM d, yyyy");
    } catch {
    }
    return e.toLocaleString();
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(e = !1) {
    const t = this.getOptions(), s = y(t, "tooltip", "enabled");
    if (s) {
      const n = x(this.services.domUtils.getHolder()), a = y(t, "style", "prefix");
      this.tooltip = E.appendOrSelect(n, `div.${he}--${a}--tooltip`), this.tooltip.style("max-width", null).attr("role", "tooltip"), this.isEventListenerAdded || (this.addTooltipEventListener(), this.isEventListenerAdded = !0), this.tooltip.classed("hidden", !0);
    } else
      !s && this.isEventListenerAdded && (this.removeTooltipEventListener(), this.isEventListenerAdded = !1);
  }
  positionTooltip(e) {
    const t = this.services.domUtils.getHolder(), s = this.tooltip.node(), n = this.getOptions(), a = y(n, "zoomBar", "top", "enabled");
    let i = y(e, "detail", "mousePosition");
    if (!i)
      i = Je(y(e, "detail", "event"), t);
    else {
      const h = y(n, "zoomBar", "top", "type"), u = de.height[h];
      a && (i[1] += u + de.spacerHeight);
    }
    const r = t.offsetWidth, l = t.offsetHeight;
    let c;
    i[0] / r > 0.9 ? c = ne.LEFT : i[0] / r < 0.1 ? c = ne.RIGHT : c = this.positionService.findBestPlacementAt(
      {
        left: i[0],
        top: i[1]
      },
      s,
      [ne.RIGHT, ne.LEFT, ne.TOP, ne.BOTTOM],
      () => ({
        top: void 0,
        // properties were never set to optional (probably should)
        left: void 0,
        // ditto
        width: r,
        height: l
      })
    );
    let { horizontalOffset: d } = wn;
    c === ne.LEFT && (d *= -1);
    const p = this.positionService.findPositionAt(
      {
        left: i[0] + d,
        top: i[1]
      },
      s,
      c
    );
    this.positionService.setElement(s, p);
  }
}
const Zs = class je extends z {
  constructor() {
    super(...arguments), this.type = "grid-brush", this.renderType = H.SVG, this.selectionSelector = "rect.selection", this.frontSelectionSelector = "rect.frontSelection";
  }
  // needs to match the class name in _grid-brush.scss
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(e = !0) {
    const t = this.parent, s = this.getComponentContainer();
    if (!t)
      throw new Error("SVG was not defined");
    const n = E.appendOrSelect(t, "svg.chart-grid-backdrop"), a = E.appendOrSelect(n, `g.${this.type}`), i = E.appendOrSelect(a, this.selectionSelector), { width: r, height: l } = E.getSVGElementSize(n, {
      useAttrs: !0
    }), { cartesianScales: c } = this.services, d = c.getMainXScaleType(), p = c.getMainXScale(), [h] = p.range();
    s.attr("transform", `translate(${h},0)`);
    const u = E.appendOrSelect(s, this.frontSelectionSelector);
    if (p && d === te.TIME) {
      let g = this.model.get("zoomDomain");
      g === void 0 && (g = this.services.zoom.getDefaultZoomBarDomain(), g && this.model.set({ zoomDomain: g }, { animate: !1 }));
      const m = (L) => {
        const O = L[1] - L[0];
        let k = "0," + O.toString();
        const I = Math.floor(l / je.DASH_LENGTH), F = I * je.DASH_LENGTH;
        for (let P = 0; P < I; P++)
          k += "," + je.DASH_LENGTH;
        k += "," + (l - F), I % 2 === 1 && (k += ",0"), k += "," + O.toString(), k += "," + l.toString(), u.attr("stroke-dasharray", k);
      }, b = (L) => {
        const O = L.selection;
        O === null || O[0] === O[1] || (u.attr("x", parseFloat(i.attr("x")) + parseFloat(n.attr("x"))).attr("y", i.attr("y")).attr("width", i.attr("width")).attr("height", i.attr("height")).style("cursor", "pointer").style("display", null), m(O));
      }, v = (L, O) => {
        const k = qs().range([0, r]).domain(g);
        let I = [k.invert(L), k.invert(O)];
        I[0].valueOf() === I[1].valueOf() && (I = this.services.zoom.getDefaultZoomBarDomain()), (g[0].valueOf() !== I[0].valueOf() || g[1].valueOf() !== I[1].valueOf()) && this.services.zoom.handleDomainChange(I);
      };
      let S;
      const T = (L) => {
        const O = L.selection;
        O !== null && (v(O[0], O[1]), a.call(S.move, null), u.style("display", "none"));
      };
      l != 0 && r != 0 && (S = ms().extent([
        [0, 0],
        [r - 1, l]
      ]).on("start brush end", b).on("end.brushed", T), a.call(S));
      const w = this.services.zoom.getZoomRatio();
      n.on("click", function(L) {
        if (L.shiftKey) {
          const O = this.services.domUtils.getHolder(), k = Je(a.node(), O)[0];
          let I = k - r * w / 2;
          I < 0 && (I = 0);
          let F = k + r * w / 2;
          F > r && (F = r), v(I, F);
        }
      });
    }
  }
};
Zs.DASH_LENGTH = 4;
let lc = Zs;
class cc extends z {
  constructor() {
    super(...arguments), this.type = "zoom-bar", this.renderType = H.SVG, this.MIN_SELECTION_DIFF = 9e-10, this.brushSelector = "g.zoom-bar-brush", this.clipId = "zoomBarClip-" + Math.floor(Math.random() * 99999999999), this.brush = ms(), this.highlightStrokeWidth = 1;
  }
  init() {
    this.services.events.addEventListener(f.ZoomBar.UPDATE, this.render.bind(this));
    const e = y(this.getOptions(), "zoomBar", V.TOP, "data");
    this.model.setZoomBarData(e);
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(e = !0) {
    const t = this.getComponentContainer(), s = this.services.zoom.isZoomBarLoading(V.TOP), n = this.services.zoom.isZoomBarLocked(V.TOP), a = y(this.getOptions(), "zoomBar", V.TOP, "type"), i = y(this.getOptions(), "axes", V.BOTTOM, "highlights"), r = de.height[a], { width: l } = E.getSVGElementSize(this.parent, {
      useAttrs: !0
    });
    if (l === 0)
      return;
    let c = 0;
    const d = this.model.get("axesMargins");
    d && d.left && (c = d.left);
    const p = E.appendOrSelect(t, "svg.zoom-container").attr("width", "100%").attr("height", r).attr("opacity", 1);
    if (E.appendOrSelect(t, "rect.zoom-spacer").attr("x", 0).attr("y", r).attr("width", "100%").attr("height", de.spacerHeight).attr("opacity", 1).attr("fill", "none"), a === Le.GRAPH_VIEW ? E.appendOrSelect(p, "rect.zoom-bg").attr("x", c).attr("y", 0).attr("width", l - c).attr("height", "100%").classed("zoom-bg-skeleton", s).style(
      "stroke",
      s ? `url(#${this.services.domUtils.generateElementIDString("shimmer-lines")})` : null
    ) : a === Le.SLIDER_VIEW && E.appendOrSelect(p, "rect.zoom-slider-bg").attr("x", c).attr("y", r / 2 - 1).attr("width", l - c).attr("height", 2).classed("zoom-slider-bg-skeleton", s).style(
      "stroke",
      s ? `url(#${this.services.domUtils.generateElementIDString("shimmer-lines")})` : null
    ), s) {
      this.renderSkeleton(p, c, l);
      return;
    }
    const { cartesianScales: h } = this.services, u = h.getMainXScale(), g = h.getMainYScale(), m = h.getMainXScaleType();
    if (u && m === te.TIME) {
      let b = this.services.zoom.getZoomBarData();
      if (Os(b) || b.length === 1)
        return;
      this.xScale = u.copy(), this.yScale = g.copy();
      const v = this.services.zoom.getDefaultZoomBarDomain(b);
      b = this.compensateDataForDefaultDomain(b, v);
      const S = this.model.get("initialZoomDomain"), T = y(
        this.getOptions(),
        "zoomBar",
        V.TOP,
        "initialZoomDomain"
      );
      T && T[0] && T[1] && (T[0] = new Date(T[0]), T[1] = new Date(T[1])), T && !(S && S[0].valueOf() === T[0].valueOf() && S[1].valueOf() === T[1].valueOf()) ? this.model.set(
        {
          // use a new object instead of newInitialZoomDomain
          initialZoomDomain: Re([], T),
          zoomDomain: T ? Re([], T) : v
        },
        { skipUpdate: !0 }
      ) : T === null && S !== null && this.model.set(
        {
          initialZoomDomain: null,
          zoomDomain: Re([], v)
        },
        { skipUpdate: !0 }
      ), this.xScale.range([c, l]).domain(v), this.maxSelectionRange = this.xScale.range(), this.yScale.range([0, r - 6]).domain(Qe(b, (O) => O.value));
      const w = this.model.get("zoomDomain");
      if (a === Le.GRAPH_VIEW && (this.renderZoomBarArea(p, "path.zoom-graph-area-unselected", b, null), this.updateClipPath(t, this.clipId, 0, 0, 0, 0), this.renderZoomBarArea(p, "path.zoom-graph-area", b, this.clipId), this.renderZoomBarBaseline(p, c, l), i)) {
        const O = i.highlightStartMapsTo, k = i.highlightEndMapsTo, I = i.color, F = i.labelMapsTo;
        i.data.forEach((P, A) => {
          E.appendOrSelect(p, `rect.highlight-${A}`).attr("height", r - 2 * this.highlightStrokeWidth).attr("y", this.highlightStrokeWidth).attr("x", this.xScale(P[O])).attr(
            "width",
            this.xScale(P[k]) - this.xScale(P[O])
          ).style(
            "fill",
            I && I.scale[P[F]] ? I.scale[P[F]] : null
          ).style("fill-opacity", 0.1).style(
            "stroke",
            I && I.scale[P[F]] ? I.scale[P[F]] : null
          ).style("stroke-dasharray", "2, 2").attr("stroke-width", "1px");
        });
      }
      this.addBrushEventListener(w, c, l);
      const L = E.appendOrSelect(t, this.brushSelector).call(this.brush);
      if (w !== void 0)
        if (w[0].valueOf() === w[1].valueOf())
          L.call(this.brush.move, this.xScale.range()), this.updateBrushHandle(this.getComponentContainer(), this.xScale.range());
        else {
          const O = w.map((k) => this.xScale(k));
          O[1] - O[0] < this.MIN_SELECTION_DIFF || (L.call(this.brush.move, O), this.updateBrushHandle(this.getComponentContainer(), O));
        }
      n && (this.brush.filter(() => !1), L.selectAll("rect").attr("cursor", "auto"));
    }
  }
  addBrushEventListener(e, t, s) {
    const n = (r) => {
      const l = r.selection;
      l === null ? this.handleBrushedEvent(r, e, this.xScale, this.xScale.range()) : l[0] === l[1] || this.handleBrushedEvent(r, e, this.xScale, l);
    }, a = y(this.getOptions(), "zoomBar", V.TOP, "type"), i = de.height[a];
    this.brush.extent([
      [t, 0],
      [s, i]
    ]).on("start brush end", null).on("start brush end", n);
  }
  // brush event listener
  handleBrushedEvent(e, t, s, n) {
    const a = [s.invert(n[0]), s.invert(n[1])];
    if (this.updateBrushHandle(this.getComponentContainer(), n), e.sourceEvent != null && (e.sourceEvent.type === "mousemove" || e.sourceEvent.type === "mouseup" || e.sourceEvent.type === "mousedown" || e.sourceEvent.type === "touchstart" || e.sourceEvent.type === "touchmove" || e.sourceEvent.type === "touchend")) {
      (t === void 0 || t[0] !== a[0] || t[1] !== a[1]) && this.services.zoom.handleDomainChange(a, {
        dispatchEvent: !1
      });
      let i;
      e.type === "start" ? i = f.ZoomBar.SELECTION_START : e.type === "brush" ? i = f.ZoomBar.SELECTION_IN_PROGRESS : e.type === "end" && (i = f.ZoomBar.SELECTION_END, this.services.events.dispatchEvent(f.ZoomDomain.CHANGE, {
        newDomain: a
      })), this.services.events.dispatchEvent(i, {
        selection: n,
        newDomain: a
      });
    }
  }
  updateBrushHandle(e, t) {
    const s = this, n = de.handleWidth, a = y(this.getOptions(), "zoomBar", V.TOP, "type"), i = de.height[a], r = -n / 2, l = de.handleBarWidth, c = a === Le.GRAPH_VIEW ? de.handleBarHeight : 6, d = -l / 2, p = (i - c) / 2;
    e.select(this.brushSelector).selectAll("rect.handle").data([{ type: "w" }, { type: "e" }]).attr("x", function(u) {
      if (u.type === "w")
        return Math.max(t[0] + r, s.maxSelectionRange[0]);
      if (u.type === "e")
        return Math.min(t[1] + r, s.maxSelectionRange[1] - n);
    }).attr("y", 0).attr("width", n).attr("height", i).attr("cursor", "ew-resize").style("display", null);
    const h = e.select(this.brushSelector).selectAll("rect.handle-bar").data([{ type: "w" }, { type: "e" }]);
    h.enter().append("rect").attr("class", function(u) {
      return "handle-bar handle-bar--" + u.type;
    }), h.attr("x", function(u) {
      if (u.type === "w")
        return Math.max(
          t[0] + d,
          s.maxSelectionRange[0] - r + d
        );
      if (u.type === "e")
        return Math.min(
          t[1] + d,
          s.maxSelectionRange[1] + r + d
        );
    }).attr("y", p).attr("width", l).attr("height", c).attr("cursor", "ew-resize"), a === Le.SLIDER_VIEW && this.updateSliderSelectedArea(t), this.updateClipPath(
      e,
      this.clipId,
      t[0],
      0,
      t[1] - t[0],
      i
    );
  }
  updateSliderSelectedArea(e) {
    const t = y(this.getOptions(), "zoomBar", V.TOP, "type"), s = de.height[t], a = this.getComponentContainer().select("svg.zoom-container");
    E.appendOrSelect(a, "rect.zoom-slider-selected-area").attr("x", e[0]).attr("y", s / 2 - 1).attr("width", e[1] - e[0]).attr("height", 2);
  }
  renderZoomBarArea(e, t, s, n) {
    const { cartesianScales: a } = this.services, i = a.getMainXAxisPosition(), r = a.getMainYAxisPosition(), l = a.getMainXScaleType(), c = a.getMainYScaleType(), d = (v, S, T) => (w) => a.getValueFromScale(v, S, T, w), p = d(this.xScale, l, i), h = d(this.yScale, c, r), u = y(this.getOptions(), "zoomBar", V.TOP, "type"), g = de.height[u], m = kt().x((v) => p(v)).y0(g).y1((v) => g - h(v)), b = E.appendOrSelect(e, t).datum(s).attr("d", m);
    n && b.attr("clip-path", `url(#${n})`);
  }
  updateClipPath(e, t, s, n, a, i) {
    const r = E.appendOrSelect(e, "clipPath").attr("id", t);
    E.appendOrSelect(r, "rect").attr("x", s).attr("y", n).attr("width", a).attr("height", i);
  }
  // assume the domains in data are already sorted
  compensateDataForDefaultDomain(e, t) {
    if (!e || e.length < 2)
      return;
    const s = Mn(e), n = this.services.cartesianScales.getDomainIdentifier(), a = this.services.cartesianScales.getRangeIdentifier();
    if (Number(t[0]) < Number(s[0][n])) {
      const i = {};
      i[n] = t[0], i[a] = 0, s.unshift(i);
    }
    if (Number(t[1]) > Number(s[s.length - 1][n])) {
      const i = {};
      i[n] = t[1], i[a] = 0, s.push(i);
    }
    return s;
  }
  renderZoomBarBaseline(e, t, s, n = !1) {
    const a = y(
      this.model.getOptions(),
      "zoomBar",
      V.TOP,
      "type"
    ), i = de.height[a], r = It()([
      [t, i],
      [s, i]
    ]);
    E.appendOrSelect(e, "path.zoom-bg-baseline").attr("d", r).classed("zoom-bg-baseline-skeleton", n).style(
      "stroke",
      n ? `url(#${this.services.domUtils.generateElementIDString("shimmer-lines")})` : null
    );
  }
  renderSkeleton(e, t, s) {
    this.renderZoomBarArea(e, "path.zoom-graph-area-unselected", [], null), this.renderZoomBarArea(e, "path.zoom-graph-area", [], this.clipId), this.brush.on("start brush end", null), E.appendOrSelect(this.getComponentContainer(), this.brushSelector).html(null), y(this.getOptions(), "zoomBar", V.TOP, "type") === Le.GRAPH_VIEW && this.renderZoomBarBaseline(e, t, s, !0);
  }
  destroy() {
    this.brush.on("start brush end", null), this.services.events.removeEventListener(f.ZoomBar.UPDATE, this.render.bind(this));
  }
}
class dc extends z {
  constructor(e, t) {
    super(e, t), this.type = "threshold", this.renderType = H.SVG, this.positionService = new et();
  }
  render(e = !1) {
    const t = y(this.getOptions(), "axes"), s = [];
    Object.keys(t).forEach((h) => {
      if (Object.values(V).includes(h)) {
        const u = t[h];
        u.thresholds && u.thresholds.length > 0 && s.push({
          axisPosition: h,
          thresholds: u.thresholds,
          correspondingDatasets: u == null ? void 0 : u.correspondingDatasets,
          mapsTo: u == null ? void 0 : u.mapsTo
        });
      }
    });
    const a = this.getComponentContainer({ withinChartClip: !0 }).selectAll("g.axis-thresholds").data(s, (h) => h.axisPosition);
    a.exit().attr("opacity", 0).remove();
    const r = a.enter().append("g").merge(a);
    r.attr("class", (h) => `axis-thresholds ${h.axisPosition}`);
    const l = r.selectAll("g.threshold-group").data(
      (h) => h.thresholds.map((u) => (u.axisPosition = h.axisPosition, u.datum = this.constructDatumObj(h, u), u))
    );
    l.exit().attr("opacity", 0).remove();
    const c = l.enter().append("g");
    c.append("line").attr("class", "threshold-line"), c.append("rect").attr("class", "threshold-hoverable-area"), c.merge(l).attr("class", "threshold-group");
    const p = this;
    r.each(function({ axisPosition: h }) {
      const u = p.services.cartesianScales.getScaleByPosition(
        h
      ), g = p.services.cartesianScales.getScaleTypeByPosition(h);
      let m = null, b = null;
      h === V.LEFT || h === V.RIGHT ? (b = u, m = p.services.cartesianScales.getMainXScale()) : (m = u, b = p.services.cartesianScales.getMainYScale());
      const v = g === te.LABELS, [S, T] = m.range(), [w, L] = b.range(), { cartesianScales: O } = p.services, k = O.getOrientation(), I = (G) => O.getDomainValue(G), F = (G) => O.getRangeValue(G), [P, A] = ve(
        I,
        F,
        k
      ), M = x(this);
      h === V.TOP || h === V.BOTTOM ? (M.selectAll("line.threshold-line").transition().call(
        (G) => p.services.transitions.setupTransition({
          transition: G,
          name: "threshold-line-update",
          animate: e
        })
      ).attr("y1", L).attr("y2", w).attr(
        "x1",
        ({ datum: G }) => P(G) + (v ? u.step() / 2 : 0)
      ).attr(
        "x2",
        ({ datum: G }) => P(G) + (v ? u.step() / 2 : 0)
      ).style("stroke", ({ fillColor: G }) => G), M.selectAll("rect.threshold-hoverable-area").attr("x", 0).attr("y", ({ datum: G }) => -P(G)).attr("width", Math.abs(w - L)).classed("rotate", !0)) : (M.selectAll("line.threshold-line").transition().call(
        (G) => p.services.transitions.setupTransition({
          transition: G,
          name: "threshold-line-update",
          animate: e
        })
      ).attr("x1", S).attr("x2", T).attr(
        "y1",
        ({ datum: G }) => A(G) + (v ? u.step() / 2 : 0)
      ).attr(
        "y2",
        ({ datum: G }) => A(G) + (v ? u.step() / 2 : 0)
      ).style("stroke", ({ fillColor: G }) => G), M.selectAll("rect.threshold-hoverable-area").attr("x", S).attr("y", ({ datum: G }) => A(G)).attr("width", Math.abs(T - S)).classed("rotate", !1));
    }), this.services.events.addEventListener(f.Threshold.SHOW, (h) => {
      this.setThresholdLabelPosition(h.detail), this.label.classed("hidden", !1);
    }), this.services.events.addEventListener(f.Threshold.HIDE, () => {
      this.label.classed("hidden", !0);
    }), this.appendThresholdLabel(), this.addEventListeners();
  }
  getFormattedValue(e) {
    const { value: t, axisPosition: s } = e, n = this.getOptions();
    if (this.services.cartesianScales.getScaleTypeByPosition(s) === te.TIME) {
      const i = [V.LEFT, V.RIGHT].includes(s), r = this.services.cartesianScales.getMainXScale(), l = this.services.cartesianScales.getMainYScale(), c = i ? l : r, d = y(n, "timeScale"), p = ut(
        c.ticks(),
        y(d, "timeInterval")
      );
      return pt(t, 0, c.ticks(), p, d);
    }
    return t.toLocaleString("en");
  }
  appendThresholdLabel() {
    const e = x(this.services.domUtils.getHolder()), t = y(this.getOptions(), "style", "prefix");
    this.label = E.appendOrSelect(
      e,
      `div.${he}--${t}--threshold--label`
    ).classed("hidden", !0);
  }
  setThresholdLabelPosition({ event: e, datum: t }) {
    const s = this.services.domUtils.getHolder(), n = Je(e, s), a = t.valueFormatter ? t.valueFormatter(t.value) : this.getFormattedValue(t);
    this.label.html(`${t.label || "Threshold"}: ${a}`).style("background-color", t.fillColor);
    const i = this.label.node(), r = this.positionService.findBestPlacementAt(
      {
        left: n[0],
        top: n[1]
      },
      i,
      [ne.RIGHT, ne.LEFT, ne.TOP, ne.BOTTOM],
      () => ({
        top: void 0,
        // other package lists this as non-optional
        left: void 0,
        // ditto
        width: s.offsetWidth,
        height: s.offsetHeight
      })
    ), l = this.positionService.findPositionAt(
      {
        left: n[0],
        top: n[1]
      },
      i,
      r
    );
    this.positionService.setElement(i, l);
  }
  // Constructs object to pass in scale functions
  constructDatumObj(e, t) {
    const s = {};
    return e.correspondingDatasets && (s.group = y(e, "correspondingDatasets", 0)), s[e.mapsTo] = t.value, s;
  }
  addEventListeners() {
    const e = this;
    this.getComponentContainer({ withinChartClip: !0 }).selectAll("rect.threshold-hoverable-area").on("mouseover mousemove", function(s) {
      x(this.parentNode).select("line.threshold-line").classed("active", !0), e.services.events.dispatchEvent(f.Threshold.SHOW, {
        event: s,
        hoveredElement: x(this),
        datum: x(this).datum()
      });
    }).on("mouseout", function(s) {
      x(this.parentNode).select("line.threshold-line").classed("active", !1), e.services.events.dispatchEvent(f.Threshold.HIDE, {
        event: s,
        hoveredElement: x(this),
        datum: x(this).datum()
      });
    });
  }
}
class hc extends z {
  constructor(e, t) {
    super(e, t), this.type = "highlight", this.renderType = H.SVG, this.positionService = new et(), this.highlightStrokeWidth = 1;
  }
  render(e = !1) {
    const t = y(this.getOptions(), "axes"), s = [];
    Object.keys(t).forEach((h) => {
      if (Object.values(V).includes(h)) {
        const u = t[h];
        u.highlights && u.highlights.data.length > 0 && s.push({
          axisPosition: h,
          highlightStartMapsTo: u.highlights.highlightStartMapsTo,
          highlightEndMapsTo: u.highlights.highlightEndMapsTo,
          labelMapsTo: u.highlights.labelMapsTo,
          highlight: u.highlights.data,
          color: u.highlights.color
        });
      }
    });
    const a = this.getComponentContainer({ withinChartClip: !0 }).selectAll("g.axis-highlight").data(s, (h) => h.axisPosition);
    a.exit().attr("opacity", 0).remove();
    const r = a.enter().append("g").merge(a);
    r.attr("class", (h) => `axis-highlight ${h.axisPosition}`);
    const l = r.selectAll("g.highlight-group").data(
      (h) => h.highlight.map((u) => (u.axisPosition = h.axisPosition, u.highlightStartMapsTo = h.highlightStartMapsTo, u.labelMapsTo = h.labelMapsTo, u.color = h.color, u.highlightEndMapsTo = h.highlightEndMapsTo, u))
    );
    l.exit().attr("opacity", 0).remove();
    const c = l.enter().append("g");
    c.append("rect").attr("class", "highlight-bar"), c.append("line").attr("class", "highlight-line"), c.merge(l).attr("class", "highlight-group");
    const p = this;
    r.each(function({ axisPosition: h }) {
      const u = p.services.cartesianScales.getMainXScale(), g = p.services.cartesianScales.getMainYScale(), [m, b] = u.range(), [v, S] = g.range(), { cartesianScales: T } = p.services, w = T.getOrientation(), L = (P) => T.getDomainValue(P), O = (P) => T.getRangeValue(P), [k, I] = ve(
        L,
        O,
        w
      ), F = x(this);
      h === V.TOP || h === V.BOTTOM ? F.selectAll("rect.highlight-bar").transition().call(
        (P) => p.services.transitions.setupTransition({
          transition: P,
          name: "highlight-bar-update",
          animate: e
        })
      ).attr("y", Math.max(S + p.highlightStrokeWidth, 0)).attr("height", Math.max(v - 2 * p.highlightStrokeWidth, 0)).attr("x", ({ highlightStartMapsTo: P, ...A }) => k(A[P])).attr(
        "width",
        ({ highlightStartMapsTo: P, highlightEndMapsTo: A, ...M }) => Math.max(k(M[A]) - k(M[P]), 0)
      ).style("stroke", ({ color: P, labelMapsTo: A, ...M }) => P && P.scale[M[A]] ? P.scale[M[A]] : null).style("stroke-dasharray", "2, 2").attr("stroke-width", p.highlightStrokeWidth + "px").style("fill-opacity", 0.1).style("fill", ({ color: P, labelMapsTo: A, ...M }) => P && P.scale[M[A]] ? P.scale[M[A]] : null) : F.selectAll("rect.highlight-bar").transition().call(
        (P) => p.services.transitions.setupTransition({
          transition: P,
          name: "highlight-bar-update",
          animate: e
        })
      ).attr("x", m).attr("width", Math.max(b - m, 0)).attr("y", ({ highlightEndMapsTo: P, ...A }) => I(A[P])).attr(
        "height",
        ({ highlightStartMapsTo: P, highlightEndMapsTo: A, ...M }) => Math.max(I(M[P]) - I(M[A]), 0)
      ).style("stroke", ({ color: P, labelMapsTo: A, ...M }) => P && P.scale[M[A]] ? P.scale[M[A]] : null).style("stroke-dasharray", "2, 2").attr("stroke-width", p.highlightStrokeWidth + "px").style("fill-opacity", 0.1).style("fill", ({ color: P, labelMapsTo: A, ...M }) => P && P.scale[M[A]] ? P.scale[M[A]] : null);
    });
  }
}
class uc extends ir {
  getItems(e) {
    if (e.detail.items)
      return e.detail.items;
    const { data: t } = e.detail;
    if (!t || !t.length || !t[0])
      return [];
    const s = this.getOptions(), { cartesianScales: n } = this.services, a = n.getDomainIdentifier(), i = n.isDualAxes(), { groupMapsTo: r } = s.data, l = n.getDomainLabel();
    let c = n.getRangeLabel();
    const d = t[0][a];
    let p;
    if (t.length === 1) {
      const h = t[0], u = n.getRangeIdentifier(h);
      if (i) {
        const m = n.getRangeAxisPosition({
          datum: h,
          groups: [h[r]]
        });
        c = n.getScaleLabel(m);
      }
      const g = h[u];
      p = [
        {
          label: l,
          value: d
        },
        ...Array.isArray(g) && g.length === 2 ? [
          {
            label: "Start",
            value: g[0]
          },
          {
            label: "End",
            value: g[1]
          }
        ] : [
          {
            label: c,
            value: h[u]
          }
        ]
      ], e.detail.additionalItems && e.detail.additionalItems.forEach(
        (m) => p.push({
          label: m.label,
          value: m.value
        })
      ), p.push({
        label: s.tooltip.groupLabel,
        value: h[r],
        color: this.model.getFillColor(h[r]),
        class: this.model.getColorClassName({
          classNameTypes: [$.TOOLTIP],
          dataGroupName: h[r]
        })
      });
    } else if (t.length > 1 && (p = [
      {
        label: l,
        value: d
      }
    ], p = p.concat(
      t.map((h) => {
        const u = h[n.getRangeIdentifier(h)];
        return {
          label: h[r],
          value: Array.isArray(u) && u.length === 2 ? `${u[0]} - ${u[1]}` : u,
          color: this.model.getFillColor(h[r]),
          class: this.model.getColorClassName({
            classNameTypes: [$.TOOLTIP],
            dataGroupName: h[r]
          })
        };
      }).sort((h, u) => u.value - h.value)
    ), !i && y(s, "tooltip", "showTotal") === !0)) {
      const h = n.getRangeIdentifier();
      p.push({
        label: Q(s, "tooltip.totalLabel") || "Total",
        value: t.reduce(
          (u, g) => u + g[h],
          0
        ),
        bold: !0
      });
    }
    return p;
  }
}
class pc extends z {
  constructor() {
    super(...arguments), this.type = "alluvial", this.renderType = H.SVG, this.gradient_id = "gradient-id-" + Math.floor(Math.random() * 99999999999);
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(e = !0) {
    const t = this.getComponentContainer({ withinChartClip: !0 });
    t.html("");
    const { width: s, height: n } = E.getSVGElementSize(t, {
      useAttrs: !0
    });
    if (s < 1 || n < 1)
      return;
    const a = this.model.getOptions(), i = this.model.getDisplayData(), r = y(
      this.getOptions(),
      "color",
      "gradient",
      "enabled"
    );
    let l = pe.minNodePadding;
    a.alluvial.nodePadding > pe.minNodePadding && (l = a.alluvial.nodePadding);
    const c = y(a, "alluvial", "nodeAlignment");
    let d = Nn;
    c === ue.LEFT ? d = Hn : c === ue.RIGHT && (d = Un);
    const p = $n().nodeId((v) => v.name).nodeWidth(pe.nodeWidth).nodePadding(l).nodeAlign(d).extent([
      [2, 30],
      [s - 2, n]
    ]);
    this.graph = p({
      nodes: a.alluvial.nodes.map((v) => Object.assign({}, v)),
      links: i.map((v) => Object.assign({}, v))
    }), this.graph.nodes = this.graph.nodes.filter((v) => v.value !== 0);
    const h = {};
    this.graph.nodes.forEach((v) => {
      const S = v.x0;
      v.category && (h[S] = v == null ? void 0 : v.category);
    }), t.append("g").classed("header-arrows", !0).selectAll("g").data(Object.keys(h)).join("g").attr("transform", (v) => `translate(${v}, 0)`).append("text").attr(
      "id",
      (v, S) => this.services.domUtils.generateElementIDString(`alluvial-category-${S}`)
    ).style("font-size", "14px").text((v) => h[v] ? h[v] : "").attr("y", 20).attr("x", (v, S) => {
      const T = this.services.domUtils.generateElementIDString(
        `alluvial-category-${S}`
      ), { width: w } = E.getSVGElementSize(x(`text#${T}`), { useBBox: !0 });
      let L = 0;
      return v + L >= w && (L = -w + 4), L;
    });
    const g = t.append("g").attr("fill", "none").selectAll("g").data(this.graph.links);
    if (g.exit().remove(), r) {
      const v = y(this.getOptions(), "color", "scale");
      v && g.enter().append("linearGradient").attr("id", (S) => `${this.gradient_id}-link-${S.index}`).attr("gradientUnits", "userSpaceOnUse").call(
        (S) => S.append("stop").attr("offset", "0%").attr("stop-color", (T) => v[T.source.name])
      ).call(
        (S) => S.append("stop").attr("offset", "100%").attr("stop-color", (T) => v[T.target.name])
      ), g.exit().remove();
    }
    g.enter().append("path").classed("link", !0).attr("d", Gn()).attr(
      "id",
      (v) => this.services.domUtils.generateElementIDString(`alluvial-line-${v.index}`)
    ).attr("class", (v) => a.alluvial.monochrome ? this.model.getColorClassName({
      classNameTypes: [$.STROKE],
      dataGroupName: 0,
      originalClassName: "link"
    }) : this.model.getColorClassName({
      classNameTypes: [$.STROKE],
      dataGroupName: v.source.index,
      originalClassName: "link"
    })).style("stroke", (v) => r ? `url(#${this.gradient_id}-link-${v.index})` : this.model.getFillColor(v.source.name)).attr("stroke-width", (v) => Math.max(1, v.width)).style("stroke-opacity", pe.opacity.default).attr(
      "aria-label",
      (v) => `${v.source.name} → ${v.target.name} (${v.value}${a.alluvial.units ? " " + a.alluvial.units : ""})`
    );
    const m = t.append("g").selectAll("g").data(this.graph.nodes).enter().append("g").attr(
      "id",
      (v) => this.services.domUtils.generateElementIDString(`alluvial-node-${v.index}`)
    ).classed("node-group", !0).attr("transform", (v) => `translate(${v.x0}, ${v.y0})`);
    m.append("rect").classed("node", !0).attr("height", (v) => v.y1 - v.y0).attr("width", (v) => v.x1 - v.x0).attr("fill", "black");
    const b = m.append("g").attr(
      "id",
      (v) => this.services.domUtils.generateElementIDString(`alluvial-node-title-${v.index}`)
    );
    b.append("text").attr(
      "id",
      (v) => this.services.domUtils.generateElementIDString(`alluvial-node-text-${v.index}`)
    ).attr("class", "node-text").style("font-size", "12px").attr("text-anchor", "start").attr("fill", "white").attr("x", 4).attr("dy", 13).text((v) => `${v.name} (${v.value})`).attr("aria-label", (v) => `${v.name} (${v.value})`), b.append("rect").classed("node-text-bg", !0).attr("width", (v, S) => {
      const T = this.services.domUtils.generateElementIDString(
        `alluvial-node-text-${S}`
      ), { width: w } = E.getSVGElementSize(x(`text#${T}`), { useBBox: !0 });
      return w + 8;
    }).attr("height", 18).attr("stroke-width", 2).lower(), b.attr("transform", (v, S) => {
      const T = this.services.domUtils.generateElementIDString(
        `alluvial-node-text-${S}`
      ), { width: w } = E.getSVGElementSize(x(`text#${T}`), { useBBox: !0 }), L = (v.y1 - v.y0) / 2 - 9;
      let O = v.x1 - v.x0;
      return v.x1 >= w ? O = O - (w + 16) : O += 4, `translate(${O}, ${L})`;
    }), this.addLineEventListener(), this.addNodeEventListener();
  }
  addLineEventListener() {
    const e = this.getOptions(), t = this, s = gt((n, a = "mouseover") => {
      const i = t.parent.selectAll("path.link").transition().call(
        (r) => t.services.transitions.setupTransition({
          transition: r,
          name: "alluvial-links-mouse-highlight"
        })
      );
      a === "mouseout" ? (x(n).lower(), i.style("stroke-opacity", pe.opacity.default)) : i.style("stroke-opacity", function() {
        return n === this ? (x(this).raise(), pe.opacity.selected) : pe.opacity.unfocus;
      });
    }, 33);
    this.parent.selectAll("path.link").on("mouseover", function(n, a) {
      const i = x(this);
      s(this, "mouseover"), i.classed("link-hovered", !0);
      const r = getComputedStyle(this).getPropertyValue("stroke");
      t.services.events.dispatchEvent(f.Alluvial.LINE_MOUSEOVER, {
        event: n,
        element: i,
        datum: a
      }), t.services.events.dispatchEvent(f.Tooltip.SHOW, {
        event: n,
        hoveredElement: i,
        items: [
          {
            label: a.target.name,
            value: a.value + (e.alluvial.units ? ` ${e.alluvial.units}` : ""),
            color: r,
            labelIcon: t.getRightArrowIcon()
          }
        ]
      });
    }).on("mousemove", function(n, a) {
      t.services.events.dispatchEvent(f.Alluvial.LINE_MOUSEMOVE, {
        event: n,
        element: x(this),
        datum: a
      }), t.services.events.dispatchEvent(f.Tooltip.MOVE, {
        event: n
      });
    }).on("click", function(n, a) {
      t.services.events.dispatchEvent(f.Alluvial.LINE_CLICK, {
        event: n,
        element: x(this),
        datum: a
      });
    }).on("mouseout", function(n, a) {
      const i = x(this);
      s(this, "mouseout"), i.classed("link-hovered", !1), t.services.events.dispatchEvent(f.Alluvial.LINE_MOUSEOUT, {
        event: n,
        element: i,
        datum: a
      }), t.services.events.dispatchEvent(f.Tooltip.HIDE, {
        event: n,
        hoveredElement: i
      });
    });
  }
  addNodeEventListener() {
    const e = this, t = gt((s = [], n = "mouseover") => {
      if (n === "mouseout" || s.length === 0) {
        e.parent.selectAll("path.link").classed("link-hovered", !1).data(this.graph.links, (i) => i.index).order().style("stroke-opacity", pe.opacity.default);
        return;
      }
      e.parent.selectAll("path.link").transition().call(
        (i) => this.services.transitions.setupTransition({
          transition: i,
          name: "alluvial-link-mouse-highlight"
        })
      ).style("stroke-opacity", function(i) {
        return s.some((r) => r === i.index) ? (x(this).classed("link-hovered", !0).raise(), pe.opacity.selected) : pe.opacity.unfocus;
      });
    }, 66);
    e.parent.selectAll(".node-group").on("mouseover", function(s, n) {
      const a = x(this), i = [];
      if (e.traverse({ link: "sourceLinks", node: "target" }, n, i), e.traverse({ link: "targetLinks", node: "source" }, n, i), i.length) {
        const r = Ve(a.attr("transform"));
        if (a.attr("transform", `translate(${r.x - 2}, ${r.y})`), a.classed("node-hovered", !0).selectAll("rect.node").attr("width", 8), n.x0 - 2 === 0) {
          const c = e.services.domUtils.generateElementIDString(
            `alluvial-node-title-${n.index}`
          ), d = e.parent.select(`g#${c}`), p = Ve(d.attr("transform"));
          d.attr("transform", `translate(${p.x + 4},${p.y})`);
        }
        const l = e.services.domUtils.generateElementIDString(
          `alluvial-node-text-${n.index}`
        );
        e.parent.select(`text#${l}`).style("font-weight", "bold"), t(i, "mouseover"), e.services.events.dispatchEvent(f.Alluvial.NODE_MOUSEOVER, {
          event: s,
          element: a,
          datum: n
        });
      }
    }).on("mousemove", function(s, n) {
      e.services.events.dispatchEvent(f.Alluvial.NODE_MOUSEMOVE, {
        event: s,
        element: x(this),
        datum: n
      }), e.services.events.dispatchEvent(f.Tooltip.MOVE, {
        event: s
      });
    }).on("click", function(s, n) {
      e.services.events.dispatchEvent(f.Alluvial.NODE_CLICK, {
        event: s,
        element: x(this),
        datum: n
      });
    }).on("mouseout", function(s, n) {
      const a = x(this), i = Ve(a.attr("transform"));
      if (a.classed("node-hovered", !1).attr("transform", `translate(${i.x + 2}, ${i.y})`).select("rect.node").attr("width", pe.nodeWidth), n.x0 - 2 === 0) {
        const l = e.services.domUtils.generateElementIDString(
          `alluvial-node-title-${n.index}`
        ), c = e.parent.select(`g#${l}`), d = Ve(c.attr("transform"));
        c.attr("transform", `translate(${d.x - 4},${d.y})`);
      }
      const r = e.services.domUtils.generateElementIDString(
        `alluvial-node-text-${n.index}`
      );
      e.parent.select(`text#${r}`).style("font-weight", "normal"), t([], "mouseout"), e.services.events.dispatchEvent(f.Alluvial.NODE_MOUSEOUT, {
        event: s,
        element: a,
        datum: n
      }), e.services.events.dispatchEvent(f.Tooltip.HIDE, {
        hoveredElement: a
      });
    });
  }
  // Traverse graph and get all connected links to node
  traverse(e, t, s = []) {
    t[e.link].map((a) => (s.push(a.index), a[e.node])).forEach((a) => this.traverse(e, a, s));
  }
  getRightArrowIcon() {
    return `
		<svg xmlns="http://www.w3.org/2000/svg" class="arrow-right" width="32" height="32" viewBox="0 0 32 32">
			<polygon points="18 6 16.57 7.393 24.15 15 4 15 4 17 24.15 17 16.57 24.573 18 26 28 16 18 6"/>
			<rect width="32" height="32"/>
		</svg>`;
  }
  // Remove event listeners
  destroy() {
    this.parent.selectAll("path.line,.node-group").on("mouseover", null).on("mousemove", null).on("click", null).on("mouseout", null);
  }
}
class gc extends z {
  constructor() {
    super(...arguments), this.type = "grid", this.renderType = H.SVG;
  }
  render(e = !0) {
    const t = y(this.getOptions(), "grid", "x", "enabled"), s = y(this.getOptions(), "grid", "y", "enabled");
    this.drawBackdrop(t, s), !(!t && !s) && (t && (E.appendOrSelect(this.backdrop, "g.x.grid"), this.drawXGrid(e)), s && (E.appendOrSelect(this.backdrop, "g.y.grid"), this.drawYGrid(e)));
  }
  drawXGrid(e) {
    const t = this.parent, s = this.backdrop.attr("height"), n = this.services.cartesianScales.getMainXScale(), a = Rt(n).tickSizeInner(-s).tickSizeOuter(0);
    if (y(this.getOptions(), "grid", "x", "alignWithAxisTicks")) {
      const l = this.services.cartesianScales.getDomainAxisPosition(), c = y(this.getOptions(), "axes", l, "ticks", "values");
      c && a.tickValues(c);
    } else {
      const l = y(this.getOptions(), "grid", "x", "numberOfTicks");
      a.ticks(l);
    }
    const r = t.select(".x.grid").attr("transform", `translate(${-this.backdrop.attr("x")}, ${s})`);
    e ? r.transition().call(
      (l) => this.services.transitions.setupTransition({
        transition: l,
        name: "grid-update",
        animate: e
      })
    ).call(a) : r.call(a), this.cleanGrid(r);
  }
  drawYGrid(e) {
    const t = this.parent, s = this.backdrop.attr("width"), n = this.services.cartesianScales.getMainYScale(), a = fs(n).tickSizeInner(-s).tickSizeOuter(0);
    if (y(this.getOptions(), "grid", "y", "alignWithAxisTicks")) {
      const l = this.services.cartesianScales.getRangeAxisPosition(), c = y(this.getOptions(), "axes", l, "ticks", "values");
      c && a.tickValues(c);
    } else {
      const l = y(this.getOptions(), "grid", "y", "numberOfTicks");
      a.ticks(l);
    }
    const r = t.select(".y.grid").attr("transform", `translate(0, ${-this.backdrop.attr("y")})`);
    e ? r.transition().call(
      (l) => this.services.transitions.setupTransition({
        transition: l,
        name: "grid-update",
        animate: e
      })
    ).call(a) : r.call(a), this.cleanGrid(r);
  }
  /**
   * Returns the threshold for the gridline tooltips based on the mouse location.
   * Calculated based on the mouse position between the two closest gridlines or edges of chart.
   */
  getGridlineThreshold(e) {
    const t = this.parent, s = t.selectAll(".x.grid .tick").nodes().sort((d, p) => Number(ge(d).tx) - Number(ge(p).tx));
    let n = -1;
    if (!s.length)
      return;
    s.forEach((d) => {
      e[0] >= +ge(d).tx && n++;
    });
    const a = n + 1 < s.length ? n + 1 : s.length, i = s[n], r = s[a];
    let l;
    if (!i)
      l = +ge(r).tx;
    else if (r)
      l = +ge(r).tx - +ge(i).tx;
    else {
      const d = t.select("rect.chart-grid-backdrop").node();
      l = E.getSVGElementSize(d).width - +ge(i).tx;
    }
    const { threshold: c } = this.getOptions().tooltip.gridline;
    return l * c;
  }
  /**
   * Returns the active gridlines based on the gridline threshold and mouse position.
   * @param position mouse positon
   */
  getActiveGridline(e) {
    const t = y(this.getOptions, "tooltip", "gridline", "threshold"), s = t || this.getGridlineThreshold(e);
    return this.parent.selectAll(".x.grid .tick").filter(function() {
      const i = ge(this), r = {
        min: Number(i.tx) - s,
        max: Number(i.tx) + s
      };
      return r.min <= e[0] && e[0] <= r.max;
    });
  }
  drawBackdrop(e, t) {
    const s = this.parent, n = this.services.cartesianScales.getMainXScale(), a = this.services.cartesianScales.getMainYScale(), [i, r] = n.range(), [l, c] = a.range();
    this.backdrop = E.appendOrSelect(s, "svg.chart-grid-backdrop");
    const d = E.appendOrSelect(
      this.backdrop,
      e || t ? "rect.chart-grid-backdrop.stroked" : "rect.chart-grid-backdrop"
    );
    this.backdrop.merge(d).attr("x", i).attr("y", c).attr("width", Math.abs(r - i)).attr("height", Math.abs(l - c)).lower(), d.attr("width", "100%").attr("height", "100%");
  }
  cleanGrid(e) {
    e.selectAll("text").remove(), e.select(".domain").remove();
  }
}
class mc extends z {
  constructor() {
    super(...arguments), this.type = "area", this.renderType = H.SVG, this.gradient_id = "gradient-id-" + Math.floor(Math.random() * 99999999999), this.handleLegendOnHover = (e) => {
      const { hoveredElement: t } = e.detail;
      this.parent.selectAll("path.area").transition("legend-hover-area").call(
        (s) => this.services.transitions.setupTransition({
          transition: s,
          name: "legend-hover-area"
        })
      ).attr("opacity", (s) => s.name !== t.datum().name ? fe.opacity.unselected : fe.opacity.selected);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("path.area").transition("legend-mouseout-area").call(
        (e) => this.services.transitions.setupTransition({
          transition: e,
          name: "legend-mouseout-area"
        })
      ).attr("opacity", fe.opacity.selected);
    };
  }
  init() {
    const e = this.services.events;
    e.addEventListener(f.Legend.ITEM_HOVER, this.handleLegendOnHover), e.addEventListener(f.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(e = !0) {
    const t = this.getComponentContainer({ withinChartClip: !0 }), s = this.getOptions();
    let n = [0, 0];
    const { cartesianScales: a } = this.services, i = a.getOrientation(), r = kt().curve(this.services.curves.getD3Curve()).defined((L) => {
      const O = a.getRangeIdentifier(), k = L[O];
      return k != null;
    }), l = this.model.getGroupedData(this.configs.groups), c = y(s, "bounds"), d = c && l && l.length === 1;
    !d && c && console.warn(
      `Bounds can only be shown when having 1 single datagroup, you've supplied ${l.length}`
    );
    let p = 0;
    const h = (L, O) => {
      y(s, "axes", L, "includeZero") === !1 && O[0] > 0 && O[1] > 0 && (p = O[0]);
    }, u = (L) => d ? a.getBoundedScaledValues(L)[0] : a.getRangeValue(p), g = (L) => d ? a.getBoundedScaledValues(L)[1] : a.getRangeValue(L);
    i === le.VERTICAL ? (n = a.getMainYScale().domain(), h(a.getMainYAxisPosition(), n), r.x((L) => a.getDomainValue(L)).y0((L) => u(L)).y1((L) => g(L))) : (n = a.getMainXScale().domain(), h(a.getMainXAxisPosition(), n), r.x0((L) => u(L)).x1((L) => g(L)).y((L) => a.getDomainValue(L)));
    const m = y(s, "color", "gradient", "enabled"), b = l && l.length === 1 && m;
    l.length > 1 && m && console.error("Gradients can only be enabled when having 1 single dataset");
    const v = t.selectAll("path.area").data(l, (L) => L.name), S = x(this.services.domUtils.getMainContainer());
    if (v.exit().attr("opacity", 0).remove(), !l.length)
      return;
    if (b) {
      const L = S.select(
        `path.${this.model.getColorClassName({
          classNameTypes: [$.STROKE],
          dataGroupName: l[0].name
        })}`
      ).node();
      let O;
      if (L)
        O = getComputedStyle(L, null).getPropertyValue(
          "stroke"
        );
      else {
        const k = y(this.model.getOptions(), "color", "scale");
        if (k !== null) {
          const I = Object.keys(k);
          O = k[I[0]];
        }
      }
      Zt.appendOrUpdateLinearGradient({
        svg: this.parent,
        id: this.services.domUtils.generateElementIDString(
          `${l[0].name.replace(" ", "")}_${this.gradient_id}`
        ),
        x1: "0%",
        x2: "0%",
        y1: "0%",
        y2: "100%",
        stops: Zt.getStops(n, O)
      });
    } else
      this.parent.selectAll("defs linearGradient").empty() || this.parent.selectAll("defs linearGradient").each(function() {
        this.parentNode.remove();
      });
    const T = this, w = v.enter().append("path");
    b ? w.merge(v).style(
      "fill",
      (L) => `url(#${this.services.domUtils.generateElementIDString(
        `${L.name.replace(" ", "")}_${this.gradient_id}`
      )})`
    ).attr("class", "area").attr(
      "class",
      (L) => this.model.getColorClassName({
        classNameTypes: [$.FILL],
        dataGroupName: L.name,
        originalClassName: "area"
      })
    ).attr("d", (L) => {
      const { data: O } = L;
      return r(O);
    }) : (w.attr("opacity", 0).merge(v).attr("class", "area").attr(
      "class",
      (L) => this.model.getColorClassName({
        classNameTypes: [$.FILL, $.STROKE],
        dataGroupName: L.name,
        originalClassName: "area"
      })
    ).style("fill", (L) => T.model.getFillColor(L.name)).transition().call(
      (L) => this.services.transitions.setupTransition({
        transition: L,
        name: "area-update-enter",
        animate: e
      })
    ).attr("opacity", d ? 1 : fe.opacity.selected).attr("d", (L) => {
      const { data: O } = L;
      return r(O);
    }), d && w.attr("fill-opacity", fe.opacity.selected).style("stroke", (L) => T.model.getStrokeColor(L.name)).style("stroke-dasharray", "2, 2").attr("stroke-width", 0.7 + "px"));
  }
  destroy() {
    const e = this.services.events;
    e.removeEventListener(f.Legend.ITEM_HOVER, this.handleLegendOnHover), e.removeEventListener(f.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
}
class fc extends z {
  constructor() {
    super(...arguments), this.type = "line", this.renderType = H.SVG, this.handleLegendOnHover = (e) => {
      const { hoveredElement: t } = e.detail;
      this.parent.selectAll("path.line").transition("legend-hover-line").call(
        (s) => this.services.transitions.setupTransition({
          transition: s,
          name: "legend-hover-line"
        })
      ).attr("opacity", (s) => s.name !== t.datum().name ? me.opacity.unselected : me.opacity.selected);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("path.line").transition("legend-mouseout-line").call(
        (e) => this.services.transitions.setupTransition({
          transition: e,
          name: "legend-mouseout-line"
        })
      ).attr("opacity", me.opacity.selected);
    };
  }
  init() {
    const { events: e } = this.services;
    e.addEventListener(f.Legend.ITEM_HOVER, this.handleLegendOnHover), e.addEventListener(f.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(e = !0) {
    const t = this.getComponentContainer({ withinChartClip: !0 }), { cartesianScales: s, curves: n } = this.services, a = (g) => s.getDomainValue(g), i = (g) => s.getRangeValue(g), [r, l] = ve(
      a,
      i,
      s.getOrientation()
    ), c = this.getOptions(), d = It().x(r).y(l).curve(n.getD3Curve()).defined((g) => {
      const m = s.getRangeIdentifier(g), b = g[m];
      return b != null;
    });
    let p = [];
    if (this.configs.stacked) {
      const g = Object.keys(c.axes).some((v) => c.axes[v].percentage), { groupMapsTo: m } = c.data;
      p = this.model.getStackedData({
        groups: this.configs.groups,
        percentage: g
      }).map((v) => {
        const S = this.services.cartesianScales.getDomainIdentifier(v), T = this.services.cartesianScales.getRangeIdentifier(v);
        return {
          name: y(v, 0, m),
          data: v.map((w) => ({
            [S]: w.data.sharedStackKey,
            [m]: w[m],
            [T]: w[1]
          })),
          hidden: !Ha(v, (w) => w[0] !== w[1])
        };
      });
    } else
      p = this.model.getGroupedData(this.configs.groups);
    const h = t.selectAll("path.line").data(p, (g) => g.name);
    h.exit().attr("opacity", 0).remove(), h.enter().append("path").classed("line", !0).attr("opacity", 0).merge(h).data(p, (g) => g.name).attr(
      "class",
      (g) => this.model.getColorClassName({
        classNameTypes: [$.STROKE],
        dataGroupName: g.name,
        originalClassName: "line"
      })
    ).style("stroke", (g) => this.model.getStrokeColor(g.name)).attr("role", U.GRAPHICS_SYMBOL).attr("aria-roledescription", "line").attr("aria-label", (g) => {
      const { data: m } = g;
      return m.map((b) => {
        const v = this.services.cartesianScales.getRangeIdentifier(b);
        return b[v];
      }).join(",");
    }).transition().call(
      (g) => this.services.transitions.setupTransition({
        transition: g,
        name: "line-update-enter",
        animate: e
      })
    ).attr("opacity", (g) => g.hidden ? 0 : 1).attr("d", (g) => {
      const { data: m } = g;
      return d(m);
    });
  }
  destroy() {
    const e = this.services.events;
    e.removeEventListener(f.Legend.ITEM_HOVER, this.handleLegendOnHover), e.removeEventListener(f.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
}
const cs = 5;
function rr(o, e) {
  return o > e - cs && o < e + cs;
}
class Xs extends z {
  constructor() {
    super(...arguments), this.type = "ruler", this.renderType = H.SVG, this.isXGridEnabled = y(this.getOptions(), "grid", "x", "enabled"), this.isYGridEnabled = y(this.getOptions(), "grid", "y", "enabled"), this.isEventListenerAdded = !1;
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(e = !1) {
    const t = y(this.getOptions(), "ruler", "enabled");
    this.drawBackdrop(), t && !this.isEventListenerAdded ? this.addBackdropEventListeners() : !t && this.isEventListenerAdded && this.removeBackdropEventListeners();
  }
  removeBackdropEventListeners() {
    this.isEventListenerAdded = !1, this.backdrop.on("mousemove mouseover mouseout", null);
  }
  formatTooltipData(e) {
    return e;
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  showRuler(e, [t, s]) {
    const n = this.parent, a = this.services.cartesianScales.getOrientation(), i = this.model.getDisplayData(), r = this.services.cartesianScales.getRangeScale(), [l, c] = r.range(), d = a === le.HORIZONTAL ? s : t, p = E.appendOrSelect(n, "g.ruler").attr("aria-label", "ruler"), h = E.appendOrSelect(p, "line.ruler-line"), u = n.selectAll("[role=graphics-symbol]"), g = i.map((b) => ({
      domainValue: this.services.cartesianScales.getDomainValue(b),
      originalData: b
    })).filter((b) => rr(b.domainValue, d));
    if (this.pointsWithinLine && g.length === this.pointsWithinLine.length && g.map((b) => b.domainValue).join() === this.pointsWithinLine.map((b) => b.domainValue).join())
      return this.pointsWithinLine = g, this.services.events.dispatchEvent(f.Tooltip.MOVE, {
        mousePosition: [t, s]
      });
    this.pointsWithinLine = g;
    const m = this.pointsWithinLine.reduce((b, v) => {
      if (b.length === 0)
        return b.push(v), b;
      const S = b[0].domainValue, T = Math.abs(d - v.domainValue), w = Math.abs(d - S);
      return T > w || (T < w ? b = [v] : b.push(v)), b;
    }, []);
    if (m.length > 0) {
      const b = m.map((w) => w.originalData).filter((w) => {
        const L = this.services.cartesianScales.getRangeIdentifier(w), O = w[L];
        return O != null;
      }), v = m.map(
        (w) => w.domainValue
      ), S = u.filter((w) => {
        const L = this.services.cartesianScales.getDomainValue(w);
        return v.includes(L);
      });
      this.elementsToHighlight && this.elementsToHighlight.size() > 0 && !Gs(this.elementsToHighlight, S) && this.hideRuler(), S.dispatch("mouseover"), this.elementsToHighlight = S, this.services.events.dispatchEvent(f.Tooltip.SHOW, {
        mousePosition: [t, s],
        hoveredElement: h,
        data: this.formatTooltipData(b)
      }), p.attr("opacity", 1);
      const T = m[0];
      a === "horizontal" ? h.attr("x1", c).attr("x2", l).attr("y1", T.domainValue).attr("y2", T.domainValue) : h.attr("y1", c).attr("y2", l).attr("x1", T.domainValue).attr("x2", T.domainValue);
    } else
      this.hideRuler();
  }
  hideRuler() {
    const e = this.parent, t = E.appendOrSelect(e, "g.ruler");
    e.selectAll("[role=graphics-symbol]").dispatch("mouseout"), this.services.events.dispatchEvent(f.Tooltip.HIDE), t.attr("opacity", 0);
  }
  /**
   * Adds the listener on the X grid to trigger multiple point tooltips along the x axis.
   */
  addBackdropEventListeners() {
    this.isEventListenerAdded = !0;
    const e = this, t = this.services.domUtils.getHolder(), s = this.model.getDisplayData();
    let n = function(a) {
      const i = Je(a, e.parent.node());
      e.showRuler(a, i);
    };
    if (s.length > 100) {
      const a = s.length % 50 * 12.5;
      n = An(
        function(i) {
          const { mousePosition: r } = this;
          e.showRuler(i, r);
        },
        a,
        t
      );
    }
    this.backdrop.on("mousemove mouseover", n).on("mouseout", this.hideRuler.bind(this));
  }
  drawBackdrop() {
    const e = this.parent;
    this.backdrop = E.appendOrSelect(e, "svg.chart-grid-backdrop");
  }
}
class Vt extends z {
  constructor() {
    super(...arguments), this.type = "scatter", this.renderType = H.SVG, this.handleChartHolderOnHover = () => {
      if (!this.parent)
        throw new Error("Parent not defined");
      this.parent.selectAll("circle.dot").transition("chart-holder-hover-scatter").call(
        (e) => {
          var t;
          return (t = this.services.transitions) == null ? void 0 : t.setupTransition({
            transition: e,
            name: "chart-holder-hover-scatter"
          });
        }
      ).attr("opacity", 1);
    }, this.handleChartHolderOnMouseOut = () => {
      if (!this.parent)
        throw new Error("Parent not defined");
      this.parent.selectAll("circle.dot").transition("chart-holder-mouseout-scatter").call(
        (e) => {
          var t;
          return (t = this.services.transitions) == null ? void 0 : t.setupTransition({
            transition: e,
            name: "chart-holder-mouseout-scatter"
          });
        }
      ).attr("opacity", 0);
    }, this.handleLegendOnHover = (e) => {
      const { hoveredElement: t } = e.detail, { groupMapsTo: s } = this.getOptions().data;
      if (!this.parent)
        throw new Error("Parent not defined");
      this.parent.selectAll("circle.dot").transition("legend-hover-scatter").call(
        (n) => {
          var a;
          return (a = this.services.transitions) == null ? void 0 : a.setupTransition({
            transition: n,
            name: "legend-hover-scatter"
          });
        }
      ).attr("opacity", (n) => n[s] !== t.datum().name ? 0.3 : 1);
    }, this.handleLegendMouseOut = () => {
      if (!this.parent)
        throw new Error("Parent not defined");
      this.parent.selectAll("circle.dot").transition("legend-mouseout-scatter").call(
        (e) => {
          var t;
          return (t = this.services.transitions) == null ? void 0 : t.setupTransition({
            transition: e,
            name: "legend-mouseout-scatter"
          });
        }
      ).attr("opacity", 1);
    };
  }
  init() {
    const { events: e } = this.services;
    if (!e)
      throw new Error("Services events are undefined.");
    e.addEventListener(f.Legend.ITEM_HOVER, this.handleLegendOnHover), e.addEventListener(f.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
    const { fadeInOnChartHolderMouseover: t } = this.configs;
    t && (e.addEventListener(f.Chart.MOUSEOVER, this.handleChartHolderOnHover), e.addEventListener(f.Chart.MOUSEOUT, this.handleChartHolderOnMouseOut));
  }
  filterBasedOnZoomDomain(e) {
    const { cartesianScales: t } = this.services;
    if (!t)
      throw new Error("Services cartesianScales are undefined.");
    const s = t.getDomainIdentifier(e), n = this.model.get("zoomDomain");
    return n !== void 0 ? e.filter(
      (a) => a[s].getTime() >= n[0].getTime() && a[s].getTime() <= n[1].getTime()
    ) : e;
  }
  getScatterData() {
    const e = this.getOptions(), { stacked: t } = this.configs;
    let s;
    if (t) {
      const n = Object.keys(e.axes).some((a) => e.axes[a].percentage);
      s = this.model.getStackedData({
        groups: this.configs.groups,
        percentage: n
      });
    } else {
      const { cartesianScales: n } = this.services;
      if (!n)
        throw new Error("Services cartesianScales are undefined.");
      s = this.model.getDisplayData(this.configs.groups).filter((a) => {
        const i = n.getRangeIdentifier(a);
        return a[i] !== void 0 && a[i] !== null;
      });
    }
    return this.filterBasedOnZoomDomain(s);
  }
  render(e) {
    if (!(y(this.getOptions(), "points", "enabled") || y(this.getOptions(), "bubble", "enabled")))
      return;
    const s = this.getComponentContainer({ withinChartClip: !0 }), n = this.getOptions(), { groupMapsTo: a } = n.data, { cartesianScales: i } = this.services;
    if (!i)
      throw new Error("Services cartesianScales are undefined.");
    const r = i.getDomainIdentifier(), l = s.selectAll("circle.dot").data(
      this.getScatterData(),
      (p) => `${p[a]}-${p[r]}`
    );
    l.exit().attr("opacity", 0).remove();
    const d = l.enter().append("circle").classed("dot", !0).attr("opacity", 0).merge(l);
    this.styleCircles(d, e), this.addEventListeners();
  }
  // A value is an anomaly if is above all defined domain and range thresholds
  isDatapointThresholdAnomaly(e) {
    const { handleThresholds: t } = this.configs;
    if (!t)
      return !1;
    const { cartesianScales: s } = this.services;
    if (!s)
      throw new Error("Cartesian scales service is undefined");
    const n = s.getOrientation(), [a, i] = ve(
      s.getHighestDomainThreshold(),
      s.getHighestRangeThreshold(),
      n
    ), [r, l] = ve(
      (p) => s.getDomainValue(p),
      (p) => s.getRangeValue(p),
      n
    ), c = r(e), d = l(e);
    return i && a ? d <= i.scaleValue && c >= a.scaleValue : i ? d <= i.scaleValue : a ? c >= a.scaleValue : !1;
  }
  styleCircles(e, t) {
    const s = this.getOptions(), { filled: n, fillOpacity: a } = s.points, { cartesianScales: i } = this.services;
    if (!i)
      throw new Error("Cartesian scales service is undefined");
    const { groupMapsTo: r } = s.data, l = (u) => i.getDomainValue(u), c = (u) => i.getRangeValue(u), [d, p] = ve(
      l,
      c,
      i.getOrientation()
    ), { fadeInOnChartHolderMouseover: h } = this.configs;
    e.raise().classed("dot", !0).attr("class", (u) => {
      const g = i.getDomainIdentifier(u), b = this.model.getIsFilled(u[r], u[g], u, n) ? [$.FILL, $.STROKE] : [$.STROKE];
      return this.model.getColorClassName({
        classNameTypes: b,
        dataGroupName: u[r],
        originalClassName: "dot"
      }) || "";
    }).classed("threshold-anomaly", (u) => this.isDatapointThresholdAnomaly(u)).classed("filled", (u) => {
      const g = i.getDomainIdentifier(u);
      return this.model.getIsFilled(u[r], u[g], u, n);
    }).classed("unfilled", (u) => {
      const g = i.getDomainIdentifier(u);
      return !this.model.getIsFilled(u[r], u[g], u, n);
    }).transition().call(
      (u) => {
        var g;
        return (g = this.services.transitions) == null ? void 0 : g.setupTransition({
          transition: u,
          name: "scatter-update-enter",
          animate: t
        });
      }
    ).attr("cx", d).attr("cy", p).attr("r", s.points.radius).style("fill", (u) => {
      const g = i.getDomainIdentifier(u);
      if (this.model.getIsFilled(u[r], u[g], u, n))
        return this.model.getFillColor(u[r], u[g], u);
    }).style("stroke", (u) => {
      const g = i.getDomainIdentifier(u);
      return this.model.getStrokeColor(u[r], u[g], u);
    }).attr("fill-opacity", n ? a : 1).attr("opacity", h ? 0 : 1).attr("role", U.GRAPHICS_SYMBOL).attr("aria-roledescription", "point").attr("aria-label", (u) => {
      const g = i.getRangeIdentifier(u);
      return u[g];
    }), this.addEventListeners();
  }
  // Extended in bubble graphs
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getTooltipAdditionalItems(e) {
    return null;
  }
  addEventListeners() {
    const e = this, { groupMapsTo: t } = e.getOptions().data;
    if (!this.parent)
      throw new Error("Parent not defined");
    this.parent.selectAll("circle").on("mouseover", function(s, n) {
      var i, r;
      const a = x(this);
      a.classed("hovered", !0).attr(
        "class",
        (l) => e.model.getColorClassName({
          classNameTypes: [$.FILL],
          dataGroupName: l[t],
          originalClassName: a.attr("class")
        })
      ).style("fill", (l) => {
        var d;
        const c = (d = e.services.cartesianScales) == null ? void 0 : d.getDomainIdentifier(l);
        return e.model.getFillColor(l[t], l[c], l);
      }).classed("unfilled", !1), (i = e.services.events) == null || i.dispatchEvent(f.Tooltip.SHOW, {
        event: s,
        hoveredElement: a,
        data: [n],
        additionalItems: e.getTooltipAdditionalItems(n)
      }), (r = e.services.events) == null || r.dispatchEvent(f.Scatter.SCATTER_MOUSEOVER, {
        event: s,
        element: a,
        datum: n
      });
    }).on("mousemove", function(s, n) {
      var i, r;
      const a = x(this);
      (i = e.services.events) == null || i.dispatchEvent(f.Scatter.SCATTER_MOUSEMOVE, {
        event: s,
        element: a,
        datum: n
      }), (r = e.services.events) == null || r.dispatchEvent(f.Tooltip.MOVE, {
        event: s
      });
    }).on("click", function(s, n) {
      var a;
      (a = e.services.events) == null || a.dispatchEvent(f.Scatter.SCATTER_CLICK, {
        event: s,
        element: x(this),
        datum: n
      });
    }).on("mouseout", function(s, n) {
      var i, r, l;
      const a = x(this);
      if (a.classed("hovered", !1), !e.configs.filled) {
        const { filled: c } = e.getOptions().points, d = (i = e.services.cartesianScales) == null ? void 0 : i.getDomainIdentifier(n), p = e.model.getIsFilled(
          n[t],
          n[d],
          n,
          c
        );
        a.classed("unfilled", !p).style("fill", (h) => p || c ? e.model.getFillColor(h[t], h[d], h) : null);
      }
      (r = e.services.events) == null || r.dispatchEvent(f.Scatter.SCATTER_MOUSEOUT, {
        event: s,
        element: a,
        datum: n
      }), (l = e.services.events) == null || l.dispatchEvent(f.Tooltip.HIDE, {
        hoveredElement: a
      });
    });
  }
  destroy() {
    var t;
    (t = this.parent) == null || t.selectAll("circle").on("mousemove", null).on("mouseout", null);
    const { events: e } = this.services;
    if (!e)
      throw new Error("Services events undefined");
    e.removeEventListener(f.Legend.ITEM_HOVER, this.handleLegendOnHover), e.removeEventListener(f.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut), e.removeEventListener(f.Chart.MOUSEOVER, this.handleChartHolderOnHover), e.removeEventListener(f.Chart.MOUSEOUT, this.handleChartHolderOnMouseOut);
  }
}
class Ys extends z {
  constructor(e, t, s) {
    super(e, t, s), this.type = "axes", this.renderType = H.SVG, this.truncation = {
      [V.LEFT]: !1,
      [V.RIGHT]: !1,
      [V.TOP]: !1,
      [V.BOTTOM]: !1
    }, s && (this.configs = s), this.margins = this.configs.margins;
  }
  render(e = !0) {
    const { position: t } = this.configs, s = this.getOptions(), n = y(s, "axes", t, "visible"), a = this.getComponentContainer(), { width: i, height: r } = E.getSVGElementSize(a, {
      useAttrs: !0
    }), l = E.appendOrSelect(a, `g.axis.${t}`);
    let c, d;
    if (t === V.BOTTOM || t === V.TOP ? (c = this.configs.axes[V.LEFT] ? this.margins.left : 0, d = this.configs.axes[V.RIGHT] ? i - this.margins.right : i) : (c = r - this.margins.bottom, d = this.margins.top), !this.services.cartesianScales)
      throw new Error("Services cartesianScales undefined");
    const p = this.services.cartesianScales.getScaleByPosition(t);
    this.scaleType === te.LABELS || this.scaleType === te.LABELS_RATIO ? p.rangeRound([c, d]) : p.range([c, d]);
    let h;
    switch (t) {
      case V.LEFT:
        h = fs;
        break;
      case V.BOTTOM:
        h = Rt;
        break;
      case V.RIGHT:
        h = Js;
        break;
      case V.TOP:
        h = Ks;
        break;
    }
    l.attr("aria-label", `${t} axis`);
    const u = !l.select("g.ticks").empty();
    let g = E.appendOrSelect(l, "g.ticks");
    u || (g.attr("role", `${U.GRAPHICS_OBJECT} ${U.GROUP}`), g.attr("aria-label", `${t} ticks`));
    const m = E.appendOrSelect(l, "g.ticks.invisible").style("opacity", "0").style("pointer-events", "none").attr("aria-hidden", !0).attr("aria-label", `invisible ${t} ticks`), b = y(s, "axes", t), v = this.scaleType === te.TIME || b.scaleType === te.TIME, S = t === V.LEFT || t === V.RIGHT, T = this.model.get("zoomDomain");
    if (T && v && !S && p.domain(T), !n) {
      g.attr("aria-hidden", !0);
      return;
    }
    const w = y(b, "scaleType"), L = y(s, "data", "loading"), O = y(b, "ticks", "number"), k = y(b, "ticks", "values"), I = y(b, "truncation", "type"), F = y(b, "truncation", "threshold"), P = y(b, "truncation", "numCharacter"), A = O !== null, M = y(s, "timeScale"), G = E.appendOrSelect(m, "g.tick"), D = E.appendOrSelect(G, "text").text("0"), X = E.getSVGElementSize(D.node(), {
      useBBox: !0
    }).height;
    G.remove();
    const re = this.scaleType || b.scaleType || te.LINEAR, W = h(p).tickSizeOuter(0);
    if (p.ticks) {
      let B;
      if (A ? B = O : (B = ke.ticks.number, S && (B = this.getNumberOfFittingTicks(
        r,
        X,
        ke.ticks.verticalSpaceRatio
      ))), p.ticks().length === 1 && p.ticks()[0] === 0 && (B = 0), W.ticks(B), v)
        if (!p.ticks(B).length)
          W.tickValues([]);
        else {
          const j = y(s, "timeScale", "addSpaceOnEdges"), q = y(s, "axes", t, "domain"), J = p.copy();
          j && !q && J.nice(B);
          const oe = J.ticks(B);
          j && oe.length > 2 && !q && (oe.splice(oe.length - 1, 1), oe.splice(0, 1)), W.tickValues(oe);
        }
    }
    let N;
    const ae = y(b, "ticks", "formatter");
    if (v) {
      const B = ut(
        W.tickValues(),
        y(s, "timeScale", "timeInterval")
      );
      ae === null ? N = (j, q) => pt(j, q, W.tickValues(), B, M) : N = (j, q) => {
        const J = pt(
          j,
          q,
          W.tickValues(),
          B,
          M
        );
        return ae(j, q, J);
      };
    } else
      ae === null ? re === te.LINEAR && (N = (B) => B.toLocaleString()) : N = ae;
    W.tickFormat(N);
    const [tt, st] = this.services.cartesianScales.getScaleByPosition(t).domain();
    let _e;
    if (k) {
      if (v)
        k.forEach((B, j) => {
          B.getTime === void 0 && (k[j] = new Date(B));
        }), _e = k.filter((B) => {
          const j = B.getTime();
          return j >= new Date(tt).getTime() && j <= new Date(st).getTime();
        });
      else if (w === te.LABELS) {
        const B = this.services.cartesianScales.getScaleByPosition(t).domain();
        _e = k.filter((j) => B.includes(j));
      } else
        _e = k.filter(
          (B) => B >= tt && B <= st
        );
      W.tickValues(_e);
    }
    switch (t) {
      case V.LEFT:
        g.attr("transform", `translate(${this.margins.left}, 0)`);
        break;
      case V.BOTTOM:
        g.attr("transform", `translate(0, ${r - this.margins.bottom})`);
        break;
      case V.RIGHT:
        g.attr("transform", `translate(${i - this.margins.right}, 0)`);
        break;
      case V.TOP:
        g.attr("transform", `translate(0, ${this.margins.top})`);
        break;
    }
    const Gt = this.model.isDataEmpty();
    if (b.title) {
      const B = E.appendOrSelect(l, "text.axis-title").html(
        Gt || L ? "" : b.title
      ), j = y(b, "titleOrientation");
      let q;
      switch (t) {
        case V.LEFT:
          j === Wt.RIGHT ? B.attr("transform", "rotate(90)").attr("y", 0).attr("x", p.range()[0] / 2).attr("dy", "-0.5em").style("text-anchor", "middle") : B.attr("transform", "rotate(-90)").attr("y", 0).attr("x", -(p.range()[0] / 2)).attr("dy", "0.75em").style("text-anchor", "middle");
          break;
        case V.BOTTOM:
          B.attr(
            "transform",
            `translate(${this.margins.left / 2 + p.range()[1] / 2}, ${r + 4})`
          ).style("text-anchor", "middle");
          break;
        case V.RIGHT:
          j === Wt.LEFT ? B.attr("transform", "rotate(-90)").attr("y", i).attr("x", -(p.range()[0] / 2)).style("text-anchor", "middle") : B.attr("transform", "rotate(90)").attr("y", -i).attr("x", p.range()[0] / 2).attr("dy", "0.75em").style("text-anchor", "middle");
          break;
        case V.TOP:
          q = E.getSVGElementSize(B, {
            useBBox: !0
          }).height, B.attr(
            "transform",
            `translate(${this.margins.left / 2 + p.range()[1] / 2}, ${q / 2})`
          ).style("text-anchor", "middle");
          break;
      }
    }
    if (v) {
      const B = ut(
        W.tickValues(),
        y(s, "timeScale", "timeInterval")
      ), j = M.showDayName, q = g;
      e && (g = g.transition().call(
        (oe) => this.services.transitions.setupTransition({
          transition: oe,
          name: "axis-update",
          animate: e
        })
      )), g = g.call(W), q.selectAll(".tick").data(W.tickValues(), p).order().select("text").style("font-weight", (oe, Ne) => Cn(oe, Ne, W.tickValues(), B, j) ? "bold" : "normal");
    } else
      !e || !u ? g = g.call(W) : g = g.transition().call(
        (B) => this.services.transitions.setupTransition({
          transition: B,
          name: "axis-update",
          animate: e
        })
      ).call(W);
    if (m.call(W), t === V.BOTTOM || t === V.TOP) {
      let B = !1;
      const j = y(b, "ticks", "rotation");
      if (j === nt.ALWAYS)
        B = !0;
      else if (j === nt.NEVER)
        B = !1;
      else if (!j || j === nt.AUTO)
        if (p.step)
          B = m.selectAll("g.tick text").nodes().some(
            (J) => E.getSVGElementSize(J, {
              useBBox: !0
            }).width >= p.step()
          );
        else {
          B = !1;
          const q = m.append("text").text("A"), J = E.getSVGElementSize(q.node(), {
            useBBox: !0
          }).width;
          let oe;
          m.selectAll("g.tick").each(function() {
            const Ne = x(this), C = parseFloat(y(ge(this), "tx"));
            C !== null && oe + Ne.text().length * J * 0.8 >= C && (B = !0), oe = C;
          }), q.remove();
        }
      B ? (A || (W.ticks(
        this.getNumberOfFittingTicks(i, X, ke.ticks.horizontalSpaceRatio)
      ), m.call(W), g.call(W)), l.selectAll("g.ticks g.tick text").attr("transform", "rotate(-45)").attr("text-anchor", t === V.TOP ? "start" : "end")) : l.selectAll("g.ticks g.tick text").attr("transform", null).attr("text-anchor", null);
    }
    if (L ? l.attr("opacity", 0) : l.attr("opacity", 1), g.selectAll("g.tick").attr("aria-label", (B) => B), m.selectAll("g.tick").attr("aria-label", (B) => B), I !== Ie.NONE && w === te.LABELS && !k) {
      const B = this.services.cartesianScales.getScaleDomain(t);
      if (B.length > 0) {
        const j = a.select(`g.axis.${t} g.ticks g.tick`).html();
        l.selectAll("g.ticks g.tick").html(j);
        const q = this;
        l.selectAll("g.tick text").data(B).text(function(J) {
          return J.length > F ? (q.truncation[t] = !0, Ge(J, I, P)) : J;
        }), this.getInvisibleAxisRef().selectAll("g.tick text").data(B).text(function(J) {
          return J.length > F ? Ge(J, I, P) : J;
        }), l.selectAll("g.ticks").html(this.getInvisibleAxisRef().html()), l.selectAll("g.tick text").data(B);
      }
    }
    this.addEventListeners();
  }
  addEventListeners() {
    const e = this.getComponentContainer(), { position: t } = this.configs, s = E.appendOrSelect(e, `g.axis.${t}`), n = this.getOptions(), a = y(n, "axes", t), i = y(a, "scaleType"), r = y(a, "truncation", "threshold"), l = this;
    s.selectAll("g.tick text").on("mouseover", function(c, d) {
      l.services.events.dispatchEvent(f.Axis.LABEL_MOUSEOVER, {
        event: c,
        element: x(this),
        datum: d
      }), i === te.LABELS && d.length > r && l.services.events.dispatchEvent(f.Tooltip.SHOW, {
        event: c,
        hoveredElement: x(this),
        content: d
      });
    }).on("mousemove", function(c, d) {
      l.services.events.dispatchEvent(f.Axis.LABEL_MOUSEMOVE, {
        event: c,
        element: x(this),
        datum: d
      }), i === te.LABELS && d.length > r && l.services.events.dispatchEvent(f.Tooltip.MOVE, {
        event: c
      });
    }).on("click", function(c, d) {
      l.services.events.dispatchEvent(f.Axis.LABEL_CLICK, {
        event: c,
        element: x(this),
        datum: d
      });
    }).on("mouseout", function(c, d) {
      l.services.events.dispatchEvent(f.Axis.LABEL_MOUSEOUT, {
        event: c,
        element: x(this),
        datum: d
      }), i === te.LABELS && l.services.events.dispatchEvent(f.Tooltip.HIDE);
    });
  }
  getInvisibleAxisRef() {
    const { position: e } = this.configs;
    return this.getComponentContainer().select(`g.axis.${e} g.ticks.invisible`);
  }
  getTitleRef() {
    const { position: e } = this.configs;
    return this.getComponentContainer().select(`g.axis.${e} text.axis-title`);
  }
  getNumberOfFittingTicks(e, t, s) {
    const n = Math.floor(e / (t * s));
    return $s(n, 2, ke.ticks.number);
  }
  destroy() {
    const e = this.getComponentContainer(), { position: t } = this.configs;
    E.appendOrSelect(e, `g.axis.${t}`).selectAll("g.tick text").on("mouseover", null).on("mousemove", null).on("mouseout", null);
  }
}
class or extends Ys {
  constructor(e, t, s) {
    super(e, t, s);
  }
  render(e = !0) {
    super.render(e), super.destroy();
    const t = this.configs.position, s = this.getComponentContainer(), n = E.appendOrSelect(s, `g.axis.${t}`), a = this;
    n.selectAll("g.tick").each(function(i, r) {
      const l = x(this);
      l.classed("tick-hover", !0).attr("tabindex", r === 0 ? 0 : -1);
      const c = l.select("text"), { width: d, height: p } = E.getSVGElementSize(c, {
        useBBox: !0
      }), h = E.appendOrSelect(l, "rect.axis-holder");
      let u = 0, g = 0;
      switch (t) {
        case V.LEFT:
          u = -d + Number(c.attr("x")), g = -(p / 2);
          break;
        case V.RIGHT:
          u = Math.abs(Number(c.attr("x"))), g = -(p / 2);
          break;
        case V.TOP:
          u = -(d / 2), g = -p + Number(c.attr("y")) / 2, a.truncation[t] && (u = 0, h.attr("transform", "rotate(-45)"));
          break;
        case V.BOTTOM:
          u = -(d / 2), g = p / 2 - 2, a.truncation[t] && (u = -d, h.attr("transform", "rotate(-45)"));
          break;
      }
      h.attr("x", u - ke.hover.rectanglePadding).attr("y", g).attr("width", d + ke.hover.rectanglePadding * 2).attr("height", p).lower();
    }), this.addEventListeners();
  }
  addEventListeners() {
    const e = this.getComponentContainer(), { position: t } = this.configs, s = E.appendOrSelect(e, `g.axis.${t}`), n = this.getOptions(), a = y(n, "axes", t), i = y(a, "scaleType"), r = y(a, "truncation", "threshold"), l = this;
    s.selectAll("g.tick.tick-hover").on("mouseover", function(c) {
      const d = x(this).select("text"), p = d.datum();
      l.services.events.dispatchEvent(f.Axis.LABEL_MOUSEOVER, {
        event: c,
        element: d,
        datum: p
      }), i === te.LABELS && p.length > r && l.services.events.dispatchEvent(f.Tooltip.SHOW, {
        event: c,
        element: d,
        datum: p
      });
    }).on("mousemove", function(c) {
      const d = x(this).select("text"), p = d.datum();
      l.services.events.dispatchEvent(f.Axis.LABEL_MOUSEMOVE, {
        event: c,
        element: d,
        datum: p
      }), l.services.events.dispatchEvent(f.Tooltip.MOVE, {
        event: c
      });
    }).on("click", function(c) {
      l.services.events.dispatchEvent(f.Axis.LABEL_CLICK, {
        event: c,
        element: x(this).select("text"),
        datum: x(this).select("text").datum()
      });
    }).on("mouseout", function(c) {
      l.services.events.dispatchEvent(f.Axis.LABEL_MOUSEOUT, {
        event: c,
        element: x(this).select("text"),
        datum: x(this).select("text").datum()
      }), i === te.LABELS && l.services.events.dispatchEvent(f.Tooltip.HIDE);
    }).on("focus", function(c) {
      const d = { clientX: 0, clientY: 0 };
      if (c.target) {
        c.target.focus();
        const p = c.target.getBoundingClientRect();
        d.clientX = p.x, d.clientY = p.y;
      }
      l.services.events.dispatchEvent(f.Axis.LABEL_FOCUS, {
        event: { ...c, ...d },
        element: x(this),
        datum: x(this).select("text").datum()
      });
    }).on("blur", function(c) {
      l.services.events.dispatchEvent(f.Axis.LABEL_BLUR, {
        event: c,
        element: x(this),
        datum: x(this).select("text").datum()
      });
    }).on("keydown", function(c) {
      c.key && c.key === "Escape" && (l.services.events.dispatchEvent(f.Tooltip.HIDE), l.services.events.dispatchEvent(f.Axis.LABEL_BLUR, {
        event: c,
        element: x(this),
        datum: x(this).select("text").datum()
      })), t === V.LEFT || t === V.RIGHT ? c.key && c.key === "ArrowUp" ? l.goNext(this, c) : c.key && c.key === "ArrowDown" && l.goPrevious(this, c) : c.key && c.key === "ArrowLeft" ? l.goPrevious(this, c) : c.key && c.key === "ArrowRight" && l.goNext(this, c);
    });
  }
  // Focus on the next HTML element sibling
  goNext(e, t) {
    e.nextElementSibling && e.nextElementSibling.tagName !== "path" && e.nextElementSibling.dispatchEvent(new Event("focus")), t.preventDefault();
  }
  // Focus on the previous HTML element sibling
  goPrevious(e, t) {
    e.previousElementSibling && e.previousElementSibling.tagName !== "path" && e.previousElementSibling.dispatchEvent(new Event("focus")), t.preventDefault();
  }
  destroy() {
    const e = this.getComponentContainer(), { position: t } = this.configs;
    E.appendOrSelect(e, `g.axis.${t}`).selectAll("g.tick.tick-hover").on("mouseover", null).on("mousemove", null).on("mouseout", null).on("focus", null).on("blur", null);
  }
}
class vc extends z {
  constructor() {
    super(...arguments), this.type = "2D-axes", this.renderType = H.SVG, this.children = {}, this.thresholds = [], this.margins = {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    };
  }
  render(e = !1) {
    const t = {}, s = Object.keys(V), n = y(this.getOptions(), "axes");
    s.forEach((r) => {
      n[V[r]] && (t[V[r]] = !0);
    }), this.configs.axes = t, s.forEach((r) => {
      const l = V[r];
      if (this.configs.axes[l] && !this.children[l]) {
        const c = {
          position: l,
          axes: this.configs.axes,
          margins: this.margins
        }, d = this.model.axisFlavor === _n.DEFAULT ? new Ys(this.model, this.services, c) : new or(this.model, this.services, c);
        d.setModel(this.model), d.setServices(this.services), d.setParent(this.parent), this.children[l] = d;
      }
    }), Object.keys(this.children).forEach((r) => {
      this.children[r].render(e);
    });
    const a = {};
    Object.keys(this.children).forEach((r) => {
      const l = this.children[r], c = l.configs.position, d = l.getInvisibleAxisRef(), { width: p, height: h } = E.getSVGElementSize(d, { useBBox: !0 });
      let u;
      switch (l.getTitleRef().empty() ? u = 0 : (u = E.getSVGElementSize(l.getTitleRef(), {
        useBBox: !0
      }).height, (c === V.LEFT || c === V.RIGHT) && (u += 5)), c) {
        case V.TOP:
          a.top = h + u;
          break;
        case V.BOTTOM:
          a.bottom = h + u;
          break;
        case V.LEFT:
          a.left = p + u;
          break;
        case V.RIGHT:
          a.right = p + u;
          break;
      }
    }), this.services.events.dispatchEvent(f.Axis.RENDER_COMPLETE), Object.keys(a).some((r) => this.margins[r] !== a[r]) && (this.margins = Object.assign(this.margins, a), this.model.set({ axesMargins: this.margins }, { skipUpdate: !0 }), this.services.events.dispatchEvent(f.ZoomBar.UPDATE), Object.keys(this.children).forEach((r) => {
      const l = this.children[r];
      l.margins = this.margins;
    }), this.render(!0));
  }
}
class lr extends z {
  constructor() {
    super(...arguments), this.type = "skeleton";
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(e = !0) {
    const t = y(this.getOptions(), "data", "loading");
    t ? this.renderSkeleton(t) : this.removeSkeleton();
  }
  renderSkeleton(e) {
    if (this.configs.skeleton === Ue.GRID)
      this.renderGridSkeleton(e);
    else if (this.configs.skeleton === Ue.VERT_OR_HORIZ)
      this.renderVertOrHorizSkeleton(e);
    else if (this.configs.skeleton === Ue.PIE)
      this.renderPieSkeleton(e);
    else if (this.configs.skeleton === Ue.DONUT)
      this.renderDonutSkeleton(e);
    else
      throw new Error(`"${this.configs.skeleton}" is not a valid Skeleton type.`);
  }
  renderGridSkeleton(e) {
    this.setScales(), this.drawBackdrop(e), this.drawXGrid(e), this.drawYGrid(e), e && this.setShimmerEffect("shimmer-lines");
  }
  renderVertOrHorizSkeleton(e) {
    const t = this.services.cartesianScales.getOrientation();
    this.setScales(), this.drawBackdrop(e), t === le.VERTICAL && this.drawYGrid(e), t === le.HORIZONTAL && this.drawXGrid(e), this.setShimmerEffect("shimmer-lines");
  }
  renderPieSkeleton(e) {
    const t = this.computeOuterRadius(), s = 0;
    this.drawRing(t, s, e), e && this.setShimmerEffect("shimmer-areas");
  }
  renderDonutSkeleton(e) {
    const t = this.computeOuterRadius(), s = this.computeInnerRadius();
    this.drawRing(t, s, e), e && this.setShimmerEffect("shimmer-areas");
  }
  setScales() {
    const e = this.services.cartesianScales.getMainXScale().range(), t = this.services.cartesianScales.getMainYScale().range();
    this.xScale = Oe().domain([0, 1]).range(e), this.yScale = Oe().domain([0, 1]).range(t);
  }
  drawBackdrop(e) {
    const t = this.parent, { width: s, height: n } = E.getSVGElementSize(t, {
      useAttrs: !0
    });
    this.backdrop = E.appendOrSelect(t, "svg.chart-skeleton.DAII").attr("width", s).attr("height", n);
    const a = E.appendOrSelect(this.backdrop, "rect.chart-skeleton-backdrop");
    a.attr("width", "100%").attr("height", "100%");
    const [i] = this.xScale.range(), [, r] = this.yScale.range();
    this.backdrop.merge(a).attr("x", i).attr("y", r), a.classed("shimmer-effect-lines", e).classed("empty-state-lines", !e).style(
      "stroke",
      e ? `url(#${this.services.domUtils.generateElementIDString("shimmer-lines")})` : null
    );
  }
  drawXGrid(e) {
    const t = +this.backdrop.attr("width"), s = y(this.getOptions(), "grid", "x", "numberOfTicks"), n = this.xScale.ticks(s).map((r) => r * t), a = E.appendOrSelect(this.backdrop, "g.x.skeleton"), i = a.selectAll("line").data(n);
    i.enter().append("line").merge(i).attr("x1", (r) => r).attr("x2", (r) => r).attr("y1", 0).attr("y2", "100%"), a.selectAll("line").classed("shimmer-effect-lines", e).classed("empty-state-lines", !e).style(
      "stroke",
      e ? `url(#${this.services.domUtils.generateElementIDString("shimmer-lines")})` : null
    );
  }
  drawYGrid(e) {
    const t = +this.backdrop.attr("height"), s = this.backdrop.attr("width"), n = y(this.getOptions(), "grid", "y", "numberOfTicks"), a = this.xScale.ticks(n).map((l) => l * t), i = E.appendOrSelect(this.backdrop, "g.y.skeleton"), r = i.selectAll("line").data(a);
    r.enter().append("line").merge(r).attr("x1", 0).attr("x2", s).attr("y1", (l) => l).attr("y2", (l) => l), i.selectAll("line").classed("shimmer-effect-lines", e).classed("empty-state-lines", !e).style(
      "stroke",
      e ? `url(#${this.services.domUtils.generateElementIDString("shimmer-lines")})` : null
    );
  }
  drawRing(e, t, s = !0) {
    const n = this.parent, { width: a, height: i } = E.getSVGElementSize(n, {
      useAttrs: !0
    }), r = E.appendOrSelect(n, "svg.chart-skeleton").attr("width", a).attr("height", i), l = t === 0 ? "pie" : "donut", c = y(this.getOptions(), l, "alignment");
    E.appendOrSelect(r, "rect.chart-skeleton-area-container").attr("width", a).attr("height", i).attr("fill", "none");
    const d = $e().innerRadius(t).outerRadius(e).startAngle(0).endAngle(Math.PI * 2), p = e + Math.abs(Z.radiusOffset), h = e + (Math.min(a, i) - e * 2) / 2, u = E.appendOrSelect(r, "path").attr("class", "skeleton-area-shape").attr("transform", `translate(${p}, ${h})`).attr("d", d).classed("shimmer-effect-areas", s).classed("empty-state-areas", !s).style(
      "fill",
      s ? `url(#${this.services.domUtils.generateElementIDString("shimmer-areas")})` : null
    );
    let g = e + Z.xOffset;
    c === ue.CENTER ? g = a / 2 : c === ue.RIGHT && (g = a - e - Z.xOffset);
    const m = e + Z.yOffset;
    u.attr("transform", `translate(${g}, ${m})`);
  }
  // same logic in pie
  computeOuterRadius() {
    const { width: e, height: t } = E.getSVGElementSize(this.parent, {
      useAttrs: !0
    });
    return Math.min(e, t) / 2 + Z.radiusOffset;
  }
  // same logic in donut
  computeInnerRadius() {
    return this.computeOuterRadius() * (3 / 4);
  }
  setShimmerEffect(e) {
    const a = "stop-bg-shimmer", i = "stop-shimmer", r = this.parent.select(".chart-skeleton"), { width: l } = E.getSVGElementSize(this.parent, {
      useAttrs: !0
    }), c = 0, d = l, p = E.appendOrSelect(r, "defs").lower(), h = E.appendOrSelect(p, "linearGradient").attr("id", this.services.domUtils.generateElementIDString(e)).attr("class", e).attr("x1", c - 3 * 0.2 * l).attr("x2", d).attr("y1", 0).attr("y2", 0).attr("gradientUnits", "userSpaceOnUse").attr("gradientTransform", "translate(0, 0)"), u = `
			<stop class="${a}" offset="${c}"></stop>
			<stop class="${i}" offset="${c + 0.2}"></stop>
			<stop class="${a}" offset="${c + 2 * 0.2}"></stop>
		`;
    h.html(u), g();
    function g() {
      h.attr("gradientTransform", `translate(${c - 3 * 0.2 * l}, 0)`).transition().duration(2e3).delay(1e3).ease(Qs).attr("gradientTransform", `translate(${d + 3 * 0.2 * l}, 0)`).on("end", g);
    }
  }
  removeSkeleton() {
    this.parent.select(".chart-skeleton").remove();
  }
}
class yc extends z {
  constructor() {
    super(...arguments), this.type = "boxplot", this.renderType = H.SVG;
  }
  render(e) {
    const t = this.getComponentContainer({ withinChartClip: !0 }), s = this.getOptions(), { groupMapsTo: n } = s.data, a = this.model.getDataGroupNames(), i = this.services.cartesianScales.getMainXScale(), r = this.services.cartesianScales.getMainYScale(), [l, c] = i.range(), [d, p] = r.range(), h = c - l, u = d - p;
    if (h === 0)
      return;
    const { cartesianScales: g } = this.services, m = g.getOrientation(), b = m === le.VERTICAL, [v, S] = ve(
      (A) => this.services.cartesianScales.getDomainValue(A),
      (A) => this.services.cartesianScales.getRangeValue(A),
      m
    ), T = Math.floor((b ? h : u) / a.length), w = Math.min(T / 2, 16), L = this.model.getBoxplotData(), O = t.selectAll(".box-group").data(L);
    O.exit().remove();
    const k = O.enter().append("g").attr("class", "box-group"), I = O.merge(k);
    k.append("path").merge(O.select("path.vertical-line.start")).attr(
      "class",
      () => this.model.getColorClassName({
        classNameTypes: [$.STROKE],
        originalClassName: "vertical-line start"
      })
    ).attr("stroke-width", ce.strokeWidth.default).attr("fill", "none").transition().call(
      (A) => this.services.transitions.setupTransition({
        transition: A,
        name: "boxplot-update-verticalstartline",
        animate: e
      })
    ).attr("d", (A) => {
      const M = g.getDomainValue(A[n]), G = M, D = g.getRangeValue(A.whiskers.min), X = g.getRangeValue(A.quartiles.q_25);
      return ie({ x0: M, x1: G, y0: D, y1: X }, m);
    }), k.append("path").merge(O.select("path.vertical-line.end")).attr(
      "class",
      () => this.model.getColorClassName({
        classNameTypes: [$.STROKE],
        originalClassName: "vertical-line end"
      })
    ).attr("stroke-width", ce.strokeWidth.default).attr("fill", "none").transition().call(
      (A) => this.services.transitions.setupTransition({
        transition: A,
        name: "boxplot-update-verticalendline",
        animate: e
      })
    ).attr("d", (A) => {
      const M = g.getDomainValue(A[n]), G = M, D = g.getRangeValue(A.whiskers.max), X = g.getRangeValue(A.quartiles.q_75);
      return ie({ x0: M, x1: G, y0: D, y1: X }, m);
    }), k.append("path").merge(O.select("path.box")).attr(
      "class",
      () => this.model.getColorClassName({
        classNameTypes: [$.FILL, $.STROKE],
        originalClassName: "box"
      })
    ).attr("fill-opacity", ce.box.opacity.default).attr("stroke-width", ce.strokeWidth.default).attr("role", U.GRAPHICS_SYMBOL).attr("aria-roledescription", "box").attr("aria-label", (A) => A[n]).transition().call(
      (A) => this.services.transitions.setupTransition({
        transition: A,
        name: "boxplot-update-quartiles",
        animate: e
      })
    ).attr("d", (A) => {
      const M = g.getDomainValue(A[n]) - w / 2, G = M + w, D = g.getRangeValue(
        Math[b ? "max" : "min"](A.quartiles.q_75, A.quartiles.q_25)
      ), X = D + Math.abs(
        g.getRangeValue(A.quartiles.q_75) - g.getRangeValue(A.quartiles.q_25)
      );
      return ie({ x0: M, x1: G, y0: D, y1: X }, m);
    }), k.append("path").merge(O.select("path.highlight-area")).attr("class", "highlight-area").attr("opacity", 0).attr("d", (A) => {
      const M = g.getDomainValue(A[n]) - w / 2, G = M + w, D = g.getRangeValue(A.whiskers.min), X = g.getRangeValue(A.whiskers.max);
      return ie({ x0: M, x1: G, y0: D, y1: X }, m);
    }), k.append("path").merge(O.select("path.whisker.start")).attr(
      "class",
      () => this.model.getColorClassName({
        classNameTypes: [$.STROKE],
        originalClassName: "whisker start"
      })
    ).attr("stroke-width", ce.strokeWidth.thicker).attr("fill", "none").transition().call(
      (A) => this.services.transitions.setupTransition({
        transition: A,
        name: "boxplot-update-startingwhisker",
        animate: e
      })
    ).attr("d", (A) => {
      const M = g.getDomainValue(A[n]) - w / 4, G = M + w / 2, D = g.getRangeValue(A.whiskers.min), X = g.getRangeValue(A.whiskers.min);
      return ie({ x0: M, x1: G, y0: D, y1: X }, m);
    }), k.append("path").merge(O.select("path.median")).attr("fill", "none").attr(
      "class",
      () => this.model.getColorClassName({
        classNameTypes: [$.STROKE],
        originalClassName: "median"
      })
    ).attr("stroke-width", 2).transition().call(
      (A) => this.services.transitions.setupTransition({
        transition: A,
        name: "boxplot-update-median",
        animate: e
      })
    ).attr("d", (A) => {
      const M = g.getDomainValue(A[n]) - w / 2, G = M + w, D = g.getRangeValue(A.quartiles.q_50);
      return ie({ x0: M, x1: G, y0: D, y1: D }, m);
    }), k.append("path").merge(O.select("path.whisker.end")).attr(
      "class",
      () => this.model.getColorClassName({
        classNameTypes: [$.STROKE],
        originalClassName: "whisker end"
      })
    ).attr("stroke-width", ce.strokeWidth.thicker).attr("fill", "none").transition().call(
      (A) => this.services.transitions.setupTransition({
        transition: A,
        name: "boxplot-update-endingwhisker",
        animate: e
      })
    ).attr("d", (A) => {
      const M = g.getDomainValue(A[n]) - w / 4, G = M + w / 2, D = g.getRangeValue(A.whiskers.max), X = g.getRangeValue(A.whiskers.max);
      return ie({ x0: M, x1: G, y0: D, y1: X }, m);
    });
    const F = I.selectAll("circle.outlier").data(
      (A) => A.outliers.map((M) => ({
        min: A.whiskers.min,
        max: A.whiskers.max,
        [n]: A[n],
        value: M
      }))
    );
    F.exit().remove();
    const P = F.enter().append("circle");
    F.merge(P).attr("r", ce.circle.radius).attr(
      "class",
      () => this.model.getColorClassName({
        classNameTypes: [$.FILL, $.STROKE],
        originalClassName: "outlier"
      })
    ).attr("fill-opacity", ce.circle.opacity.default).attr("cx", v).transition().call(
      (A) => this.services.transitions.setupTransition({
        transition: A,
        name: "boxplot-update-circles",
        animate: e
      })
    ).attr("cy", S), this.addBoxEventListeners(), this.addCircleEventListeners();
  }
  addBoxEventListeners() {
    const e = this, t = this.getOptions(), { groupMapsTo: s } = t.data;
    this.parent.selectAll("path.highlight-area").on("mouseover", function(n, a) {
      const i = x(this);
      x(this.parentNode).select("path.box").classed("hovered", !0).attr("fill-opacity", ce.box.opacity.hovered), e.services.events.dispatchEvent(f.Tooltip.SHOW, {
        event: n,
        hoveredElement: i,
        items: [
          {
            label: t.tooltip.groupLabel,
            value: a[s],
            class: e.model.getColorClassName({
              classNameTypes: [$.TOOLTIP]
            })
          },
          {
            label: "Minimum",
            value: a.whiskers.min
          },
          {
            label: "Q1",
            value: a.quartiles.q_25
          },
          {
            label: "Median",
            value: a.quartiles.q_50
          },
          {
            label: "Q3",
            value: a.quartiles.q_75
          },
          {
            label: "Maximum",
            value: a.whiskers.max
          },
          {
            label: "IQR",
            value: a.quartiles.q_75 - a.quartiles.q_25
          }
        ]
      }), e.services.events.dispatchEvent(f.Boxplot.BOX_MOUSEOVER, {
        event: n,
        element: i,
        datum: a
      });
    }).on("mousemove", function(n, a) {
      const i = x(this);
      e.services.events.dispatchEvent(f.Boxplot.BOX_MOUSEMOVE, {
        event: n,
        element: i,
        datum: a
      }), e.services.events.dispatchEvent(f.Tooltip.MOVE, {
        event: n
      });
    }).on("click", function(n, a) {
      e.services.events.dispatchEvent(f.Boxplot.BOX_CLICK, {
        event: n,
        element: x(this),
        datum: a
      });
    }).on("mouseout", function(n, a) {
      const i = x(this);
      x(this.parentNode).select("path.box").classed("hovered", !1).attr("fill-opacity", ce.box.opacity.default), e.services.events.dispatchEvent(f.Boxplot.BOX_MOUSEOUT, {
        event: n,
        element: i,
        datum: a
      }), e.services.events.dispatchEvent(f.Tooltip.HIDE, {
        hoveredElement: i
      });
    });
  }
  addCircleEventListeners() {
    const e = this, t = this.getOptions(), { groupMapsTo: s } = t.data, n = this.services.cartesianScales.getRangeIdentifier();
    this.parent.selectAll("circle").on("mouseover", function(a, i) {
      const r = x(this);
      r.classed("hovered", !0).attr("fill-opacity", ce.circle.opacity.hovered).classed("unfilled", !1), e.services.events.dispatchEvent(f.Tooltip.SHOW, {
        event: a,
        hoveredElement: r,
        items: [
          {
            label: t.tooltip.groupLabel,
            value: i[s],
            class: e.model.getColorClassName({
              classNameTypes: [$.TOOLTIP]
            })
          },
          {
            label: "Outlier",
            value: i[n]
          }
        ]
      }), e.services.events.dispatchEvent(f.Boxplot.OUTLIER_MOUSEOVER, {
        event: a,
        element: r,
        datum: i
      });
    }).on("mousemove", function(a, i) {
      const r = x(this);
      e.services.events.dispatchEvent(f.Boxplot.OUTLIER_MOUSEMOVE, {
        event: a,
        element: r,
        datum: i
      }), e.services.events.dispatchEvent(f.Tooltip.MOVE, {
        event: a
      });
    }).on("click", function(a, i) {
      e.services.events.dispatchEvent(f.Boxplot.OUTLIER_CLICK, {
        event: a,
        element: x(this),
        datum: i
      });
    }).on("mouseout", function(a, i) {
      const r = x(this);
      r.classed("hovered", !1).attr("fill-opacity", ce.circle.opacity.default), e.services.events.dispatchEvent(f.Boxplot.OUTLIER_MOUSEOUT, {
        event: a,
        element: r,
        datum: i
      }), e.services.events.dispatchEvent(f.Tooltip.HIDE, {
        hoveredElement: r
      });
    });
  }
}
class bc extends z {
  constructor() {
    super(...arguments), this.type = "zero-line", this.renderType = H.SVG;
  }
  render(e) {
    const t = this.services.cartesianScales.getRangeAxisPosition({
      groups: this.configs.groups
    }), s = this.services.cartesianScales.getScaleByPosition(t), [n, a] = s.domain(), i = n > 0 && a < 0 || n < 0 && a > 0, r = this.getComponentContainer();
    if (!i) {
      r.selectAll("line.domain").remove();
      return;
    }
    const [l, c] = this.services.cartesianScales.getDomainScale().range();
    let d = +s(0) + 0.5;
    d || (d = s.range()[0]);
    const p = kn(
      {
        x0: l,
        x1: c,
        y0: d,
        y1: d
      },
      this.services.cartesianScales.getOrientation()
    );
    E.appendOrSelect(r, "line.domain").transition().call(
      (u) => this.services.transitions.setupTransition({
        transition: u,
        name: "zero-line-update",
        animate: e
      })
    ).attr("y1", p.y0).attr("y2", p.y1).attr("x1", p.x0).attr("x2", p.x1);
  }
}
class Ec extends Vt {
  constructor() {
    super(...arguments), this.type = "bubble", this.renderType = H.SVG;
  }
  getRadiusScale(e) {
    const t = this.getOptions(), { radiusMapsTo: s } = t.bubble, n = e.data(), a = n.map((c) => c[s]).filter((c) => c), i = E.getHTMLElementSize(this.services.domUtils.getMainContainer()), r = a.length > 0, l = r ? Qe(a) : [1, 1];
    return Oe().domain(l).range(r ? t.bubble.radiusRange(i, n) : [4, 4]);
  }
  styleCircles(e, t) {
    const s = this.getOptions(), { radiusMapsTo: n } = s.bubble, a = this.getRadiusScale(e), { groupMapsTo: i } = s.data, { cartesianScales: r } = this.services, l = (h) => r.getDomainValue(h), c = (h) => r.getRangeValue(h), [d, p] = ve(
      l,
      c,
      r.getOrientation()
    );
    e.raise().classed("dot", !0).attr("role", U.GRAPHICS_SYMBOL).attr("aria-label", (h) => {
      const u = r.getRangeIdentifier(h);
      return h[u];
    }).transition().call(
      (h) => this.services.transitions.setupTransition({
        transition: h,
        name: "bubble-update-enter",
        animate: t
      })
    ).attr("cx", d).attr("cy", p).attr("r", (h) => a(h[n] || 1)).attr(
      "class",
      (h) => this.model.getColorClassName({
        classNameTypes: [$.FILL, $.STROKE],
        dataGroupName: h[i],
        originalClassName: "dot"
      })
    ).style("fill", (h) => {
      const u = this.services.cartesianScales.getDomainIdentifier(h);
      return this.model.getFillColor(h[i], h[u], h);
    }).style("stroke", (h) => {
      const u = this.services.cartesianScales.getDomainIdentifier(h);
      return this.model.getStrokeColor(h[i], h[u], h);
    }).attr("fill-opacity", s.bubble.fillOpacity).attr("opacity", 1);
  }
  getTooltipAdditionalItems(e) {
    const t = y(this.getOptions(), "bubble");
    return [
      {
        label: y(t, "radiusLabel"),
        value: e[y(t, "radiusMapsTo")]
      }
    ];
  }
}
class Sc extends z {
  constructor() {
    super(...arguments), this.type = "bullet", this.renderType = H.SVG, this.handleLegendOnHover = (e) => {
      const { hoveredElement: t } = e.detail, { groupMapsTo: s } = this.getOptions().data;
      this.parent.selectAll("path.bar").transition("legend-hover-simple-bar").call(
        (n) => this.services.transitions.setupTransition({
          transition: n,
          name: "legend-hover-simple-bar"
        })
      ).attr("opacity", (n) => n[s] !== t.datum().name ? 0.3 : 1);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("path.bar").transition("legend-mouseout-simple-bar").call(
        (e) => this.services.transitions.setupTransition({
          transition: e,
          name: "legend-mouseout-simple-bar"
        })
      ).attr("opacity", 1);
    };
  }
  init() {
    const e = this.services.events;
    e.addEventListener(f.Legend.ITEM_HOVER, this.handleLegendOnHover), e.addEventListener(f.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(e) {
    const t = this.getOptions(), { groupMapsTo: s } = t.data, n = this.getComponentContainer({ withinChartClip: !0 }), a = this.model.getDisplayData(this.configs.groups), i = this.services.cartesianScales.getRangeScale(), r = this.services.cartesianScales.getRangeIdentifier(), [l, c] = i.range(), [, d] = i.domain(), p = () => {
      const m = [];
      a.forEach((S) => {
        S.ranges ? S.ranges.forEach((T, w) => {
          T != null && T < d && m.push({
            datum: S,
            value: T,
            order: w + 1
          });
        }) : m.push({
          datum: S,
          order: 1
        });
      });
      const b = E.appendOrSelect(n, "g.range-boxes").selectAll("path.range-box").data(m, (S) => `${S[s]}-${S.order}`);
      b.exit().attr("opacity", 0).remove(), b.enter().append("path").attr("opacity", 0).merge(b).attr("class", (S) => `range-box order-${S.order}`).transition().call(
        (S) => this.services.transitions.setupTransition({
          transition: S,
          name: "bullet-range-box-update-enter",
          animate: e
        })
      ).attr("d", (S) => {
        let w, L, O, k;
        return S.order === 1 ? (w = this.services.cartesianScales.getDomainValue(S.datum) - 16 / 2, L = w + 16, O = c - 2, k = l + 1) : (w = this.services.cartesianScales.getDomainValue(S.datum) - 16 / 2, L = w + 16, O = this.services.cartesianScales.getRangeValue(S.value), k = c), ie(
          { x0: w, x1: L, y0: O, y1: k },
          this.services.cartesianScales.getOrientation()
        );
      }).attr("opacity", 1);
    }, h = () => {
      const m = E.appendOrSelect(n, "g.bars").selectAll("path.bar").data(a, (v) => v[s]);
      m.exit().attr("opacity", 0).remove(), m.enter().append("path").attr("opacity", 0).merge(m).classed("bar", !0).transition().call(
        (v) => this.services.transitions.setupTransition({
          transition: v,
          name: "bullet-bar-update-enter",
          animate: e
        })
      ).attr(
        "class",
        (v) => this.model.getColorClassName({
          classNameTypes: [$.FILL],
          dataGroupName: v[s],
          originalClassName: "bar"
        })
      ).style("fill", (v) => this.model.getFillColor(v[s])).attr("d", (v) => {
        const T = this.services.cartesianScales.getDomainValue(v) - 4, w = T + 8, L = this.services.cartesianScales.getRangeValue(0) + 1, O = this.services.cartesianScales.getRangeValue(v);
        return ie(
          { x0: T, x1: w, y0: L, y1: O },
          this.services.cartesianScales.getOrientation()
        );
      }).attr("opacity", 1).attr("role", U.GRAPHICS_SYMBOL).attr("aria-roledescription", "bar").attr("aria-label", (v) => v.value);
    }, u = () => {
      const m = E.appendOrSelect(n, "g.markers").selectAll("path.marker").data(
        a.filter((v) => y(v, "marker") !== null),
        (v) => v[s]
      );
      m.exit().attr("opacity", 0).remove(), m.enter().append("path").attr("opacity", 0).merge(m).classed("marker", !0).transition().call(
        (v) => this.services.transitions.setupTransition({
          transition: v,
          name: "bullet-marker-update-enter",
          animate: e
        })
      ).attr("d", (v) => {
        const T = this.services.cartesianScales.getDomainValue(v) - 12, w = T + 24, L = this.services.cartesianScales.getRangeValue(v.marker);
        return ie(
          { x0: T, x1: w, y0: L, y1: L },
          this.services.cartesianScales.getOrientation()
        );
      }).attr("opacity", 1);
    }, g = () => {
      let m = [];
      a.filter((S) => y(S, "marker") !== null).forEach((S) => {
        const T = S.marker, w = S[r];
        m = m.concat([
          { datum: S, value: T * 0.25, barValue: w },
          { datum: S, value: T * 0.5, barValue: w },
          { datum: S, value: T * 0.75, barValue: w }
        ]);
      });
      const b = E.appendOrSelect(n, "g.quartiles").selectAll("path.quartile").data(m, (S) => S[s]);
      b.exit().attr("opacity", 0).remove(), b.enter().append("path").attr("opacity", 0).merge(b).attr("class", (S) => `quartile ${S.value <= S.barValue ? "over-bar" : ""}`).transition().call(
        (S) => this.services.transitions.setupTransition({
          transition: S,
          name: "bullet-quartile-update-enter",
          animate: e
        })
      ).attr("d", ({ datum: S, value: T }) => {
        let w = 4;
        S.ranges && S.ranges.indexOf(T) !== -1 && (w = 8);
        const L = this.services.cartesianScales.getDomainValue(S) - w / 2, O = L + w, k = this.services.cartesianScales.getRangeValue(T);
        return ie(
          { x0: L, x1: O, y0: k, y1: k },
          this.services.cartesianScales.getOrientation()
        );
      }).attr("opacity", 1);
    };
    p(), h(), u(), g(), this.addEventListeners();
  }
  addEventListeners() {
    const e = this, t = this.getOptions(), { groupMapsTo: s } = t.data, n = this.services.cartesianScales.getRangeIdentifier();
    this.parent.selectAll("path.bar").on("mouseover", function(a, i) {
      const r = x(this);
      r.classed("hovered", !0), e.services.events.dispatchEvent(f.Bar.BAR_MOUSEOVER, {
        event: a,
        element: r,
        datum: i
      });
      const l = y(t, "bullet", "performanceAreaTitles"), c = e.model.getMatchingRangeIndexForDatapoint(i);
      e.services.events.dispatchEvent(f.Tooltip.SHOW, {
        event: a,
        hoveredElement: r,
        items: [
          {
            label: t.tooltip.groupLabel || "Group",
            value: i[s],
            class: e.model.getColorClassName({
              classNameTypes: [$.TOOLTIP],
              dataGroupName: i[s]
            })
          },
          {
            label: "Value",
            value: i[n]
          },
          {
            label: "Target",
            value: i.marker
          },
          {
            label: "Percentage",
            value: `${Math.floor(i[n] / i.marker * 100)}%`
          },
          {
            label: "Performance",
            value: l[c]
          }
        ]
      });
    }).on("mousemove", function(a, i) {
      e.services.events.dispatchEvent(f.Bar.BAR_MOUSEMOVE, {
        event: a,
        element: x(this),
        datum: i
      }), e.services.events.dispatchEvent(f.Tooltip.MOVE, {
        event: a
      });
    }).on("click", function(a, i) {
      e.services.events.dispatchEvent(f.Bar.BAR_CLICK, {
        event: a,
        element: x(this),
        datum: i
      });
    }).on("mouseout", function(a, i) {
      const r = x(this);
      r.classed("hovered", !1), e.services.events.dispatchEvent(f.Bar.BAR_MOUSEOUT, {
        event: a,
        element: r,
        datum: i
      }), e.services.events.dispatchEvent(f.Tooltip.HIDE, {
        hoveredElement: r
      });
    });
  }
  destroy() {
    this.parent.selectAll("path.bar").on("mouseover", null).on("mousemove", null).on("mouseout", null);
    const e = this.services.events;
    e.removeEventListener(f.Legend.ITEM_HOVER, this.handleLegendOnHover), e.removeEventListener(f.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
}
function cr(o) {
  return o;
}
function dr(o) {
  if (o == null)
    return cr;
  var e, t, s = o.scale[0], n = o.scale[1], a = o.translate[0], i = o.translate[1];
  return function(r, l) {
    l || (e = t = 0);
    var c = 2, d = r.length, p = new Array(d);
    for (p[0] = (e += r[0]) * s + a, p[1] = (t += r[1]) * n + i; c < d; )
      p[c] = r[c], ++c;
    return p;
  };
}
function hr(o, e) {
  for (var t, s = o.length, n = s - e; n < --s; )
    t = o[n], o[n++] = o[s], o[s] = t;
}
function ur(o, e) {
  return typeof e == "string" && (e = o.objects[e]), e.type === "GeometryCollection" ? { type: "FeatureCollection", features: e.geometries.map(function(t) {
    return ds(o, t);
  }) } : ds(o, e);
}
function ds(o, e) {
  var t = e.id, s = e.bbox, n = e.properties == null ? {} : e.properties, a = Bt(o, e);
  return t == null && s == null ? { type: "Feature", properties: n, geometry: a } : s == null ? { type: "Feature", id: t, properties: n, geometry: a } : { type: "Feature", id: t, bbox: s, properties: n, geometry: a };
}
function Bt(o, e) {
  var t = dr(o.transform), s = o.arcs;
  function n(d, p) {
    p.length && p.pop();
    for (var h = s[d < 0 ? ~d : d], u = 0, g = h.length; u < g; ++u)
      p.push(t(h[u], u));
    d < 0 && hr(p, g);
  }
  function a(d) {
    return t(d);
  }
  function i(d) {
    for (var p = [], h = 0, u = d.length; h < u; ++h)
      n(d[h], p);
    return p.length < 2 && p.push(p[0]), p;
  }
  function r(d) {
    for (var p = i(d); p.length < 4; )
      p.push(p[0]);
    return p;
  }
  function l(d) {
    return d.map(r);
  }
  function c(d) {
    var p = d.type, h;
    switch (p) {
      case "GeometryCollection":
        return { type: p, geometries: d.geometries.map(c) };
      case "Point":
        h = a(d.coordinates);
        break;
      case "MultiPoint":
        h = d.coordinates.map(a);
        break;
      case "LineString":
        h = i(d.arcs);
        break;
      case "MultiLineString":
        h = d.arcs.map(i);
        break;
      case "Polygon":
        h = l(d.arcs);
        break;
      case "MultiPolygon":
        h = d.arcs.map(l);
        break;
      default:
        return null;
    }
    return { type: p, coordinates: h };
  }
  return c(e);
}
function pr(o, e) {
  var t = {}, s = {}, n = {}, a = [], i = -1;
  e.forEach(function(c, d) {
    var p = o.arcs[c < 0 ? ~c : c], h;
    p.length < 3 && !p[1][0] && !p[1][1] && (h = e[++i], e[i] = c, e[d] = h);
  }), e.forEach(function(c) {
    var d = r(c), p = d[0], h = d[1], u, g;
    if (u = n[p])
      if (delete n[u.end], u.push(c), u.end = h, g = s[h]) {
        delete s[g.start];
        var m = g === u ? u : u.concat(g);
        s[m.start = u.start] = n[m.end = g.end] = m;
      } else
        s[u.start] = n[u.end] = u;
    else if (u = s[h])
      if (delete s[u.start], u.unshift(c), u.start = p, g = n[p]) {
        delete n[g.end];
        var b = g === u ? u : g.concat(u);
        s[b.start = g.start] = n[b.end = u.end] = b;
      } else
        s[u.start] = n[u.end] = u;
    else
      u = [c], s[u.start = p] = n[u.end = h] = u;
  });
  function r(c) {
    var d = o.arcs[c < 0 ? ~c : c], p = d[0], h;
    return o.transform ? (h = [0, 0], d.forEach(function(u) {
      h[0] += u[0], h[1] += u[1];
    })) : h = d[d.length - 1], c < 0 ? [h, p] : [p, h];
  }
  function l(c, d) {
    for (var p in c) {
      var h = c[p];
      delete d[h.start], delete h.start, delete h.end, h.forEach(function(u) {
        t[u < 0 ? ~u : u] = 1;
      }), a.push(h);
    }
  }
  return l(n, s), l(s, n), e.forEach(function(c) {
    t[c < 0 ? ~c : c] || a.push([c]);
  }), a;
}
function gr(o) {
  for (var e = -1, t = o.length, s, n = o[t - 1], a = 0; ++e < t; )
    s = n, n = o[e], a += s[0] * n[1] - s[1] * n[0];
  return Math.abs(a);
}
function mr(o) {
  return Bt(o, fr.apply(this, arguments));
}
function fr(o, e) {
  var t = {}, s = [], n = [];
  e.forEach(a);
  function a(l) {
    switch (l.type) {
      case "GeometryCollection":
        l.geometries.forEach(a);
        break;
      case "Polygon":
        i(l.arcs);
        break;
      case "MultiPolygon":
        l.arcs.forEach(i);
        break;
    }
  }
  function i(l) {
    l.forEach(function(c) {
      c.forEach(function(d) {
        (t[d = d < 0 ? ~d : d] || (t[d] = [])).push(l);
      });
    }), s.push(l);
  }
  function r(l) {
    return gr(Bt(o, { type: "Polygon", arcs: [l] }).coordinates[0]);
  }
  return s.forEach(function(l) {
    if (!l._) {
      var c = [], d = [l];
      for (l._ = 1, n.push(c); l = d.pop(); )
        c.push(l), l.forEach(function(p) {
          p.forEach(function(h) {
            t[h < 0 ? ~h : h].forEach(function(u) {
              u._ || (u._ = 1, d.push(u));
            });
          });
        });
    }
  }), s.forEach(function(l) {
    delete l._;
  }), {
    type: "MultiPolygon",
    arcs: n.map(function(l) {
      var c = [], d;
      if (l.forEach(function(m) {
        m.forEach(function(b) {
          b.forEach(function(v) {
            t[v < 0 ? ~v : v].length < 2 && c.push(v);
          });
        });
      }), c = pr(o, c), (d = c.length) > 1)
        for (var p = 1, h = r(c[0]), u, g; p < d; ++p)
          (u = r(c[p])) > h && (g = c[0], c[0] = c[p], c[p] = g, h = u);
      return c;
    }).filter(function(l) {
      return l.length > 0;
    })
  };
}
class xc extends Xs {
  constructor() {
    super(...arguments), this.type = "ruler-binned", this.renderType = H.SVG;
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  showRuler(e, [t, s]) {
    const n = this.parent, a = this.model.getOptions(), { cartesianScales: i } = this.services, r = i.getOrientation(), l = i.getRangeScale(), [c, d] = l.range(), p = i.getDomainScale(), h = p.invert(
      r === le.VERTICAL ? t : s
    ), u = E.appendOrSelect(n, "g.ruler").attr("aria-label", "ruler"), g = E.appendOrSelect(u, "line.ruler-line"), b = n.selectAll("[role=graphics-symbol]").filter((v) => {
      if (parseFloat(Q(v, "data.x0")) <= h && parseFloat(Q(v, "data.x1")) >= h)
        return !0;
    });
    if (b.size() > 0) {
      this.elementsToHighlight && this.elementsToHighlight.size() > 0 && !Gs(this.elementsToHighlight, b) && this.hideRuler(), b.dispatch("mouseover"), this.elementsToHighlight = b;
      const v = x(b.nodes()[0]).datum(), S = parseFloat(Q(v, "data.x0")), T = parseFloat(Q(v, "data.x1")), w = this.model.getActiveDataGroupNames(), L = w.reverse().map((k) => ({
        label: k,
        value: Q(v, `data.${k}`),
        class: this.model.getColorClassName({
          classNameTypes: [$.TOOLTIP],
          dataGroupName: k
        })
      })).filter((k) => k.value !== 0);
      if (L.length > 0) {
        this.services.events.dispatchEvent(f.Tooltip.SHOW, {
          mousePosition: [t, s],
          hoveredElement: g,
          items: [
            {
              label: Q(a, "bins.rangeLabel") || "Range",
              value: `${S} – ${T}`
            },
            ...L,
            ...y(a, "tooltip", "showTotal") === !0 ? [
              {
                label: Q(a, "tooltip.totalLabel") || "Total",
                value: w.reduce(
                  (I, F) => I + parseFloat(Q(v, `data.${F}`)),
                  0
                )
              }
            ] : []
          ]
        }), u.attr("opacity", 1);
        const k = p((S + T) / 2);
        r === "horizontal" ? g.attr("x1", d).attr("x2", c).attr("y1", k).attr("y2", k) : g.attr("y1", d).attr("y2", c).attr("x1", k).attr("x2", k);
      } else
        this.hideRuler();
    } else
      this.hideRuler();
  }
}
class Oc extends Xs {
  formatTooltipData(e) {
    return e.reverse();
  }
}
const Tc = (o, e) => {
  const t = o.x, s = o.y, n = e.x, a = e.y, i = Dt();
  return i.moveTo(t, s), i.lineTo(n, a), i.toString();
}, Lc = (o, e, t = 0.5) => {
  const s = o.x, n = o.y, a = e.x, i = e.y, r = Dt();
  return r.moveTo(s, n), r.lineTo(s + (a - s) * t, n), r.lineTo(s + (a - s) * t, i), r.lineTo(a, i), r.toString();
}, wc = (o, e, t, s, n, a) => {
  const i = o.x, r = o.y, l = e.x, c = e.y, d = Dt();
  return d.moveTo(i, r), d.bezierCurveTo(t, s, n, a, l, c), d.toString();
}, Mc = {
  d: "M7 0v8L0 4z",
  height: 8,
  width: 7.5,
  id: "arrowLeft"
}, Ac = {
  d: "M0 0v8l7-4z",
  height: 8,
  width: 7.5,
  id: "arrowRight"
}, Cc = {
  d: "M5.32 9.513a4.75 4.75 0 100-9.5 4.75 4.75 0 000 9.5z",
  height: 10,
  width: 10,
  id: "circle"
}, kc = {
  d: "M5.03517654-1e-7l4.99999996 5-4.99999996 5-5-5L2.4517844 2.58339204z",
  height: 10,
  width: 10,
  id: "diamond"
}, Ic = {
  d: "M0 .44974747h8v8H0v-3.6830331z",
  height: 9,
  width: 8,
  id: "square"
}, Rc = {
  d: "M0 0h1.5v8H0z",
  height: 8,
  width: 2,
  id: "tee"
};
class Dc extends nr {
  constructor(e, t, s) {
    super(e, t, s), this.type = "color-legend", this.renderType = H.SVG, this.gradient_id = `gradient-id-${Math.floor(Math.random() * 99999999999)}`, this.handleAxisCompleteEvent = () => {
      const n = this.getComponentContainer(), { width: a } = E.getSVGElementSize(n, {
        useAttrs: !0
      }), i = y(this.getOptions(), "data", "loading");
      if (a > K.color.barWidth && !i) {
        const r = y(this.getOptions(), "heatmap", "colorLegend", "title"), { cartesianScales: l } = this.services, d = l.getMainXScale().range();
        if (d[0] > 1 && (n.select("g.legend").attr("transform", `translate(${d[0]}, 0)`), r)) {
          const { width: p } = E.getSVGElementSize(
            n.select("g.legend-title").select("text"),
            { useBBox: !0 }
          ), h = d[0] - p - 9;
          h > 1 ? n.select("g.legend-title").attr("transform", `translate(${h}, 0)`) : (n.select("g.legend").attr("transform", `translate(${d[0]}, 16)`), n.select("g.legend-title").attr("transform", `translate(${d[0]}, 0)`));
        }
      } else
        n.select("g.legend-title").attr("transform", "translate(0, 0)");
    }, this.chartType = s.chartType;
  }
  init() {
    this.chartType === "heatmap" && this.services.events.addEventListener(
      f.Axis.RENDER_COMPLETE,
      this.handleAxisCompleteEvent
    );
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(e = !1) {
    const t = this.getOptions(), s = this.getComponentContainer(), { width: n } = E.getSVGElementSize(s, {
      useAttrs: !0
    }), a = y(t, "color", "gradient", "colors"), i = y(
      t,
      this.chartType,
      "colorLegend",
      "type"
    );
    let r = y(t, "color", "pairing", "option");
    const l = y(t, "heatmap", "colorLegend", "title");
    if (y(this.getOptions(), "data", "loading")) {
      s.html("");
      return;
    }
    const d = !Os(a), p = In(this.model.getDisplayData()), h = !(n <= K.color.barWidth), u = h ? K.color.barWidth : n, g = E.appendOrSelect(s, "g.legend"), m = E.appendOrSelect(g, "g.legend-axis");
    if (l) {
      const I = E.appendOrSelect(s, "g.legend-title");
      E.appendOrSelect(I, "text").text(l).attr("dy", "0.7em"), g.attr("transform", "translate(0, 16)");
    }
    const b = p[0] < 0 && p[1] > 0 ? "diverge" : "mono";
    (r < 1 && r > 4 && b === "mono" || r < 1 && r > 2 && b === "diverge") && (r = 1);
    let v = [];
    const S = b === "diverge" ? 17 : 11;
    if (d)
      v = a;
    else
      for (let I = 1; I < S + 1; I++)
        v.push(
          i === at.LINEAR ? `stop-color-${b}-${r}-${I}` : `fill-${b}-${r}-${I}`
        );
    const T = vs(p[0], p[1]), w = en(T, 3), L = Oe().domain(p).range([0, u]), O = Rt(L).tickSize(0).tickValues(w);
    let k;
    switch (i) {
      case at.LINEAR:
        this.drawLinear(v, g, u);
        break;
      case at.QUANTIZE:
        k = this.drawQuantize(
          v,
          b,
          d,
          g,
          u
        ), L.range([k, u]);
        break;
      default:
        throw Error("Entered color legend type is not supported.");
    }
    m.attr("transform", `translate(0,${K.color.axisYTranslation})`).call(O), m.select(".domain").remove(), m.select("g.tick:last-of-type text").style("text-anchor", h ? "middle" : "end"), m.select("g.tick:first-of-type text").style(
      "text-anchor",
      h && this.chartType !== "choropleth" ? "middle" : "start"
    );
  }
  // Renders gradient legend
  drawLinear(e, t, s) {
    const n = 100 / (e.length - 1);
    E.appendOrSelect(t, "linearGradient").attr("id", `${this.gradient_id}-legend`).selectAll("stop").data(e).enter().append("stop").attr("offset", (r, l) => `${l * n}%`).attr("class", (r, l) => e[l]).attr("stop-color", (r) => r), E.appendOrSelect(t, "rect").attr("width", s).attr("height", K.color.barHeight).style("fill", `url(#${this.gradient_id}-legend)`);
  }
  /**
   * Renders quantized legend
   * @returns number (range start)
   */
  drawQuantize(e, t, s, n, a) {
    !s && t === "diverge" && e.splice(e.length / 2, 1);
    const i = _t().domain(e).range([0, a]);
    return E.appendOrSelect(n, "g.quantized-rect").selectAll("rect").data(i.domain()).join("rect").attr("x", (l) => i(l)).attr("y", 0).attr("width", Math.max(0, i.bandwidth() - 1)).attr("height", K.color.barHeight).attr("class", (l) => l).attr("fill", (l) => l), (!s && t) === "mono" ? i.bandwidth() - 1 : 0;
  }
  destroy() {
    this.chartType === "heatmap" && this.services.events.removeEventListener(
      f.Axis.RENDER_COMPLETE,
      this.handleAxisCompleteEvent
    );
  }
}
class _c extends sr {
  constructor() {
    super(...arguments), this.type = "meter-title", this.renderType = H.SVG;
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(e = !1) {
    const t = y(this.model.getDisplayData(), 0), s = this.getOptions(), n = this.getComponentContainer(), { groupMapsTo: a } = s.data;
    if (y(s, "meter", "proportional"))
      this.displayTotal(), this.displayBreakdownTitle();
    else {
      const c = n.selectAll("text.meter-title").data([t[a]]);
      c.enter().append("text").classed("meter-title", !0).merge(c).attr("x", 0).attr("y", "1em").text((d) => d), c.exit().remove(), this.appendPercentage();
    }
    this.displayStatus();
    const r = this.getMaxTitleWidth(), l = E.appendOrSelect(n, "text.meter-title");
    r > 0 && l.node().getComputedTextLength() > r && this.truncateTitle(l, r);
  }
  displayBreakdownTitle() {
    const e = this.getComponentContainer(), t = this.getOptions(), s = this.model.getMaximumDomain(this.model.getDisplayData()), n = y(t, "meter", "proportional", "total"), a = y(t, "meter", "proportional", "unit") ? y(t, "meter", "proportional", "unit") : "";
    let i;
    if (s === n)
      i = null;
    else {
      const d = n !== null ? n - s : s, p = y(t, "meter", "proportional", "breakdownFormatter");
      i = p !== null ? p({
        datasetsTotal: s,
        total: n
      }) : `${s} ${a} used (${d} ${a} available)`;
    }
    const r = e.selectAll("text.proportional-meter-title").data([i]);
    r.enter().append("text").classed("proportional-meter-title", !0).merge(r).attr("x", 0).attr("y", "1em").text((d) => d), r.exit().remove();
    const l = this.getMaxTitleWidth(), c = E.appendOrSelect(e, "text.proportional-meter-title");
    l > 0 && c.node().getComputedTextLength() > l && this.truncateTitle(c, l);
  }
  // show the total for prop meter
  displayTotal() {
    const e = this.getComponentContainer(), t = this.getOptions(), s = y(t, "meter", "proportional", "total"), n = s ? y(t, "meter", "proportional", "total") : this.model.getMaximumDomain(this.model.getDisplayData()), a = y(t, "meter", "proportional", "unit") ? y(t, "meter", "proportional", "unit") : "", i = y(t, "meter", "proportional", "totalFormatter"), r = i !== null ? i(n) : `${s} ${a} total`, l = E.getHTMLElementSize(this.services.domUtils.getMainContainer()), c = l.width ? l.width : this.parent.node().getAttribute("width"), d = e.selectAll("text.proportional-meter-total").data([r]);
    d.enter().append("text").classed("proportional-meter-total", !0).merge(d).attr(
      "x",
      this.model.getStatus() && typeof c != "string" ? c - se.total.paddingRight : c
    ).attr("y", "1em").attr("text-anchor", "end").text((p) => p), d.exit().remove();
  }
  /**
   * Appends the corresponding status based on the value and the peak.
   */
  displayStatus() {
    const e = this, t = this.getComponentContainer(), s = E.getHTMLElementSize(this.services.domUtils.getMainContainer()), n = s.width ? s.width : 0, a = this.model.getStatus(), i = se.status.indicatorSize / 2, r = E.appendOrSelect(t, "g.status-indicator").attr("class", a !== null ? `status-indicator status--${a}` : "").attr("transform", `translate(${n - i}, 0)`), l = a ? [a] : [], c = r.selectAll("circle.status").data(l);
    c.enter().append("circle").merge(c).attr("class", "status").attr("r", i).attr("cx", 0).attr("cy", 8);
    const d = r.selectAll("path.innerFill").data(l);
    d.enter().append("path").merge(d).attr("d", e.getStatusIconPathString(a)).attr("transform", `translate(-${i}, 0)`).attr("class", "innerFill"), d.exit().remove(), c.exit().remove();
  }
  /**
   * Appends the associated percentage to the end of the title
   */
  appendPercentage() {
    const e = y(this.model.getDisplayData(), 0, "value"), t = this.getComponentContainer(), s = E.appendOrSelect(t, "text.meter-title"), n = y(this.getOptions(), "meter", "statusBar", "percentageIndicator", "enabled") === !0 ? [e] : [], a = t.selectAll("text.percent-value").data(n), i = se.statusBar.paddingRight;
    a.enter().append("text").classed("percent-value", !0).merge(a).text((r) => `${r}%`).attr("x", +s.attr("x") + s.node().getComputedTextLength() + i).attr("y", s.attr("y")), a.exit().remove();
  }
  /**
   * Uses the parent class truncate logic
   * @param title d3 selection of title element that will be truncated
   * @param titlestring the original string that needs truncation
   * @param maxWidth the max width the title can take
   */
  truncateTitle(e, t) {
    super.truncateTitle(e, t);
    const s = E.appendOrSelect(this.parent, "tspan"), n = se.statusBar.paddingRight, a = Math.ceil(s.node().getComputedTextLength());
    E.appendOrSelect(this.parent, "text.percent-value").attr(
      "x",
      +e.attr("x") + e.node().getComputedTextLength() + a + n
    );
  }
  // computes the maximum space a title can take
  getMaxTitleWidth() {
    const e = E.getHTMLElementSize(this.services.domUtils.getMainContainer()), t = y(this.getOptions(), "meter", "proportional"), s = e.width ? e.width : this.parent.node().getBoundingClientRect().width;
    if (t !== null) {
      const n = E.appendOrSelect(this.parent, "text.proportional-meter-total").node(), a = E.getSVGElementSize(n, {
        useBBox: !0
      }).width;
      return s - a - se.total.paddingLeft;
    } else {
      const n = E.appendOrSelect(this.parent, "text.percent-value"), a = se.statusBar.paddingRight, i = n.node().getComputedTextLength(), r = E.appendOrSelect(this.parent, "g.status-indicator").node(), l = E.getSVGElementSize(r, { useBBox: !0 }).width + se.status.paddingLeft;
      return s - i - a - l;
    }
  }
  /**
   * Get the associated status icon for the data
   * @param status the active status for the meter chart
   */
  getStatusIconPathString(e) {
    switch (e) {
      case it.SUCCESS:
        return "M6.875 11.3125 3.75 8.1875 4.74375 7.25 6.875 9.34375 11.50625 4.75 12.5 5.7375 Z";
      case it.DANGER:
        return "M10.7 11.5 4.5 5.3 5.3 4.5 11.5 10.7 Z";
      case it.WARNING:
        return "M7.9375,11.125 C7.41973305,11.125 7,11.544733 7,12.0625 C7,12.580267 7.41973305,13 7.9375,13 C8.45526695,13 8.875,12.580267 8.875,12.0625 C8.875,11.544733 8.45526695,11.125 7.9375,11.125 M7.3125, 3 8.5625, 3 8.5625, 9.875 7.3125, 9.875, 7.3125, 3 Z";
    }
  }
}
class $t extends z {
  // Gets the correct width for bars based on options & configurations
  getBarWidth() {
    const e = this.getOptions();
    if (e.bars.width)
      return e.bars.width;
    const t = this.model.getDisplayData().length, s = this.services.cartesianScales.getMainXScale(), n = E.getSVGElementSize(this.parent, {
      useAttrs: !0
    }).width;
    if (!s.step) {
      const a = y(e, "bars", "spacingFactor");
      return Math.min(e.bars.maxWidth, n * a / t);
    }
    return Math.min(e.bars.maxWidth, s.step() / 2);
  }
  isOutsideZoomedDomain(e, t) {
    if (this.model.getDisplayData().length <= 1)
      return !1;
    const n = this.model.get("zoomDomain");
    if (n !== void 0) {
      const a = this.services.cartesianScales.getDomainScale();
      return e < a(n[0]) || t > a(n[1]);
    }
    return !1;
  }
}
class Pc extends z {
  constructor() {
    super(...arguments), this.type = "circle-pack", this.renderType = H.SVG, this.handleLegendOnHover = (e) => {
      const { hoveredElement: t } = e.detail;
      this.parent.selectAll("circle.node").transition("legend-hover-circlepack").call(
        (s) => this.services.transitions.setupTransition({
          transition: s,
          name: "legend-hover-circlepack"
        })
      ).attr("opacity", (s) => s.data.dataGroupName === t.datum().name ? 1 : Pe.circles.fillOpacity);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("circle.node").transition("legend-mouseout-circlepack").call(
        (e) => this.services.transitions.setupTransition({
          transition: e,
          name: "legend-mouseout-circlepack"
        })
      ).attr("opacity", 1);
    };
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(e = !0) {
    const t = this.getComponentContainer({ withinChartClip: !0 }), { width: s, height: n } = E.getSVGElementSize(this.parent, {
      useAttrs: !0
    });
    if (s < 1 || n < 1)
      return;
    let a = this.model.getDisplayData();
    const i = this.model.hasParentNode(), r = this.model.getHierarchyLevel(), l = this.getOptions(), c = y(l, "canvasZoom", "enabled");
    i && y(a, 0, "children") && (a = y(a, 0, "children"));
    const d = Pt({ children: a }).sum((m) => m.value).sort((m, b) => b.value - m.value), h = tn().size([s, n]).padding((m) => m.depth >= 1 ? Pe.padding.children + 3 : Pe.padding.mainGroup + 3)(d).descendants().splice(1).filter((m) => m.depth <= r), u = t.selectAll("circle.node").data(h);
    u.exit().attr("width", 0).attr("height", 0).remove();
    const g = u.enter().append("circle").classed("node", !0);
    g.merge(u).attr("class", (m) => {
      const b = c && r === 3 ? this.getZoomClass(m) : "";
      return this.model.getColorClassName({
        classNameTypes: [$.FILL, $.STROKE],
        dataGroupName: m.data.dataGroupName,
        originalClassName: m.children ? `node ${b}` : `node node-leaf ${b}`
      });
    }).style("fill", (m) => this.model.getFillColor(m.data.dataGroupName)).style("stroke", (m) => this.model.getFillColor(m.data.dataGroupName)).attr("cx", (m) => m.x).attr("cy", (m) => m.y).transition("circlepack-leaf-update-enter").call(
      (m) => this.services.transitions.setupTransition({
        transition: m,
        name: "circlepack-leaf-update-enter"
      })
    ).attr("r", (m) => m.r).attr("opacity", 1).attr("fill-opacity", Pe.circles.fillOpacity), c === !0 && this.focal && (this.services.canvasZoom.zoomIn(this.focal, g, He), this.setBackgroundListeners()), i || this.addLegendListeners(), this.addEventListeners();
  }
  // turn off the highlight class on children circles
  unhighlightChildren(e) {
    const t = e.map((s) => s.data);
    this.parent.selectAll("circle.node").filter((s) => t.some((n) => n === s.data) && s.depth > 1).style("stroke", (s) => this.model.getFillColor(s.data.dataGroupName));
  }
  // highlight the children circles with a stroke
  highlightChildren(e) {
    const t = e.map((s) => s.data);
    this.parent.selectAll("circle.node").filter((s) => t.some((n) => n === s.data) && s.depth > 1).style("stroke", Pe.circles.hover.stroke);
  }
  getZoomClass(e) {
    return this.model.getHierarchyLevel() === 3 && this.focal && (e.data === this.focal.data || this.focal.children.some((t) => t.data === e.data)) ? "focal" : "non-focal";
  }
  addLegendListeners() {
    const { events: e } = this.services;
    e.addEventListener(f.Legend.ITEM_HOVER, this.handleLegendOnHover), e.addEventListener(f.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  removeBackgroundListeners() {
    x(this.services.domUtils.getMainContainer()).on("click", () => null);
  }
  setBackgroundListeners() {
    const e = x(this.services.domUtils.getMainContainer()), t = this, s = this.parent.selectAll("circle.node");
    e.on("click", () => {
      t.focal = null, t.model.updateHierarchyLevel(2), e.classed("zoomed-in", !1), t.services.canvasZoom.zoomOut(s, He);
    });
  }
  // Zoom icon to be appended to the label in the tooltip
  getZoomIcon() {
    return `
		<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 10 10">
			<polygon points="5.93 3.71 4.45 3.71 4.45 2.23 3.71 2.23 3.71 3.71 2.23 3.71 2.23 4.45 3.71 4.45 3.71 5.93 4.45 5.93 4.45 4.45 5.93 4.45 5.93 3.71"/>
			<path d="M7.2,6.67a4,4,0,0,0,1-2.59A4.08,4.08,0,1,0,4.07,8.15h0a4,4,0,0,0,2.59-1L9.48,10,10,9.48Zm-3.12.77A3.34,3.34,0,1,1,7.41,4.08,3.34,3.34,0,0,1,4.08,7.44Z"/>
		</svg>`;
  }
  // add event listeners for tooltip on the circles
  addEventListeners() {
    const e = this;
    this.parent.selectAll("circle.node").on("mouseover", function(t, s) {
      const n = x(this);
      n.classed("hovered", !0);
      const a = e.model.getHierarchyLevel(), i = a > 2 && !n.classed("focal"), r = y(e.model.getOptions(), "canvasZoom", "enabled");
      let l = !1;
      if (!i) {
        let c = [], d = [], p = null;
        if (s.children) {
          s.depth > 1 && r && (l = !0, n.classed("clickable", !0)), c = s.children.map((g) => {
            if (g !== null)
              return typeof g.data.value == "number" ? {
                label: g.data.name,
                value: g.data.value
              } : {
                label: g.data.name,
                labelIcon: r && a <= 2 ? e.getZoomIcon() : null,
                value: g.value
              };
          });
          const u = e.model.getOptions();
          d = [
            {
              label: Q(u, "tooltip.totalLabel") || "Total",
              value: s.value,
              bold: !0
            }
          ], e.highlightChildren(s.children);
        } else
          p = s.value;
        const h = getComputedStyle(this, null).getPropertyValue("fill");
        e.services.events.dispatchEvent(f.Tooltip.SHOW, {
          event: t,
          hoveredElement: n,
          items: [
            {
              color: h,
              label: s.data.name,
              labelIcon: l && r && a <= 2 ? e.getZoomIcon() : null,
              value: p
            },
            ...c,
            ...d
          ]
        });
      }
      e.services.events.dispatchEvent(f.CirclePack.CIRCLE_MOUSEOVER, {
        event: t,
        element: n,
        datum: s
      });
    }).on("mousemove", function(t, s) {
      const n = x(this);
      e.services.events.dispatchEvent(f.CirclePack.CIRCLE_MOUSEMOVE, {
        event: t,
        element: n,
        datum: s
      }), e.services.events.dispatchEvent(f.Tooltip.MOVE, {
        event: t
      });
    }).on("mouseout", function(t, s) {
      const n = x(this);
      n.classed("hovered", !1), s.children && e.unhighlightChildren(s.children), e.services.events.dispatchEvent(f.CirclePack.CIRCLE_MOUSEOUT, {
        event: t,
        element: n,
        datum: s
      }), e.services.events.dispatchEvent(f.Tooltip.HIDE, {
        hoveredElement: n
      });
    }).on("click", function(t, s) {
      const n = x(this), a = n.classed("non-focal"), i = y(e.model.getOptions(), "canvasZoom", "enabled");
      if (i && e.model.getHierarchyLevel() > 2) {
        const r = e.parent.selectAll("circle.node");
        x(e.services.domUtils.getMainContainer()).classed("zoomed-in", !1), e.focal = null, e.model.updateHierarchyLevel(2), e.services.canvasZoom.zoomOut(r, He);
      } else if (s.depth === 2 && s.children && !a && i) {
        const r = e.parent.selectAll("circle.node");
        x(e.services.domUtils.getMainContainer()).classed("zoomed-in", !0), e.focal = s, e.model.updateHierarchyLevel(3), e.services.canvasZoom.zoomIn(s, r, He), t.stopPropagation();
      }
      e.services.events.dispatchEvent(f.CirclePack.CIRCLE_CLICK, {
        event: t,
        element: n,
        datum: s
      });
    });
  }
  destroy() {
    this.parent.selectAll("circle.node").on("mouseover", null).on("mousemove", null).on("mouseout", null).on("click", null);
    const e = this.services.events;
    e.removeEventListener(f.Legend.ITEM_HOVER, this.handleLegendOnHover), e.removeEventListener(f.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut), this.removeBackgroundListeners();
  }
}
function vr(o, e) {
  const t = nn(this._current, o);
  return (s) => (this._current = t(s), e(this._current));
}
class yr extends z {
  constructor() {
    super(...arguments), this.type = "pie", this.renderType = H.SVG, this.handleLegendOnHover = (e) => {
      const { hoveredElement: t } = e.detail, { groupMapsTo: s } = this.getOptions().data;
      this.parent.selectAll("path.slice").transition("legend-hover-bar").call(
        (n) => this.services.transitions.setupTransition({
          transition: n,
          name: "legend-hover-bar"
        })
      ).attr(
        "opacity",
        (n) => n.data[s] !== t.datum().name ? 0.3 : 1
      );
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("path.slice").transition("legend-mouseout-bar").call(
        (e) => this.services.transitions.setupTransition({
          transition: e,
          name: "legend-mouseout-bar"
        })
      ).attr("opacity", 1);
    };
  }
  init() {
    const e = this.services.events;
    e.addEventListener(f.Legend.ITEM_HOVER, this.handleLegendOnHover), e.addEventListener(f.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  getInnerRadius() {
    return Z.innerRadius;
  }
  render(e = !0) {
    const t = this, s = this.getComponentContainer(), n = this.getOptions(), { groupMapsTo: a } = n.data, { valueMapsTo: i } = n.pie, r = this.model.getDisplayData().filter((M) => M[i] > 0), l = this.computeRadius();
    this.arc = $e().innerRadius(this.getInnerRadius()).outerRadius(l), this.hoverArc = $e().innerRadius(this.getInnerRadius()).outerRadius(l + Z.hoverArc.outerRadiusOffset);
    const d = sn().value((M) => M[i]).sort(y(n, "pie", "sortFunction")).padAngle(Z.padAngle)(r), h = E.appendOrSelect(s, "g.slices").attr("role", U.GROUP).attr("data-name", "slices").selectAll("path.slice").data(d, (M) => M.data[a]);
    h.exit().attr("opacity", 0).remove(), h.enter().append("path").classed("slice", !0).attr("opacity", 0).merge(h).attr(
      "class",
      (M) => this.model.getColorClassName({
        classNameTypes: [$.FILL],
        dataGroupName: M.data[a],
        originalClassName: "slice"
      })
    ).style("fill", (M) => t.model.getFillColor(M.data[a])).attr("d", this.arc).transition().call(
      (M) => this.services.transitions.setupTransition({
        transition: M,
        name: "pie_slice_enter_update",
        animate: e
      })
    ).attr("opacity", 1).attr("role", U.GRAPHICS_SYMBOL).attr("aria-roledescription", "slice").attr(
      "aria-label",
      (M) => `${M[i]}, ${zt(M.data[i], r, i) + "%"}`
    ).attrTween("d", function(M) {
      return vr.bind(this)(M, t.arc);
    });
    const m = n.pie.labels.enabled, b = m ? d.filter((M) => M.data[i] > 0) : [], S = E.appendOrSelect(s, "g.labels").attr("role", U.GROUP).attr("data-name", "labels").selectAll("text.pie-label").data(b, (M) => M.data[a]);
    S.exit().attr("opacity", 0).remove();
    const T = S.enter().append("text").classed("pie-label", !0), w = [];
    T.merge(S).style("text-anchor", "middle").text((M) => n.pie.labels.formatter ? n.pie.labels.formatter(M) : zt(M.data[i], r, i) + "%").datum(function(M) {
      const G = l + 7, D = (M.endAngle - M.startAngle) / 2 + M.startAngle, X = D / Math.PI * 180, re = this.getComputedTextLength();
      return M.textOffsetX = re / 2, M.textOffsetY = X > 90 && X < 270 ? 10 : 0, M.xPosition = (M.textOffsetX + G) * Math.sin(D), M.yPosition = (M.textOffsetY + G) * -Math.cos(D), M;
    }).attr("transform", function(M, G) {
      const D = b.length, X = (M.endAngle - M.startAngle) * (180 / Math.PI);
      if (G >= D - 2 && X < Z.callout.minSliceDegree) {
        let re, W;
        return M.index === D - 1 ? (re = M.xPosition + Z.callout.offsetX + Z.callout.textMargin + M.textOffsetX, W = M.yPosition - Z.callout.offsetY, M.direction = rt.RIGHT, w.push(M)) : (re = M.xPosition - Z.callout.offsetX - M.textOffsetX - Z.callout.textMargin, W = M.yPosition - Z.callout.offsetY, M.direction = rt.LEFT, w.push(M)), `translate(${re}, ${W})`;
      }
      return `translate(${M.xPosition}, ${M.yPosition})`;
    }), this.renderCallouts(w);
    const L = y(n, "donut") ? "donut" : "pie", O = y(n, L, "alignment"), { width: k } = E.getSVGElementSize(this.getParent(), {
      useAttrs: !0
    }), I = m ? Z.xOffset : 0, F = m ? Z.yOffset : 0;
    let P = l + I;
    O === ue.CENTER ? P = k / 2 : O === ue.RIGHT && (P = k - l - Z.xOffset);
    let A = l + F;
    w.length > 0 && (A += Z.yOffsetCallout), s.attr("x", P + 7).attr("y", A), this.addEventListeners();
  }
  renderCallouts(e) {
    const t = E.appendOrSelect(this.getComponentContainer(), "g.callouts").attr("role", U.GROUP).attr("data-name", "callouts"), s = t.selectAll("g.callout").data(e);
    s.exit().remove();
    const n = s.enter().append("g").classed("callout", !0).attr("role", U.GROUP).attr("aria-roledescription", "label callout");
    n.merge(s).datum(function(r) {
      const { xPosition: l, yPosition: c, direction: d } = r;
      return d === rt.RIGHT ? (r.startPos = {
        x: l,
        y: c + r.textOffsetY
      }, r.endPos = {
        x: l + Z.callout.offsetX,
        y: c - Z.callout.offsetY + r.textOffsetY
      }, r.intersectPointX = r.endPos.x - Z.callout.horizontalLineLength) : (r.startPos = {
        x: l,
        y: c + r.textOffsetY
      }, r.endPos = {
        x: l - Z.callout.offsetX,
        y: c - Z.callout.offsetY + r.textOffsetY
      }, r.intersectPointX = r.endPos.x + Z.callout.horizontalLineLength), r;
    }), n.append("line").classed("vertical-line", !0).merge(t.selectAll("line.vertical-line")).datum(function() {
      return x(this.parentNode).datum();
    }).style("stroke-width", "1px").attr("x1", (r) => r.startPos.x).attr("y1", (r) => r.startPos.y).attr("x2", (r) => r.intersectPointX).attr("y2", (r) => r.endPos.y), n.append("line").classed("horizontal-line", !0).merge(t.selectAll("line.horizontal-line")).datum(function() {
      return x(this.parentNode).datum();
    }).style("stroke-width", "1px").attr("x1", (r) => r.intersectPointX).attr("y1", (r) => r.endPos.y).attr("x2", (r) => r.endPos.x).attr("y2", (r) => r.endPos.y);
  }
  addEventListeners() {
    const e = this;
    this.parent.selectAll("path.slice").on("mouseover", function(t, s) {
      const n = x(this);
      n.classed("hovered", !0).transition("pie_slice_mouseover").call(
        (r) => e.services.transitions.setupTransition({
          transition: r,
          name: "pie_slice_mouseover"
        })
      ).attr("d", e.hoverArc), e.services.events.dispatchEvent(f.Pie.SLICE_MOUSEOVER, {
        event: t,
        element: x(this),
        datum: s
      });
      const { groupMapsTo: a } = e.getOptions().data, { valueMapsTo: i } = e.getOptions().pie;
      e.services.events.dispatchEvent(f.Tooltip.SHOW, {
        event: t,
        hoveredElement: n,
        items: [
          {
            label: s.data[a],
            value: s.data[i]
          }
        ]
      });
    }).on("mousemove", function(t, s) {
      const n = x(this);
      e.services.events.dispatchEvent(f.Pie.SLICE_MOUSEMOVE, {
        event: t,
        element: n,
        datum: s
      }), e.services.events.dispatchEvent(f.Tooltip.MOVE, {
        event: t
      });
    }).on("click", function(t, s) {
      e.services.events.dispatchEvent(f.Pie.SLICE_CLICK, {
        event: t,
        element: x(this),
        datum: s
      });
    }).on("mouseout", function(t, s) {
      const n = x(this);
      n.classed("hovered", !1).transition("pie_slice_mouseout").call(
        (a) => e.services.transitions.setupTransition({
          transition: a,
          name: "pie_slice_mouseout"
        })
      ).attr("d", e.arc), e.services.events.dispatchEvent(f.Pie.SLICE_MOUSEOUT, {
        event: t,
        element: n,
        datum: s
      }), e.services.events.dispatchEvent(f.Tooltip.HIDE, {
        hoveredElement: n
      });
    });
  }
  // Helper functions
  computeRadius() {
    const { width: e, height: t } = E.getSVGElementSize(this.parent, {
      useAttrs: !0
    }), s = this.getOptions(), n = Math.min(e, t) / 2;
    return s.pie.labels.enabled ? n + Z.radiusOffset : n;
  }
}
class Vc extends yr {
  constructor() {
    super(...arguments), this.type = "donut", this.renderType = H.SVG;
  }
  render(e = !0) {
    super.render(e);
    const t = this;
    if (this.model.isDataEmpty()) {
      this.getComponentContainer().select("g.center").remove();
      return;
    }
    const s = E.appendOrSelect(this.getComponentContainer(), "g.center"), n = this.getOptions(), a = this.computeRadius(), i = y(n, "donut", "center", "label");
    E.appendOrSelect(s, "text.donut-figure").attr("text-anchor", "middle").style("dominant-baseline", () => i === null || i === "" ? "central" : "initial").style("font-size", () => n.donut.center.numberFontSize(a)).transition().call(
      (r) => this.services.transitions.setupTransition({
        transition: r,
        name: "donut-figure-enter-update",
        animate: e
      })
    ).tween("text", function() {
      return t.centerNumberTween(x(this));
    }), i !== null && i !== "" && E.appendOrSelect(s, "text.donut-title").attr("text-anchor", "middle").style("font-size", () => n.donut.center.titleFontSize(a)).attr("y", n.donut.center.titleYPosition(a)).text(i);
  }
  getInnerRadius() {
    return this.computeRadius() * (3 / 4);
  }
  centerNumberTween(e) {
    const t = this.getOptions();
    let s = y(t, "donut", "center", "number");
    s === null && (s = this.model.getDisplayData().reduce((r, l) => r + l[t.pie.valueMapsTo], 0));
    const n = parseInt(e.text().replace(/[, ]+/g, ""), 10) || 0;
    let a;
    n % 1 === 0 && s % 1 === 0 ? a = an : a = vs;
    const i = a(n, s);
    return (r) => {
      const { numberFormatter: l } = t.donut.center;
      e.text(l(i(r)));
    };
  }
}
const hs = "4,10 8,6 12,10", us = "12,6 8,10 4,6";
class Bc extends z {
  constructor() {
    super(...arguments), this.type = "gauge", this.renderType = H.SVG;
  }
  getValue() {
    var s;
    return ((s = this.model.getData().find((n) => n.group === "value")) == null ? void 0 : s.value) ?? null;
  }
  getValueRatio() {
    return $s(this.getValue(), 0, 100) / 100;
  }
  getDelta() {
    var s;
    return ((s = this.model.getData().find((n) => n.group === "delta")) == null ? void 0 : s.value) ?? null;
  }
  getArcRatio() {
    const e = this.getOptions();
    return y(e, "gauge", "type") === ze.FULL ? 1 : 0.5;
  }
  getArcSize() {
    return this.getArcRatio() * Math.PI * 2;
  }
  getStartAngle() {
    const e = this.getArcSize();
    return e === 2 * Math.PI ? 0 : -e / 2;
  }
  // use provided arrow direction or default to using the delta
  getArrow(e) {
    const t = this.getOptions();
    switch (y(t, "gauge", "deltaArrow", "direction")) {
      case jt.UP:
        return hs;
      case jt.DOWN:
        return us;
      default:
        return e > 0 ? hs : us;
    }
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(e = !0) {
    const t = this.getComponentContainer().attr("width", "100%").attr("height", "100%"), s = this.getOptions(), n = this.getValue(), a = this.getValueRatio(), i = this.getArcSize(), r = this.getStartAngle(), l = a * i, c = r + l, d = r + i, p = this.computeRadius(), h = this.getInnerRadius();
    this.backgroundArc = $e().innerRadius(h).outerRadius(p).startAngle(c).endAngle(d), this.arc = $e().innerRadius(h).outerRadius(p).startAngle(r).endAngle(c), E.appendOrSelect(t, "path.arc-background").attr("d", this.backgroundArc);
    const u = t.selectAll("path.arc-foreground").data([n]);
    u.enter().append("path").merge(u).attr(
      "class",
      this.model.getColorClassName({
        classNameTypes: [$.FILL],
        dataGroupName: "value",
        originalClassName: "arc-foreground"
      })
    ).style("fill", () => y(this.getOptions(), "color", "scale", "value")).attr("d", this.arc).attr("role", U.GRAPHICS_SYMBOL).attr("aria-roledescription", "value").attr("aria-label", (S) => S), this.drawValueNumber(), this.drawDelta(), u.exit().remove();
    const m = y(s, "gauge", "alignment"), { width: b } = E.getSVGElementSize(this.getParent(), {
      useAttrs: !0
    });
    let v = p;
    m === ue.CENTER ? v = b / 2 : m === ue.RIGHT && (v = b - p), t.attr("x", v).attr("y", p), this.addEventListeners();
  }
  /**
   * draws the value number associated with the Gauge component in the center
   */
  drawValueNumber() {
    const e = this.getComponentContainer(), t = this.getOptions(), s = y(t, "gauge", "type"), n = this.getValue(), a = this.getDelta(), i = this.computeRadius(), r = y(t, "gauge", "valueFontSize"), l = y(t, "gauge", "deltaFontSize"), c = y(t, "gauge", "numberSpacing"), d = y(t, "gauge", "showPercentageSymbol");
    let p = 0;
    s === ze.FULL && !a ? p = l(i) : s === ze.SEMI && a && (p = -(l(i) + c));
    const h = E.appendOrSelect(e, "g.gauge-numbers").attr(
      "transform",
      `translate(0, ${p})`
    ), u = r(i), g = E.appendOrSelect(h, "g.gauge-value-number"), m = y(t, "gauge", "numberFormatter"), b = g.selectAll("text.gauge-value-number").data([n]);
    b.enter().append("text").attr("class", "gauge-value-number").merge(b).style("font-size", `${u}px`).attr("text-anchor", "middle").text((k) => m(k));
    const { width: v } = E.getSVGElementSize(
      E.appendOrSelect(e, "text.gauge-value-number"),
      { useBBox: !0 }
    ), S = u / 2, T = d ? "%" : "", w = E.appendOrSelect(g, "text.gauge-value-symbol").style("font-size", `${S}px`).attr("x", v / 2).text(T), { width: L, height: O } = E.getSVGElementSize(w, {
      useBBox: !0
    });
    w.attr("y", `-${O / 2}px`), g.attr("transform", `translate(-${L / 2}, 0)`);
  }
  /**
   * adds the delta number for the gauge
   */
  drawDelta() {
    const e = this, t = this.getComponentContainer(), s = this.getOptions(), n = this.getDelta();
    if (n) {
      const a = this.computeRadius(), i = n ? y(s, "gauge", "deltaFontSize") : () => 0, r = n ? y(s, "gauge", "numberFormatter") : () => null, l = y(s, "gauge", "deltaArrow", "size"), c = y(s, "gauge", "numberSpacing"), d = y(s, "gauge", "showPercentageSymbol"), p = E.appendOrSelect(t, "g.gauge-numbers"), h = E.appendOrSelect(p, "g.gauge-delta").attr(
        "transform",
        `translate(0, ${i(a) + c})`
      ), u = E.appendOrSelect(h, "text.gauge-delta-number"), g = d ? "%" : "";
      u.data(n === null ? [] : [n]), u.enter().append("text").classed("gauge-delta-number", !0).merge(u).attr("text-anchor", "middle").style("font-size", `${i(a)}px`).text((S) => `${r(S)}${g}`);
      const { width: m } = E.getSVGElementSize(
        E.appendOrSelect(t, ".gauge-delta-number"),
        { useBBox: !0 }
      ), b = y(s, "gauge", "deltaArrow", "enabled"), v = h.selectAll("svg.gauge-delta-arrow").data(n !== null && b ? [n] : []);
      v.enter().append("svg").merge(v).attr("class", "gauge-delta-arrow").attr("x", -l(a) - m / 2).attr("y", -l(a) / 2 - i(a) * 0.35).attr("width", l(a)).attr("height", l(a)).attr("viewBox", "0 0 16 16").each(function() {
        const S = x(this);
        E.appendOrSelect(S, "rect.gauge-delta-arrow-backdrop").attr("width", "16").attr("height", "16").attr("fill", "none");
        const T = y(s, "gauge", "status");
        E.appendOrSelect(S, "polygon.gauge-delta-arrow").attr("class", T !== null ? `gauge-delta-arrow status--${T}` : "").attr("points", e.getArrow(n));
      }), v.exit().remove(), u.exit().remove();
    } else {
      const a = t.select("g.gauge-delta");
      a.empty() || a.remove();
    }
  }
  getInnerRadius() {
    const e = this.computeRadius(), t = y(this.getOptions(), "gauge", "arcWidth");
    return e - t;
  }
  addEventListeners() {
    const e = this;
    this.parent.selectAll("path.arc-foreground").on("mouseover", function(t, s) {
      e.services.events.dispatchEvent(f.Gauge.ARC_MOUSEOVER, {
        event: t,
        element: x(this),
        datum: s
      });
    }).on("mousemove", function(t, s) {
      const n = x(this);
      e.services.events.dispatchEvent(f.Gauge.ARC_MOUSEMOVE, {
        event: t,
        element: n,
        datum: s
      });
    }).on("click", function(t, s) {
      e.services.events.dispatchEvent(f.Gauge.ARC_CLICK, {
        event: t,
        element: x(this),
        datum: s
      });
    }).on("mouseout", function(t, s) {
      const n = x(this);
      e.services.events.dispatchEvent(f.Gauge.ARC_MOUSEOUT, {
        event: t,
        element: n,
        datum: s
      });
    });
  }
  // Helper functions
  computeRadius() {
    const e = this.getOptions(), t = y(e, "gauge", "type"), { width: s, height: n } = E.getSVGElementSize(this.parent, {
      useAttrs: !0
    });
    return t === ze.SEMI ? Math.min(s / 2, n) : Math.min(s / 2, n / 2);
  }
}
class $c extends $t {
  constructor() {
    super(...arguments), this.type = "grouped-bar", this.renderType = H.SVG, this.padding = 5, this.defaultStepFactor = 70, this.handleLegendOnHover = (e) => {
      const { hoveredElement: t } = e.detail, { groupMapsTo: s } = this.getOptions().data;
      this.parent.selectAll("path.bar").transition("legend-hover-bar").call(
        (n) => this.services.transitions.setupTransition({
          transition: n,
          name: "legend-hover-bar"
        })
      ).attr("opacity", (n) => n[s] !== t.datum().name ? 0.3 : 1);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("path.bar").transition("legend-mouseout-bar").call(
        (e) => this.services.transitions.setupTransition({
          transition: e,
          name: "legend-mouseout-bar"
        })
      ).attr("opacity", 1);
    };
  }
  init() {
    const e = this.services.events;
    e.addEventListener(f.Legend.ITEM_HOVER, this.handleLegendOnHover), e.addEventListener(f.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(e) {
    const t = this.model.getDisplayData(this.configs.groups), s = this.getOptions(), { groupMapsTo: n } = s.data;
    this.setGroupScale();
    const a = this.getComponentContainer({ withinChartClip: !0 }), i = Rn(
      t.map((h) => {
        const u = this.services.cartesianScales.getDomainIdentifier(h);
        return h[u] && typeof h[u].toString == "function" ? h[u].toString() : h[u];
      })
    ), r = a.selectAll("g.bars").data(i, (h) => h);
    r.exit().attr("opacity", 0).remove();
    const c = r.enter().append("g").classed("bars", !0).attr("role", U.GROUP).attr("data-name", "bars").merge(r);
    c.transition().call(
      (h) => this.services.transitions.setupTransition({
        transition: h,
        name: "bar-group-update-enter",
        animate: e
      })
    ).attr("transform", (h) => {
      const g = this.services.cartesianScales.getDomainValue(h) - this.getGroupWidth() / 2;
      return this.services.cartesianScales.getOrientation() === le.VERTICAL ? `translate(${g}, 0)` : `translate(0, ${g})`;
    });
    const d = c.selectAll("path.bar").data(
      (h) => this.getDataCorrespondingToLabel(h),
      (h) => h[n]
    );
    d.exit().attr("opacity", 0).remove(), d.enter().append("path").attr("opacity", 0).merge(d).classed("bar", !0).transition().call(
      (h) => this.services.transitions.setupTransition({
        transition: h,
        name: "bar-update-enter",
        animate: e
      })
    ).attr(
      "class",
      (h) => this.model.getColorClassName({
        classNameTypes: [$.FILL],
        dataGroupName: h[n],
        originalClassName: "bar"
      })
    ).style("fill", (h) => this.model.getFillColor(h[n])).attr("d", (h) => {
      const u = this.groupScale(h[n]), g = this.getBarWidth(), m = u, b = u + g, v = this.services.cartesianScales.getRangeAxisPosition({ datum: h }), S = this.services.cartesianScales.getValueThroughAxisPosition(v, 0), T = this.services.cartesianScales.getRangeValue(h), w = this.services.cartesianScales.getDomainValue(h) - g / 2, L = w + g;
      if (!this.isOutsideZoomedDomain(w, L))
        return ie(
          { x0: m, x1: b, y0: S, y1: T },
          this.services.cartesianScales.getOrientation()
        );
    }).attr("opacity", 1).attr("role", U.GRAPHICS_SYMBOL).attr("aria-roledescription", "bar").attr("aria-label", (h) => h.value), this.addEventListeners();
  }
  addEventListeners() {
    const e = this;
    this.parent.selectAll("path.bar").on("mouseover", function(t, s) {
      const n = x(this);
      n.classed("hovered", !0), e.services.events.dispatchEvent(f.Bar.BAR_MOUSEOVER, {
        event: t,
        element: n,
        datum: s
      }), e.services.events.dispatchEvent(f.Tooltip.SHOW, {
        event: t,
        hoveredElement: n,
        data: [s]
      });
    }).on("mousemove", function(t, s) {
      const n = x(this);
      e.services.events.dispatchEvent(f.Bar.BAR_MOUSEMOVE, {
        event: t,
        element: n,
        datum: s
      }), e.services.events.dispatchEvent(f.Tooltip.MOVE, {
        event: t
      });
    }).on("click", function(t, s) {
      e.services.events.dispatchEvent(f.Bar.BAR_CLICK, {
        event: t,
        element: x(this),
        datum: s
      });
    }).on("mouseout", function(t, s) {
      const n = x(this);
      n.classed("hovered", !1), e.services.events.dispatchEvent(f.Bar.BAR_MOUSEOUT, {
        event: t,
        element: n,
        datum: s
      }), e.services.events.dispatchEvent(f.Tooltip.HIDE, {
        hoveredElement: n
      });
    });
  }
  destroy() {
    this.parent.selectAll("path.bar").on("mouseover", null).on("mousemove", null).on("mouseout", null);
    const e = this.services.events;
    e.removeEventListener(f.Legend.ITEM_HOVER, this.handleLegendOnHover), e.removeEventListener(f.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  getDataCorrespondingToLabel(e) {
    return this.model.getDisplayData(this.configs.groups).filter((s) => {
      const n = this.services.cartesianScales.getDomainIdentifier(s);
      return s[n].toString() === e;
    });
  }
  getGroupWidth() {
    const e = this.model.getGroupedData(this.configs.groups), t = this.getTotalGroupPadding();
    return this.getBarWidth() * e.length + t;
  }
  getDomainScaleStep() {
    const e = this.services.cartesianScales.getDomainScale(), t = this.model.getGroupedData(this.configs.groups);
    let s = this.defaultStepFactor;
    if (typeof e.step == "function")
      s = e.step();
    else if (t.length > 0) {
      const n = t.find((a) => {
        var i;
        return ((i = a.data) == null ? void 0 : i.length) > 1;
      });
      if (n) {
        const a = this.services.cartesianScales.getDomainIdentifier(n.data[0]);
        s = Math.abs(
          e(n.data[1][a]) - e(n.data[0][a])
        );
      }
    }
    return s;
  }
  getTotalGroupPadding() {
    const e = this.model.getGroupedData(this.configs.groups);
    return e.length === 1 ? 0 : Math.min(5, 5 * (this.getDomainScaleStep() / this.defaultStepFactor)) * (e.length - 1);
  }
  // Gets the correct width for bars based on options & configurations
  getBarWidth() {
    const e = this.getOptions(), t = y(e, "bars", "width"), s = y(e, "bars", "maxWidth");
    if (t !== null && (s === null || t <= s))
      return t;
    const a = this.model.getGroupedData(this.configs.groups).length, i = this.getTotalGroupPadding();
    return Math.min(
      s,
      (this.getDomainScaleStep() - i) / a
    );
  }
  setGroupScale() {
    const e = this.model.getActiveDataGroupNames(this.configs.groups);
    this.groupScale = _t().domain(e).rangeRound([0, this.getGroupWidth()]);
  }
}
class Gc extends z {
  constructor() {
    super(...arguments), this.type = "heatmap", this.renderType = H.SVG, this.matrix = {}, this.xBandwidth = 0, this.yBandwidth = 0, this.translationUnits = {
      x: 0,
      y: 0
    }, this.handleAxisOnHover = (e) => {
      const { detail: t } = e, { datum: s } = t, n = this.model.getUniqueRanges(), a = this.model.getUniqueDomain(), i = this.services.cartesianScales.getDomainLabel(), r = this.services.cartesianScales.getRangeLabel(), l = this.services.cartesianScales.getMainXScale(), c = this.services.cartesianScales.getMainYScale();
      let d = "", p = null, h = null, u = null;
      this.matrix[s] !== void 0 ? (d = i, n.forEach((g) => {
        if (typeof this.matrix[s][g].value == "number") {
          const m = this.matrix[s][g].value;
          if (p === null) {
            p = m, h = m, u = m;
            return;
          }
          p += m, h = m < h ? m : h, u = m > u ? m : u;
        }
      })) : (d = r, a.forEach((g) => {
        if (typeof this.matrix[g][s].value == "number") {
          const m = this.matrix[g][s].value;
          if (p === null) {
            p = m, h = m, u = m;
            return;
          }
          p += m, h = m < h ? m : h, u = m > u ? m : u;
        }
      })), l(s) !== void 0 ? this.parent.select("g.multi-cell.column-highlight").classed("highlighter-hidden", !1).attr("transform", `translate(${l(s)}, ${ht(c.range())})`) : c(s) !== void 0 && this.parent.select("g.multi-cell.row-highlight").classed("highlighter-hidden", !1).attr("transform", `translate(${ht(l.range())},${c(s)})`), this.services.events.dispatchEvent(f.Tooltip.SHOW, {
        event: t.event,
        hoveredElement: x(e.detail.element),
        items: [
          {
            label: d,
            value: s,
            bold: !0
          },
          {
            label: "Min",
            value: h !== null ? h : "-"
          },
          {
            label: "Max",
            value: u !== null ? u : "-"
          },
          {
            label: "Average",
            value: p !== null ? p / a.length : "-"
          }
        ]
      });
    }, this.handleAxisMouseOut = (e) => {
      this.parent.selectAll("g.multi-cell").classed("highlighter-hidden", !0), this.services.events.dispatchEvent(f.Tooltip.HIDE, {
        event: e
      });
    };
  }
  init() {
    const e = this.services.events;
    e.addEventListener(f.Axis.LABEL_MOUSEOVER, this.handleAxisOnHover), e.addEventListener(f.Axis.LABEL_MOUSEOUT, this.handleAxisMouseOut), e.addEventListener(f.Axis.LABEL_FOCUS, this.handleAxisOnHover), e.addEventListener(f.Axis.LABEL_BLUR, this.handleAxisMouseOut);
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(e = !0) {
    const t = this.getComponentContainer({ withinChartClip: !0 });
    t.lower();
    const { cartesianScales: s } = this.services;
    if (this.matrix = this.model.getMatrix(), t.html(""), y(this.getOptions(), "data", "loading"))
      return;
    const n = s.getMainXScale(), a = s.getMainYScale(), i = s.getDomainIdentifier(), r = s.getRangeIdentifier(), l = this.model.getUniqueDomain(), c = this.model.getUniqueRanges(), d = this.model.getMatrixAsArray(), p = n.range(), h = a.range();
    this.xBandwidth = Math.abs((p[1] - p[0]) / l.length), this.yBandwidth = Math.abs((h[1] - h[0]) / c.length);
    const u = this.services.domUtils.generateElementIDString("heatmap-pattern-stripes");
    t.append("defs").append("pattern").attr("id", u).attr("width", 3).attr("height", 3).attr("patternUnits", "userSpaceOnUse").attr("patternTransform", "rotate(45)").append("rect").classed("pattern-fill", !0).attr("width", 0.5).attr("height", 8);
    const g = t.selectAll().data(d).enter().append("g").attr("class", (m) => `heat-${m.index}`).classed("cell", !0).attr(
      "transform",
      (m) => `translate(${n(m[i])}, ${a(m[r])})`
    ).append("rect").attr(
      "class",
      (m) => this.model.getColorClassName({
        value: m.value,
        originalClassName: `heat-${m.index}`
      })
    ).classed("heat", !0).classed("null-state", (m) => m.index === -1 || m.value === null).attr("width", this.xBandwidth).attr("height", this.yBandwidth).style("fill", (m) => m.index === -1 || m.value === null ? `url(#${u})` : this.model.getFillColor(Number(m.value))).attr("aria-label", (m) => m.value);
    this.createOuterBox("g.cell-highlight", this.xBandwidth, this.yBandwidth), this.createOuterBox(
      "g.multi-cell.column-highlight",
      this.xBandwidth,
      Math.abs(h[1] - h[0])
    ), this.createOuterBox(
      "g.multi-cell.row-highlight",
      Math.abs(p[1] - p[0]),
      this.yBandwidth
    ), this.determineDividerStatus() && (g.style("stroke-width", "1px"), this.parent.select("g.cell-highlight").classed("cell-2", !0)), this.addEventListener();
  }
  /**
   * Generates a box using lines to create a hover effect
   * The lines have drop shadow in their respective direction
   * @param parentTag - tag name
   * @param xBandwidth - X length
   * @param yBandwidth - y length
   */
  createOuterBox(e, t, s) {
    const n = E.appendOrSelect(this.parent, e).classed("shadows", !0).classed("highlighter-hidden", !0);
    E.appendOrSelect(n, "line.top").attr("x1", -1).attr("x2", t + 1), E.appendOrSelect(n, "line.left").attr("x1", 0).attr("y1", -1).attr("x2", 0).attr("y2", s + 1), E.appendOrSelect(n, "line.down").attr("x1", -1).attr("x2", t + 1).attr("y1", s).attr("y2", s), E.appendOrSelect(n, "line.right").attr("x1", t).attr("x2", t).attr("y1", -1).attr("y2", s + 1);
  }
  determineDividerStatus() {
    const e = y(this.getOptions(), "heatmap", "divider", "state");
    return e !== ot.OFF && (e === ot.AUTO && Ft.minCellDividerDimension <= this.xBandwidth && Ft.minCellDividerDimension <= this.yBandwidth || e === ot.ON);
  }
  addEventListener() {
    const e = this, { cartesianScales: t } = this.services, s = this.getOptions(), n = Q(s, "tooltip.totalLabel"), a = t.getDomainIdentifier(), i = t.getRangeIdentifier(), r = t.getDomainLabel(), l = t.getRangeLabel();
    this.parent.selectAll("g.cell").on("mouseover", function(c, d) {
      const p = x(this), h = p.select("rect.heat");
      if (!h.classed("null-state")) {
        const g = Ve(p.attr("transform"));
        e.parent.select("g.cell-highlight").attr(
          "transform",
          `translate(${g.x + e.translationUnits.x}, ${g.y + e.translationUnits.y})`
        ).classed("highlighter-hidden", !1), e.services.events.dispatchEvent(f.Heatmap.HEATMAP_MOUSEOVER, {
          event: c,
          element: h,
          datum: d
        }), e.services.events.dispatchEvent(f.Tooltip.SHOW, {
          event: c,
          items: [
            {
              label: r,
              value: d[a]
            },
            {
              label: l,
              value: d[i]
            },
            {
              label: n || "Total",
              value: d.value,
              color: h.style("fill")
            }
          ]
        });
      }
    }).on("mousemove", function(c, d) {
      e.services.events.dispatchEvent(f.Heatmap.HEATMAP_MOUSEMOVE, {
        event: c,
        element: x(this),
        datum: d
      }), e.services.events.dispatchEvent(f.Tooltip.MOVE, {
        event: c
      });
    }).on("click", function(c, d) {
      e.services.events.dispatchEvent(f.Heatmap.HEATMAP_CLICK, {
        event: c,
        element: x(this),
        datum: d
      });
    }).on("mouseout", function(c, d) {
      const h = x(this).select("rect.heat"), u = h.classed("null-state");
      e.parent.select("g.cell-highlight").classed("highlighter-hidden", !0), u || (e.services.events.dispatchEvent(f.Heatmap.HEATMAP_MOUSEOUT, {
        event: c,
        element: h,
        datum: d
      }), e.services.events.dispatchEvent(f.Tooltip.HIDE, {
        event: c,
        hoveredElement: h
      }));
    });
  }
  // Remove event listeners
  destroy() {
    this.parent.selectAll("rect.heat").on("mouseover", null).on("mousemove", null).on("click", null).on("mouseout", null);
    const e = this.services.events;
    e.removeEventListener(f.Legend.ITEM_HOVER, this.handleAxisOnHover), e.removeEventListener(f.Legend.ITEM_MOUSEOUT, this.handleAxisMouseOut);
  }
}
class Nc extends z {
  constructor() {
    super(...arguments), this.type = "histogram", this.renderType = H.SVG, this.handleLegendOnHover = (e) => {
      const { hoveredElement: t } = e.detail, s = this.getOptions(), { groupMapsTo: n } = s.data;
      this.parent.selectAll("path.bar").transition("legend-hover-bar").call(
        (a) => this.services.transitions.setupTransition({
          transition: a,
          name: "legend-hover-bar"
        })
      ).attr("opacity", (a) => a[n] !== t.datum().name ? 0.3 : 1);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("path.bar").transition("legend-mouseout-bar").call(
        (e) => this.services.transitions.setupTransition({
          transition: e,
          name: "legend-mouseout-bar"
        })
      ).attr("opacity", 1);
    };
  }
  init() {
    const e = this.services.events;
    e.addEventListener(f.Legend.ITEM_HOVER, this.handleLegendOnHover), e.addEventListener(f.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(e) {
    const t = this.getComponentContainer(), s = this.model.getOptions(), { groupIdentifier: n } = s, { groupMapsTo: a } = s.data, i = this.model.getBinnedStackedData(), r = this.services.cartesianScales.getMainXScale(), l = t.selectAll("g.bars").data(i, (d) => Q(d, `0.${a}`));
    l.exit().attr("opacity", 0).remove(), l.enter().append("g").classed("bars", !0).attr("role", U.GROUP);
    const c = t.selectAll("g.bars").selectAll("path.bar").data((d) => d);
    c.exit().remove(), c.enter().append("path").merge(c).classed("bar", !0).attr(n, (d, p) => p).transition().call(
      (d) => this.services.transitions.setupTransition({
        transition: d,
        name: "histogram-bar-update-enter",
        animate: e
      })
    ).attr(
      "class",
      (d) => this.model.getColorClassName({
        classNameTypes: [$.FILL],
        dataGroupName: d[a],
        originalClassName: "bar"
      })
    ).style("fill", (d) => this.model.getFillColor(d[a])).attr("d", (d) => {
      const p = Q(d, "data");
      if (!p)
        return;
      const h = r(p.x1) - r(p.x0) - 1, u = this.services.cartesianScales.getDomainValue(p.x0), g = u + h, m = this.services.cartesianScales.getRangeValue(d[0]);
      let b = this.services.cartesianScales.getRangeValue(d[1]);
      return Math.abs(b - m) > 0 && Math.abs(b - m) > s.bars.dividerSize && (this.services.cartesianScales.getOrientation() === le.VERTICAL ? b += 1 : b -= 1), ie(
        { x0: u, x1: g, y0: m, y1: b },
        this.services.cartesianScales.getOrientation()
      );
    }).attr("opacity", 1).attr("role", U.GRAPHICS_SYMBOL).attr("aria-roledescription", "bar").attr("aria-label", (d) => y(d, "data", d[a])), this.addEventListeners();
  }
  addEventListeners() {
    const e = this.model.getOptions(), { groupMapsTo: t } = e.data, s = this;
    this.parent.selectAll("path.bar").on("mouseover", function(n, a) {
      const i = x(this);
      i.classed("hovered", !0);
      const r = parseFloat(Q(a, "data.x0")), l = parseFloat(Q(a, "data.x1")), c = s.services.cartesianScales.getRangeAxisPosition(), d = s.services.cartesianScales.getScaleLabel(c);
      s.services.events.dispatchEvent(f.Tooltip.SHOW, {
        event: n,
        hoveredElement: i,
        items: [
          {
            label: Q(e, "bins.rangeLabel") || "Range",
            value: `${r} – ${l}`
          },
          {
            label: e.tooltip.groupLabel || "Group",
            value: a[t],
            class: s.model.getColorClassName({
              classNameTypes: [$.TOOLTIP],
              dataGroupName: a[t]
            })
          },
          {
            label: d,
            value: Q(a, `data.${a[t]}`)
          }
        ]
      });
    }).on("mousemove", function(n) {
      s.services.events.dispatchEvent(f.Tooltip.MOVE, {
        event: n
      });
    }).on("mouseout", function() {
      x(this).classed("hovered", !1), s.services.events.dispatchEvent(f.Tooltip.HIDE);
    });
  }
  destroy() {
    this.parent.selectAll("path.bar").on("mouseover", null).on("mousemove", null).on("mouseout", null);
    const e = this.services.events;
    e.removeEventListener(f.Legend.ITEM_HOVER, this.handleLegendOnHover), e.removeEventListener(f.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
}
class Hc extends Vt {
  constructor() {
    super(...arguments), this.type = "lollipop", this.renderType = H.SVG, this.handleScatterOnHover = (e) => {
      const t = e.detail, s = this.getOptions(), { groupMapsTo: n } = s.data;
      this.parent.selectAll("line.line").attr("stroke-width", (a) => a[n] !== t.datum[n] ? me.weight.unselected : me.weight.selected);
    }, this.handleScatterOnMouseOut = () => {
      this.parent.selectAll("line.line").attr("stroke-width", me.weight.unselected);
    }, this.handleLegendOnHover = (e) => {
      const { hoveredElement: t } = e.detail, s = this.getOptions(), { groupMapsTo: n } = s.data;
      this.parent.selectAll("line.line").transition("legend-hover-line").call(
        (a) => this.services.transitions.setupTransition({
          transition: a,
          name: "legend-hover-line"
        })
      ).attr("opacity", (a) => a[n] !== t.datum().name ? me.opacity.unselected : me.opacity.selected);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("line.line").transition("legend-mouseout-line").call(
        (e) => this.services.transitions.setupTransition({
          transition: e,
          name: "legend-mouseout-line"
        })
      ).attr("opacity", me.opacity.selected);
    };
  }
  init() {
    const { events: e } = this.services;
    e.addEventListener(f.Legend.ITEM_HOVER, this.handleLegendOnHover), e.addEventListener(f.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(e) {
    const t = this.getComponentContainer({ withinChartClip: !0 }), s = this.model.getOptions(), { groupMapsTo: n } = s.data, { cartesianScales: a } = this.services, i = a.getMainXScale(), r = a.getMainYScale(), l = a.getDomainIdentifier(), c = (v) => a.getDomainValue(v), d = (v) => a.getRangeValue(v), p = a.getOrientation(), [h, u] = ve(
      c,
      d,
      p
    ), g = t.selectAll("line.line").data(
      this.getScatterData(),
      (v) => `${v[n]}-${v[l]}`
    );
    g.exit().attr("opacity", 0).remove();
    const b = g.enter().append("line").attr("opacity", 0).merge(g).classed("line", !0).attr(
      "class",
      (v) => this.model.getColorClassName({
        classNameTypes: [$.STROKE],
        dataGroupName: v[n],
        originalClassName: "line"
      })
    ).transition().call(
      (v) => this.services.transitions.setupTransition({
        transition: v,
        name: "lollipop-line-update-enter",
        animate: e
      })
    ).style("stroke", (v) => this.model.getFillColor(v[n], v[l], v)).attr("opacity", 1);
    p === le.HORIZONTAL ? b.attr("y1", u).attr("y2", u).attr("x1", i.range()[0]).attr("x2", (v) => h(v) - s.points.radius) : b.attr("x1", h).attr("x2", h).attr("y1", r.range()[0]).attr("y2", (v) => u(v) + s.points.radius), this.addScatterPointEventListeners();
  }
  // listen for when individual datapoints are hovered
  addScatterPointEventListeners() {
    this.services.events.addEventListener(
      f.Scatter.SCATTER_MOUSEOVER,
      this.handleScatterOnHover
    ), this.services.events.addEventListener(
      f.Scatter.SCATTER_MOUSEOUT,
      this.handleScatterOnMouseOut
    );
  }
  destroy() {
    const e = this.services.events;
    e.removeEventListener(f.Legend.ITEM_HOVER, this.handleLegendOnHover), e.removeEventListener(f.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut), e.removeEventListener(f.Scatter.SCATTER_MOUSEOVER, this.handleScatterOnHover), e.removeEventListener(
      f.Scatter.SCATTER_MOUSEOUT,
      this.handleScatterOnMouseOut
    );
  }
}
class Uc extends z {
  constructor() {
    super(...arguments), this.type = "meter", this.renderType = H.SVG;
  }
  getStackedBounds(e, t) {
    let s = 0;
    return e.map((a, i) => i !== 0 ? (s += t(a.value), {
      ...a,
      width: Math.abs(t(a.value) - se.dividerWidth),
      x: s - t(a.value)
    }) : (s = t(a.value), {
      ...a,
      width: Math.abs(t(a.value) - se.dividerWidth),
      x: 0
    }));
  }
  render(e = !0) {
    const t = this, s = this.getComponentContainer(), n = this.getOptions(), a = y(n, "meter", "proportional"), i = this.model.getDisplayData(), r = this.model.getStatus(), { width: l } = E.getSVGElementSize(s, {
      useAttrs: !0
    }), { groupMapsTo: c } = n.data;
    let d;
    if (y(n, "meter", "proportional") === null)
      d = 100;
    else {
      const T = y(n, "meter", "proportional", "total");
      d = T || this.model.getMaximumDomain(this.model.getDisplayData());
    }
    const p = Oe().domain([0, d]).range([0, l]), h = this.getStackedBounds(i, p), u = y(n, "meter", "height");
    E.appendOrSelect(s, "rect.container").attr("x", 0).attr("y", 0).attr("width", l).attr(
      "height",
      u || (a ? se.height.proportional : se.height.default)
    ), E.appendOrSelect(s, "line.rangeIndicator").attr("x1", l).attr("x2", l).attr("y1", 0).attr(
      "y2",
      u || (a ? se.height.proportional : se.height.default)
    );
    const g = s.selectAll("rect.value").data(h), m = r != null && !t.model.isUserProvidedColorScaleValid() && !a ? `value status--${r}` : "value";
    g.enter().append("rect").classed("value", !0).merge(g).attr("x", (T) => T.x).attr("y", 0).attr("height", () => u || (a ? se.height.proportional : se.height.default)).attr(
      "class",
      (T) => this.model.getColorClassName({
        classNameTypes: [$.FILL],
        dataGroupName: T[c],
        originalClassName: m
      })
    ).transition().call(
      (T) => this.services.transitions.setupTransition({
        transition: T,
        name: "meter-bar-update",
        animate: e
      })
    ).attr("width", (T) => T.value > d ? p(d) : T.width).style("fill", (T) => t.model.getFillColor(T[c])).attr("role", U.GRAPHICS_SYMBOL).attr("aria-roledescription", "value").attr("aria-label", (T) => T.value), g.exit().remove();
    const b = y(n, "meter", "peak");
    let v = b;
    b !== null && (b > d ? v = d : b < i[0].value && (v = i[0].value > d ? d : i[0].value));
    const S = s.selectAll("line.peak").data(v == null ? [] : [v]);
    S.enter().append("line").classed("peak", !0).merge(S).attr("y1", 0).attr("y2", () => u || (a ? se.height.proportional : se.height.default)).transition().call(
      (T) => this.services.transitions.setupTransition({
        transition: T,
        name: "peak-line-update",
        animate: e
      })
    ).attr("x1", (T) => p(T)).attr("x2", (T) => p(T)).attr("role", U.GRAPHICS_SYMBOL).attr("aria-roledescription", "peak").attr("aria-label", (T) => T), S.exit().remove(), this.services.domUtils.setSVGMaxHeight(), this.addEventListeners();
  }
  // add event listeners for tooltips on proportional meter bars
  addEventListeners() {
    const e = this.getOptions(), { groupMapsTo: t } = e.data, s = this, n = y(e, "meter", "proportional");
    this.parent.selectAll("rect.value").on("mouseover", function(a, i) {
      const r = x(this);
      s.services.events.dispatchEvent(f.Meter.METER_MOUSEOVER, {
        event: a,
        element: r,
        datum: i
      }), n && (r.classed("hovered", !0), s.services.events.dispatchEvent(f.Tooltip.SHOW, {
        event: a,
        hoveredElement: r,
        items: [
          {
            label: i[t],
            value: i.value
          }
        ]
      }));
    }).on("mousemove", function(a, i) {
      const r = x(this);
      s.services.events.dispatchEvent(f.Meter.METER_MOUSEMOVE, {
        event: a,
        element: r,
        datum: i
      }), n && s.services.events.dispatchEvent(f.Tooltip.MOVE, {
        event: a
      });
    }).on("click", function(a, i) {
      s.services.events.dispatchEvent(f.Meter.METER_CLICK, {
        event: a,
        element: x(this),
        datum: i
      });
    }).on("mouseout", function(a, i) {
      const r = x(this);
      s.services.events.dispatchEvent(f.Meter.METER_MOUSEOUT, {
        event: a,
        element: r,
        datum: i
      }), n && (r.classed("hovered", !1), s.services.events.dispatchEvent(f.Tooltip.HIDE, {
        hoveredElement: r
      }));
    });
  }
  destroy() {
    this.parent.selectAll("rect.value").on("mouseover", null).on("mousemove", null).on("mouseout", null).on("click", null);
  }
}
class zc extends z {
  constructor() {
    super(...arguments), this.type = "radar", this.renderType = H.SVG, this.getLabelDimensions = (e) => {
      const t = E.appendOrSelect(this.getComponentContainer(), "g.tmp-tick"), s = E.appendOrSelect(t, "text").text(e), { width: n, height: a } = E.getSVGElementSize(s.node(), { useBBox: !0 });
      return t.remove(), { width: n, height: a };
    }, this.normalizeFlatData = (e) => {
      const t = this.getOptions(), { angle: s, value: n } = y(t, "radar", "axes"), a = y(t, "data", "groupMapsTo"), i = $a(
        this.uniqueKeys.map((r) => this.uniqueGroups.map((l) => ({
          [s]: r,
          [a]: l,
          [n]: null
        })))
      );
      return Re(i, e);
    }, this.normalizeGroupedData = (e) => {
      const t = this.getOptions(), { angle: s, value: n } = y(t, "radar", "axes"), a = y(t, "data", "groupMapsTo");
      return e.map(({ name: i, data: r }) => {
        const l = this.uniqueKeys.map((c) => ({
          [a]: i,
          [s]: c,
          [n]: null
        }));
        return { name: i, data: Re(l, r) };
      });
    }, this.handleLegendOnHover = (e) => {
      const { hoveredElement: t } = e.detail;
      this.parent.selectAll("g.blobs path").transition("legend-hover-blob").call(
        (s) => this.services.transitions.setupTransition({
          transition: s,
          name: "legend-hover-blob"
        })
      ).style("fill-opacity", (s) => s.name !== t.datum().name ? Ee.opacity.unselected : Ee.opacity.selected).style("stroke-opacity", (s) => s.name !== t.datum().name ? Ee.opacity.unselected : 1);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("g.blobs path").transition("legend-mouseout-blob").call(
        (e) => this.services.transitions.setupTransition({
          transition: e,
          name: "legend-mouseout-blob"
        })
      ).style("fill-opacity", Ee.opacity.selected).style("stroke-opacity", 1);
    };
  }
  init() {
    const { events: e } = this.services;
    e.addEventListener(f.Legend.ITEM_HOVER, this.handleLegendOnHover), e.addEventListener(f.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(e = !0) {
    const t = this.getComponentContainer(), { width: s, height: n } = E.getSVGElementSize(t, {
      useAttrs: !0
    }), a = this.model.getData(), i = this.model.getGroupedData(), r = this.getOptions(), l = y(r, "data", "groupMapsTo"), c = y(r, "radar", "axes", "value"), { angle: d, value: p } = y(r, "radar", "axes"), { xLabelPadding: h, yLabelPadding: u, yTicksNumber: g, minRange: m, xAxisRectHeight: b } = Ee;
    this.uniqueKeys = Array.from(new Set(a.map((C) => C[d]))), this.uniqueGroups = Array.from(new Set(a.map((C) => C[l]))), this.fullDataNormalized = this.normalizeFlatData(a), this.groupedDataNormalized = this.normalizeGroupedData(i);
    const S = 2 * (this.getLabelDimensions(this.uniqueKeys[0]).height + u), L = (Math.min(s, n) - S) / 2;
    if (L <= 0)
      return;
    const O = _t().domain(this.fullDataNormalized.map((C) => C[d])).range([0, 2 * Math.PI].map((C) => C - Math.PI / 2)), k = ht(this.fullDataNormalized.map((C) => C[p])), I = Oe().domain([
      k >= 0 ? 0 : k,
      Nt(this.fullDataNormalized.map((C) => C[p]))
    ]).range([m, L]).nice(g), F = I.ticks(g), P = (C) => this.model.getFillColor(C), A = rn().angle((C) => O(C[d]) + Math.PI / 2).radius((C) => I(C[p])).curve(on), M = this.uniqueKeys.map((C) => {
      const R = this.getLabelDimensions(C).width, _ = Vn(
        O(C),
        L
      );
      return R + _;
    }), D = {
      x: Nt(M) + h,
      y: n / 2
    }, re = E.appendOrSelect(t, "g.y-axes").attr("role", U.GROUP).selectAll("path").data(F, (C) => C), W = (C) => this.uniqueKeys.map((R) => ({ [d]: R, [p]: C }));
    re.join(
      (C) => C.append("path").attr("opacity", 0).attr("transform", `translate(${D.x}, ${D.y})`).attr("fill", "none").call(
        (R) => R.transition().call(
          (_) => this.services.transitions.setupTransition({
            transition: _,
            name: "radar_y_axes_enter",
            animate: e
          })
        ).attr("opacity", 1).attr("d", (_) => A(W(_)))
      ),
      (C) => C.call(
        (R) => R.transition().call(
          (_) => this.services.transitions.setupTransition({
            transition: _,
            name: "radar_y_axes_update",
            animate: e
          })
        ).attr("opacity", 1).attr("transform", `translate(${D.x}, ${D.y})`).attr("d", (_) => A(W(_)))
      ),
      (C) => C.call(
        (R) => R.transition().call(
          (_) => this.services.transitions.setupTransition({
            transition: _,
            name: "radar_y_axes_exit",
            animate: e
          })
        ).attr("d", (_) => A(W(_))).attr("opacity", 0).remove()
      )
    ), E.appendOrSelect(t, "g.x-axes").attr("role", U.GROUP).selectAll("line").data(this.uniqueKeys, (C) => C).join(
      (C) => C.append("line").attr("opacity", 0).attr("class", (R) => `x-axis-${we(R)}`).attr("stroke-dasharray", "0").attr("x1", (R) => Y(O(R), 0, D).x).attr("y1", (R) => Y(O(R), 0, D).y).attr("x2", (R) => Y(O(R), 0, D).x).attr("y2", (R) => Y(O(R), 0, D).y).call(
        (R) => R.transition().call(
          (_) => this.services.transitions.setupTransition({
            transition: _,
            name: "radar_x_axes_enter",
            animate: e
          })
        ).attr("opacity", 1).attr("x1", (_) => Y(O(_), I.range()[0], D).x).attr("y1", (_) => Y(O(_), I.range()[0], D).y).attr("x2", (_) => Y(O(_), I.range()[1], D).x).attr("y2", (_) => Y(O(_), I.range()[1], D).y)
      ),
      (C) => C.call(
        (R) => R.transition().call(
          (_) => this.services.transitions.setupTransition({
            transition: _,
            name: "radar_x_axes_update",
            animate: e
          })
        ).attr("opacity", 1).attr("x1", (_) => Y(O(_), I.range()[0], D).x).attr("y1", (_) => Y(O(_), I.range()[0], D).y).attr("x2", (_) => Y(O(_), I.range()[1], D).x).attr("y2", (_) => Y(O(_), I.range()[1], D).y)
      ),
      (C) => C.call(
        (R) => R.transition().call(
          (_) => this.services.transitions.setupTransition({
            transition: _,
            name: "radar_x_axes_exit",
            animate: e
          })
        ).attr("opacity", 0).remove()
      )
    ), E.appendOrSelect(t, "g.x-labels").attr("role", U.GROUP).selectAll("text").data(this.uniqueKeys).join(
      (C) => C.append("text").text((R) => R).attr("opacity", 0).attr(
        "x",
        (R) => Y(O(R), I.range()[1] + h, D).x
      ).attr(
        "y",
        (R) => Y(O(R), I.range()[1] + h, D).y
      ).style("text-anchor", (R) => Xt(O(R)).textAnchor).style(
        "dominant-baseline",
        (R) => Xt(O(R)).dominantBaseline
      ).call(
        (R) => R.transition().call(
          (_) => this.services.transitions.setupTransition({
            transition: _,
            name: "radar_x_labels_enter",
            animate: e
          })
        ).attr("opacity", 1)
      ),
      (C) => C.call(
        (R) => R.transition().call(
          (_) => this.services.transitions.setupTransition({
            transition: _,
            name: "radar_x_labels_update",
            animate: e
          })
        ).attr("opacity", 1).attr(
          "x",
          (_) => Y(O(_), I.range()[1] + h, D).x
        ).attr(
          "y",
          (_) => Y(O(_), I.range()[1] + h, D).y
        ).end().finally(() => {
          const _ = y(r, "radar", "alignment"), be = this.getAlignmentXOffset(_, t, this.getParent());
          t.attr("x", be);
        })
      ),
      (C) => C.call(
        (R) => R.transition().call(
          (_) => this.services.transitions.setupTransition({
            transition: _,
            name: "radar_x_labels_exit",
            animate: e
          })
        ).attr("opacity", 0).remove()
      )
    ), E.appendOrSelect(t, "g.blobs").attr("role", U.GROUP).selectAll("path").data(this.groupedDataNormalized, (C) => C.name).join(
      (C) => C.append("path").attr(
        "class",
        (R) => this.model.getColorClassName({
          classNameTypes: [$.FILL, $.STROKE],
          dataGroupName: R.name,
          originalClassName: "blob"
        })
      ).attr("role", U.GRAPHICS_SYMBOL).attr("aria-label", (R) => R.name).attr("opacity", 0).attr(
        "transform",
        e ? () => `translate(${D.x}, ${D.y}) scale(${1 + Math.random() * 0.35})` : `translate(${D.x}, ${D.y})`
      ).style("fill", (R) => P(R.name)).style("fill-opacity", Ee.opacity.selected).style("stroke", (R) => P(R.name)).call((R) => {
        const _ = R.transition().call(
          (be) => this.services.transitions.setupTransition({
            transition: be,
            name: "radar_blobs_enter",
            animate: e
          })
        );
        e && _.delay(() => Math.random() * 30).attr("transform", `translate(${D.x}, ${D.y})`), _.attr("opacity", 1).attr("d", (be) => A(be.data));
      }),
      (C) => (C.attr(
        "class",
        (R) => this.model.getColorClassName({
          classNameTypes: [$.FILL, $.STROKE],
          dataGroupName: R.name,
          originalClassName: "blob"
        })
      ).style("fill", (R) => P(R.name)).style("stroke", (R) => P(R.name)), C.call(
        (R) => R.transition().call(
          (_) => this.services.transitions.setupTransition({
            transition: _,
            name: "radar_blobs_update",
            animate: e
          })
        ).attr("opacity", 1).attr("transform", `translate(${D.x}, ${D.y})`).attr("d", (_) => A(_.data))
      ), C),
      (C) => C.call((R) => {
        const _ = R.transition().call(
          (be) => this.services.transitions.setupTransition({
            transition: be,
            name: "radar_blobs_exit",
            animate: e
          })
        );
        e && _.delay(() => Math.random() * 30).attr(
          "transform",
          () => `translate(${D.x}, ${D.y}) scale(${1 + Math.random() * 0.35})`
        ), _.attr("opacity", 0).remove();
      })
    ), E.appendOrSelect(t, "g.dots").attr("role", U.GROUP).selectAll("circle").data(this.fullDataNormalized.filter((C) => y(C, p) !== null)).join(
      (C) => C.append("circle").attr("role", U.GRAPHICS_SYMBOL).attr("aria-label", (R) => R[c]),
      (C) => C,
      (C) => C.remove()
    ).attr(
      "class",
      (C) => this.model.getColorClassName({
        classNameTypes: [$.FILL],
        dataGroupName: C[l],
        originalClassName: we(C[d])
      })
    ).attr("cx", (C) => Y(O(C[d]), I(C[p]), D).x).attr("cy", (C) => Y(O(C[d]), I(C[p]), D).y).attr("r", 0).attr("opacity", 0).style("fill", (C) => P(C[l])), E.appendOrSelect(t, "g.x-axes-rect").attr("role", U.GROUP).selectAll("rect").data(this.uniqueKeys).join(
      (C) => C.append("rect"),
      (C) => C,
      (C) => C.remove()
    ).attr("x", D.x).attr("y", D.y - b / 2).attr("width", I.range()[1]).attr("height", b).style("fill", "red").style("fill-opacity", 0).attr("transform", (C) => `rotate(${Bn(O(C))}, ${D.x}, ${D.y})`), E.appendOrSelect(t, "g.y-labels").attr("role", U.GROUP).selectAll("text").data(Qe(F)).join(
      (C) => C.append("text").attr("opacity", 0).text((R) => R).attr(
        "x",
        (R) => Y(-Math.PI / 2, I(R), D).x + u
      ).attr("y", (R) => Y(-Math.PI / 2, I(R), D).y).style("text-anchor", "start").style("dominant-baseline", "middle").call(
        (R) => R.transition().call(
          (_) => this.services.transitions.setupTransition({
            transition: _,
            name: "radar_y_labels_enter",
            animate: e
          })
        ).attr("opacity", 1)
      ),
      (C) => C.call(
        (R) => R.transition().call(
          (_) => this.services.transitions.setupTransition({
            transition: _,
            name: "radar_y_labels_update",
            animate: e
          })
        ).text((_) => _).attr("opacity", 1).attr(
          "x",
          (_) => Y(-Math.PI / 2, I(_), D).x + u
        ).attr("y", (_) => Y(-Math.PI / 2, I(_), D).y)
      ),
      (C) => C.call(
        (R) => R.transition().call(
          (_) => this.services.transitions.setupTransition({
            transition: _,
            name: "radar_y_labels_exit",
            animate: e
          })
        ).attr("opacity", 0).remove()
      )
    ), this.addEventListeners();
  }
  getAlignmentXOffset(e, t, s) {
    const n = E.getSVGElementSize(t, {
      useBBox: !0
    }), { width: a } = E.getSVGElementSize(s, {
      useAttrs: !0
    });
    let i = 0;
    return e === ue.CENTER ? i = Math.floor((a - n.width) / 2) : e === ue.RIGHT && (i = a - n.width), i;
  }
  destroy() {
    this.parent.selectAll(".x-axes-rect > rect").on("mouseover", null).on("mousemove", null).on("mouseout", null);
    const e = this.services.events;
    e.removeEventListener(f.Legend.ITEM_HOVER, this.handleLegendOnHover), e.removeEventListener(f.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  addEventListeners() {
    const e = this, {
      axes: { angle: t }
    } = y(this.getOptions(), "radar");
    this.parent.selectAll(".x-axes-rect > rect").on("mouseover", function(s, n) {
      const a = x(this);
      e.services.events.dispatchEvent(f.Radar.X_AXIS_MOUSEOVER, {
        event: s,
        element: a,
        datum: n
      });
      const i = e.parent.select(`.x-axes .x-axis-${we(n)}`), r = e.parent.selectAll(`.dots circle.${we(n)}`), l = e.model.getActiveDataGroupNames(), c = e.getOptions(), { groupMapsTo: d } = c.data, p = y(c, "radar", "axes", "value");
      i.classed("hovered", !0).attr("stroke-dasharray", "4 4"), r.classed("hovered", !0).attr(
        "opacity",
        (u) => l.indexOf(u[d]) !== -1 ? 1 : 0
      ).attr("r", Ee.dotsRadius);
      const h = e.fullDataNormalized.filter(
        (u) => u[t] === n && l.indexOf(u[d]) !== -1
      );
      e.services.events.dispatchEvent(f.Tooltip.SHOW, {
        event: s,
        hoveredElement: a,
        items: h.filter((u) => typeof u[p] == "number").map((u) => ({
          label: u[d],
          value: u[p],
          color: e.model.getFillColor(u[d]),
          class: e.model.getColorClassName({
            classNameTypes: [$.TOOLTIP],
            dataGroupName: u[d]
          })
        }))
      });
    }).on("mousemove", function(s, n) {
      const a = x(this);
      e.services.events.dispatchEvent(f.Radar.X_AXIS_MOUSEMOVE, {
        event: s,
        element: a,
        datum: n
      }), e.services.events.dispatchEvent(f.Tooltip.MOVE, {
        event: s
      });
    }).on("click", function(s, n) {
      e.services.events.dispatchEvent(f.Radar.X_AXIS_CLICK, {
        event: s,
        element: x(this),
        datum: n
      });
    }).on("mouseout", function(s, n) {
      const a = x(this), i = e.parent.select(`.x-axes .x-axis-${we(n)}`), r = e.parent.selectAll(`.dots circle.${we(n)}`);
      i.classed("hovered", !1).attr("stroke-dasharray", "0"), r.classed("hovered", !1).attr("opacity", 0).attr("r", 0), e.services.events.dispatchEvent(f.Radar.X_AXIS_MOUSEOUT, {
        event: s,
        element: a,
        datum: n
      }), e.services.events.dispatchEvent(f.Tooltip.HIDE);
    });
  }
}
class Fc extends $t {
  constructor() {
    super(...arguments), this.type = "simple-bar", this.renderType = H.SVG, this.handleLegendOnHover = (e) => {
      const { hoveredElement: t } = e.detail, { groupMapsTo: s } = this.getOptions().data;
      this.parent.selectAll("path.bar").transition("legend-hover-simple-bar").call(
        (n) => this.services.transitions.setupTransition({
          transition: n,
          name: "legend-hover-simple-bar"
        })
      ).attr("opacity", (n) => n[s] !== t.datum().name ? 0.3 : 1);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("path.bar").transition("legend-mouseout-simple-bar").call(
        (e) => this.services.transitions.setupTransition({
          transition: e,
          name: "legend-mouseout-simple-bar"
        })
      ).attr("opacity", 1);
    };
  }
  init() {
    const e = this.services.events;
    e.addEventListener(f.Legend.ITEM_HOVER, this.handleLegendOnHover), e.addEventListener(f.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(e) {
    const t = this.getOptions(), { groupMapsTo: s } = t.data, n = this.getComponentContainer({ withinChartClip: !0 }), a = this.model.getDisplayData(this.configs.groups), i = this.services.cartesianScales.getOrientation(), r = n.selectAll("path.bar").data(a, (c) => c[s]);
    r.exit().attr("opacity", 0).remove(), r.enter().append("path").attr("opacity", 0).merge(r).classed("bar", !0).attr("width", this.getBarWidth.bind(this)).transition().call(
      (c) => this.services.transitions.setupTransition({
        transition: c,
        name: "bar-update-enter",
        animate: e
      })
    ).attr(
      "class",
      (c) => this.model.getColorClassName({
        classNameTypes: [$.FILL],
        dataGroupName: c[s],
        originalClassName: "bar"
      })
    ).style("fill", (c) => this.model.getFillColor(c[s])).attr("d", (c) => {
      const d = this.services.cartesianScales.getRangeIdentifier(), p = this.getBarWidth(), h = c[d], u = this.services.cartesianScales.getDomainValue(c) - p / 2, g = u + p;
      let m, b;
      if (Array.isArray(h) && h.length === 2)
        m = this.services.cartesianScales.getRangeValue(h[0]), b = this.services.cartesianScales.getRangeValue(h[1]);
      else {
        const T = this.services.cartesianScales.getRangeScale().domain()[0];
        m = this.services.cartesianScales.getRangeValue(Math.max(0, T)), b = this.services.cartesianScales.getRangeValue(c);
      }
      const v = Math.abs(b - m);
      if (v !== 0 && v < 2 && (h > 0 && i === le.VERTICAL || h < 0 && i === le.HORIZONTAL ? b = m - 2 : b = m + 2), !this.isOutsideZoomedDomain(u, g))
        return ie({ x0: u, x1: g, y0: m, y1: b }, i);
    }).attr("opacity", 1).attr("role", U.GRAPHICS_SYMBOL).attr("aria-roledescription", "bar").attr("aria-label", (c) => c.value), this.addEventListeners();
  }
  addEventListeners() {
    const e = this;
    this.parent.selectAll("path.bar").on("mouseover", function(t, s) {
      const n = x(this);
      n.classed("hovered", !0), e.services.events.dispatchEvent(f.Bar.BAR_MOUSEOVER, {
        event: t,
        element: n,
        datum: s
      }), e.services.events.dispatchEvent(f.Tooltip.SHOW, {
        event: t,
        hoveredElement: n,
        data: [s]
      });
    }).on("mousemove", function(t, s) {
      e.services.events.dispatchEvent(f.Bar.BAR_MOUSEMOVE, {
        event: t,
        element: x(this),
        datum: s
      }), e.services.events.dispatchEvent(f.Tooltip.MOVE, {
        event: t
      });
    }).on("click", function(t, s) {
      e.services.events.dispatchEvent(f.Bar.BAR_CLICK, {
        event: t,
        element: x(this),
        datum: s
      });
    }).on("mouseout", function(t, s) {
      const n = x(this);
      n.classed("hovered", !1), e.services.events.dispatchEvent(f.Bar.BAR_MOUSEOUT, {
        event: t,
        element: n,
        datum: s
      }), e.services.events.dispatchEvent(f.Tooltip.HIDE, {
        hoveredElement: n
      });
    });
  }
  destroy() {
    this.parent.selectAll("path.bar").on("mouseover", null).on("mousemove", null).on("mouseout", null);
    const e = this.services.events;
    e.removeEventListener(f.Legend.ITEM_HOVER, this.handleLegendOnHover), e.removeEventListener(f.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
}
class Wc extends lr {
  constructor() {
    super(...arguments), this.type = "skeleton-lines";
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(e = !0) {
    const t = y(this.getOptions(), "data", "loading"), s = !y(this.getOptions(), "grid", "x", "enabled") && !y(this.getOptions(), "grid", "y", "enabled") && !y(this.getOptions(), "axes", "bottom", "visible") && !y(this.getOptions(), "axes", "left", "visible");
    t && !s ? super.renderGridSkeleton(t) : t && s ? this.renderSparklineSkeleton(t) : this.removeSkeleton();
  }
  renderSparklineSkeleton(e) {
    this.setScales(), this.drawBackdrop(e), this.drawSparkline(e), this.updateBackdropStyle(), e && this.setShimmerEffect("shimmer-lines");
  }
  drawSparkline(e) {
    const t = this.backdrop.attr("width"), s = [100], n = E.appendOrSelect(this.backdrop, "g.y.skeleton"), a = n.selectAll("line").data(s);
    a.enter().append("line").merge(a).attr("x1", 0).attr("x2", t).attr("y1", (i) => i).attr("y2", (i) => i), n.selectAll("line").classed("shimmer-effect-lines", e).classed("empty-state-lines", !e).style(
      "stroke",
      e ? `url(#${this.services.domUtils.generateElementIDString("shimmer-lines")})` : null
    );
  }
  updateBackdropStyle() {
    const e = this.parent;
    this.backdrop = E.appendOrSelect(e, "svg.chart-skeleton.DAII"), E.appendOrSelect(this.backdrop, "rect.chart-skeleton-backdrop").classed("shimmer-effect-lines", !1).classed("shimmer-effect-sparkline", !0).style("stroke", null);
  }
}
class jc extends z {
  constructor() {
    super(...arguments), this.type = "area-stacked", this.renderType = H.SVG, this.handleLegendOnHover = (e) => {
      const { hoveredElement: t } = e.detail, s = this.getOptions(), { groupMapsTo: n } = s.data;
      this.parent.selectAll("path.area").transition("legend-hover-area").call(
        (a) => this.services.transitions.setupTransition({
          transition: a,
          name: "legend-hover-area"
        })
      ).attr("opacity", (a) => y(a, 0, n) !== t.datum().name ? fe.opacity.unselected : fe.opacity.selected);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("path.area").transition("legend-mouseout-area").call(
        (e) => this.services.transitions.setupTransition({
          transition: e,
          name: "legend-mouseout-area"
        })
      ).attr("opacity", fe.opacity.selected);
    };
  }
  init() {
    const e = this.services.events;
    e.addEventListener(f.Legend.ITEM_HOVER, this.handleLegendOnHover), e.addEventListener(f.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(e = !0) {
    const t = this.getComponentContainer({ withinChartClip: !0 }), s = this, n = this.getOptions(), { groupMapsTo: a } = n.data, i = Object.keys(n.axes).some((g) => n.axes[g].percentage), r = this.model.getStackedData({
      percentage: i,
      groups: this.configs.groups
    }), l = y(r, 0, 0), c = this.services.cartesianScales.getDomainAxisPosition({ datum: l }), d = this.services.cartesianScales.getRangeAxisPosition({ datum: l }), p = this.services.cartesianScales.getScaleByPosition(d), h = t.selectAll("path.area").data(r, (g) => y(g, 0, a));
    this.areaGenerator = kt().x(
      (g) => this.services.cartesianScales.getValueThroughAxisPosition(
        c,
        g.data.sharedStackKey
      )
    ).y0((g) => p(g[0])).y1((g) => p(g[1])).curve(this.services.curves.getD3Curve()), h.exit().attr("opacity", 0).remove(), h.enter().append("path").attr("opacity", 0).merge(h).data(r, (g) => y(g, 0, a)).attr("class", "area").attr(
      "class",
      (g) => this.model.getColorClassName({
        classNameTypes: [$.FILL],
        dataGroupName: y(g, 0, a),
        originalClassName: "area"
      })
    ).style("fill", (g) => s.model.getFillColor(y(g, 0, a))).attr("role", U.GRAPHICS_SYMBOL).attr("aria-roledescription", "area").attr("aria-label", (g) => y(g, 0, a)).transition().call(
      (g) => this.services.transitions.setupTransition({
        transition: g,
        name: "area-update-enter",
        animate: e
      })
    ).attr("opacity", fe.opacity.selected).attr("d", this.areaGenerator);
  }
}
class Zc extends $t {
  constructor() {
    super(...arguments), this.type = "stacked-bar", this.renderType = H.SVG, this.handleLegendOnHover = (e) => {
      const { hoveredElement: t } = e.detail, { groupMapsTo: s } = this.model.getOptions().data;
      this.parent.selectAll("path.bar").transition("legend-hover-bar").call(
        (n) => this.services.transitions.setupTransition({
          transition: n,
          name: "legend-hover-bar"
        })
      ).attr("opacity", (n) => n[s] !== t.datum().name ? 0.3 : 1);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("path.bar").transition("legend-mouseout-bar").call(
        (e) => this.services.transitions.setupTransition({
          transition: e,
          name: "legend-mouseout-bar"
        })
      ).attr("opacity", 1);
    };
  }
  init() {
    const e = this.services.events;
    e.addEventListener(f.Legend.ITEM_HOVER, this.handleLegendOnHover), e.addEventListener(f.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(e) {
    const t = this.getComponentContainer({ withinChartClip: !0 }), s = this.getOptions(), { groupMapsTo: n } = s.data, a = this.model.getStackedData({
      groups: this.configs.groups,
      divergent: !0
    }), i = this.model.getActiveDataGroupNames(), r = t.selectAll("g.bars").data(a, (c) => y(c, 0, n));
    r.exit().attr("opacity", 0).remove(), r.enter().append("g").classed("bars", !0).attr("role", U.GROUP).attr("data-name", "bars");
    const l = t.selectAll("g.bars").selectAll("path.bar").data(
      (c) => c,
      (c) => c.data.sharedStackKey
    );
    l.exit().remove(), l.enter().append("path").merge(l).classed("bar", !0).transition().call(
      (c) => this.services.transitions.setupTransition({
        transition: c,
        name: "bar-update-enter",
        animate: e
      })
    ).attr(
      "class",
      (c) => this.model.getColorClassName({
        classNameTypes: [$.FILL],
        dataGroupName: c[n],
        originalClassName: "bar"
      })
    ).style("fill", (c) => this.model.getFillColor(c[n])).attr("d", (c) => {
      const d = c.data.sharedStackKey, p = this.getBarWidth(), h = this.services.cartesianScales.getDomainValue(d) - p / 2, u = h + p, g = this.services.cartesianScales.getRangeValue(c[0]);
      let m = this.services.cartesianScales.getRangeValue(c[1]);
      if (!this.isOutsideZoomedDomain(h, u)) {
        if (Math.abs(m - g) > 0 && Math.abs(m - g) > s.bars.dividerSize) {
          const b = c[0] < 0 && c[1] <= 0;
          b && i.length > 1 ? this.services.cartesianScales.getOrientation() === le.VERTICAL ? m += c[1] === 0 ? 2 : 1 : m -= 1 : b || (this.services.cartesianScales.getOrientation() === le.VERTICAL ? m += 1 : m -= 1);
        }
        return ie(
          { x0: h, x1: u, y0: g, y1: m },
          this.services.cartesianScales.getOrientation()
        );
      }
    }).attr("opacity", 1).attr("role", U.GRAPHICS_SYMBOL).attr("aria-roledescription", "bar").attr("aria-label", (c) => c[1] - c[0]), this.addEventListeners();
  }
  addEventListeners() {
    const e = this.getOptions(), { groupMapsTo: t } = e.data, s = this;
    this.parent.selectAll("path.bar").on("mouseover", function(n, a) {
      const i = x(this);
      i.classed("hovered", !0), s.services.events.dispatchEvent(f.Bar.BAR_MOUSEOVER, {
        event: n,
        element: i,
        datum: a
      });
      let l = s.model.getDisplayData(s.configs.groups).find((c) => {
        const d = s.services.cartesianScales.getDomainIdentifier(c), p = s.services.cartesianScales.getRangeIdentifier(c);
        return c[p] === a.data[a[t]] && c[d].toString() === a.data.sharedStackKey && c[t] === a[t];
      });
      if (l === void 0) {
        const c = s.services.cartesianScales.getDomainIdentifier(), d = s.services.cartesianScales.getRangeIdentifier();
        l = {
          [c]: a.data.sharedStackKey,
          [d]: a.data[a[t]],
          [t]: a[t]
        };
      }
      s.services.events.dispatchEvent(f.Tooltip.SHOW, {
        event: n,
        hoveredElement: i,
        data: [l]
      });
    }).on("mousemove", function(n, a) {
      const i = x(this);
      s.services.events.dispatchEvent(f.Bar.BAR_MOUSEMOVE, {
        event: n,
        element: i,
        datum: a
      }), s.services.events.dispatchEvent(f.Tooltip.MOVE, {
        event: n
      });
    }).on("click", function(n, a) {
      s.services.events.dispatchEvent(f.Bar.BAR_CLICK, {
        event: n,
        element: x(this),
        datum: a
      });
    }).on("mouseout", function(n, a) {
      const i = x(this);
      i.classed("hovered", !1), s.services.events.dispatchEvent(f.Bar.BAR_MOUSEOUT, {
        event: n,
        element: i,
        datum: a
      }), s.services.events.dispatchEvent(f.Tooltip.HIDE, {
        hoveredElement: i
      });
    });
  }
  getBarWidth() {
    const e = this.getOptions();
    if (y(e, "bars", "width"))
      return e.bars.width;
    const t = this.services.cartesianScales.getMainXScale(), s = E.getSVGElementSize(this.parent, {
      useAttrs: !0
    }).width, n = this.model.getStackKeys().length, a = y(e, "bars", "spacingFactor");
    return t.step ? Math.min(e.bars.maxWidth, t.step() / 2) : Math.min(e.bars.maxWidth, s * a / n);
  }
  destroy() {
    this.parent.selectAll("path.bar").on("mouseover", null).on("mousemove", null).on("mouseout", null);
    const e = this.services.events;
    e.removeEventListener(f.Legend.ITEM_HOVER, this.handleLegendOnHover), e.removeEventListener(f.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
}
class Xc extends Vt {
  constructor() {
    super(...arguments), this.type = "scatter-stacked", this.renderType = H.SVG;
  }
  render(e) {
    if (!y(this.getOptions(), "points", "enabled"))
      return;
    const s = this.getComponentContainer({ withinChartClip: !0 }), n = this.getOptions(), { groupMapsTo: a } = n.data, i = Object.keys(n.axes).some((u) => n.axes[u].percentage), r = this.model.getStackedData({
      groups: this.configs.groups,
      percentage: i
    }), l = s.selectAll("g.dots").data(r, (u) => y(u, 0, a));
    l.exit().attr("opacity", 0).remove();
    const d = l.enter().append("g").classed("dots", !0).attr("role", U.GROUP).merge(l).selectAll("circle.dot").data((u) => u);
    d.exit().attr("opacity", 0).remove();
    const h = d.enter().append("circle").classed("dot", !0).attr("opacity", 0).merge(d).datum((u) => {
      const g = u[a], m = this.services.cartesianScales.getDomainIdentifier(u), b = this.services.cartesianScales.getRangeIdentifier(u);
      return {
        [a]: g,
        [m]: u.data.sharedStackKey,
        [b]: u[1]
      };
    });
    this.styleCircles(h, e), this.addEventListeners();
  }
  getTooltipData(e, t) {
    const s = this.getOptions(), { groupMapsTo: n } = s.data, a = Object.keys(s.axes).some((l) => s.axes[l].percentage), i = this.model.getStackedData({
      groups: this.configs.groups,
      percentage: a
    }), r = [];
    return i.forEach((l, c) => {
      l.forEach((d, p) => {
        const h = d[n], u = d.data.sharedStackKey;
        let g = d.data[h];
        const m = d[1], b = this.services.cartesianScales.getDomainIdentifier(d), v = this.services.cartesianScales.getRangeIdentifier(d);
        g != null && e === this.services.cartesianScales.getDomainValue(u) && t === this.services.cartesianScales.getRangeValue(m) && (a && (g = this.model.getStackedData({
          groups: this.configs.groups
        })[c][p].data[h]), g !== null && r.push({
          [n]: h,
          [b]: u,
          [v]: g
        }));
      });
    }), this.model.getDisplayData(this.configs.groups).filter((l) => {
      const c = this.services.cartesianScales.getDomainIdentifier(l), d = this.services.cartesianScales.getRangeIdentifier(l);
      return r.find((p) => p[n] == l[n] && p[c] == l[c] && p[d] == l[d]) !== void 0;
    });
  }
}
const Ae = 6;
class Yc extends z {
  constructor() {
    super(...arguments), this.type = "tree", this.renderType = H.SVG;
  }
  getLongestLabel(e) {
    let t = "";
    return e.forEach((s) => {
      const n = s.children ? this.getLongestLabel(s.children) : "";
      (n.length > t.length || s.name.length > t.length) && (t = n.length > s.name.length ? n : s.name);
    }), t;
  }
  getMockLabelWidth(e, t) {
    const s = e.append("text").attr("dy", "0.31em").attr("x", 0).attr("text-anchor", "end").text(t), { width: n } = E.getSVGElementSize(s.node(), {
      useBBox: !0
    });
    return s.remove(), n;
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(e = !0) {
    const t = this.getComponentContainer();
    t.html("");
    const { width: s, height: n } = E.getSVGElementSize(this.parent, {
      useAttrs: !0
    });
    if (s < 1 || n < 1)
      return;
    const a = this.model.getOptions(), i = this.model.getDisplayData(), r = y(a, "tree", "rootTitle") || "Tree", l = this.getMockLabelWidth(t, r), c = this.getLongestLabel(i), d = this.getMockLabelWidth(t, c), p = {
      top: 0,
      right: 0,
      bottom: 0,
      left: l > 0 ? l + Ae : 30 - Ae
    }, h = Pt({
      name: r,
      children: i
    }), u = 10, g = s / 6, m = (O) => {
      const k = h.descendants().reverse(), I = h.links();
      let F = h, P = h;
      h.eachBefore((N) => {
        N.x < F.x && (F = N), N.x > P.x && (P = N);
      });
      const A = P.x - F.x, M = t.transition().call(
        (N) => this.services.transitions.setupTransition({
          transition: N,
          name: "tree-update-viewbox",
          animate: !0
        })
      ).attr("viewBox", [-p.left, F.x, s, A].join(" ")), G = L.selectAll("g").data(k, (N) => N.id), D = this, X = G.enter().append("g").attr("transform", () => `translate(${O.y0},${O.x0})`).attr(
        "class",
        (N) => N.depth !== 0 && N.children && N.children.length > 0 ? "clickable" : null
      ).on("mouseover", function(N, ae) {
        D.services.events.dispatchEvent(f.Tree.NODE_MOUSEOVER, {
          event: N,
          element: x(this),
          datum: ae
        });
      }).on("click", function(N, ae) {
        ae.depth !== 0 && (ae.children = ae.children ? null : ae._children, m(ae)), D.services.events.dispatchEvent(f.Tree.NODE_CLICK, {
          event: N,
          element: x(this),
          datum: ae
        });
      }).on("mouseout", function(N, ae) {
        D.services.events.dispatchEvent(f.Tree.NODE_MOUSEOUT, {
          event: N,
          element: x(this),
          datum: ae
        });
      });
      X.append("circle").attr("r", 2.5).attr("class", (N) => N._children ? "parent" : "child").attr("stroke-width", 10), X.append("text").attr("dy", "0.31em").attr("x", (N) => N._children ? -Ae : Ae).attr("text-anchor", (N) => N._children ? "end" : "start").text((N) => N.data.name).clone(!0).attr("class", "text-stroke").lower(), G.merge(X).transition(M).attr("transform", (N) => `translate(${N.y},${N.x})`).attr("fill-opacity", 1).attr("stroke-opacity", 1), G.exit().transition(M).remove().attr("transform", () => `translate(${O.y},${O.x})`).attr("fill-opacity", 0).attr("stroke-opacity", 0);
      const re = w.selectAll("path").data(I, (N) => N.target.id), W = re.enter().append("path").attr("d", () => {
        const N = { x: O.x0, y: O.y0 };
        return T({ source: N, target: N });
      });
      re.merge(W).transition(M).attr("d", T), re.exit().transition(M).remove().attr("d", () => {
        const N = { x: O.x, y: O.y };
        return T({ source: N, target: N });
      }), h.eachBefore((N) => {
        N.x0 = N.x, N.y0 = N.y;
      });
    }, b = h.descendants(), v = b[b.length - 1].depth, S = y(a, "tree", "type") === Pn.DENDROGRAM ? ln().size([
      n,
      s - d - v * Ae - l
    ]) : cn().nodeSize([u, g]).size([
      n,
      s - d - v * Ae - l
    ]), T = dn().x((O) => O.y).y((O) => O.x);
    h.x0 = g / 2, h.y0 = 0, h.descendants().forEach((O, k) => {
      O.id = k, O._children = O.children;
    }), S(h), t.attr("viewBox", [-p.left, -p.top, s, u]).style("user-select", "none");
    const w = t.append("g").attr("class", "links"), L = t.append("g").attr("class", "nodes");
    m(h);
  }
}
var br = "#000000", Er = "#ffffff", Sr = "#fcf4d6", xr = "#fddc69", Or = "#f1c21b", Tr = "#d2a106", Lr = "#b28600", wr = "#8e6a00", Mr = "#684e00", Ar = "#483700", Cr = "#302400", kr = "#1c1500", Ir = {
  10: Sr,
  20: xr,
  30: Or,
  40: Tr,
  50: Lr,
  60: wr,
  70: Mr,
  80: Ar,
  90: Cr,
  100: kr
}, Rr = "#fff2e8", Dr = "#ffd9be", _r = "#ffb784", Pr = "#ff832b", Vr = "#eb6200", Br = "#ba4e00", $r = "#8a3800", Gr = "#5e2900", Nr = "#3e1a00", Hr = "#231000", Ur = {
  10: Rr,
  20: Dr,
  30: _r,
  40: Pr,
  50: Vr,
  60: Br,
  70: $r,
  80: Gr,
  90: Nr,
  100: Hr
}, zr = "#fff1f1", Fr = "#ffd7d9", Wr = "#ffb3b8", jr = "#ff8389", Zr = "#fa4d56", Xr = "#da1e28", Yr = "#a2191f", qr = "#750e13", Kr = "#520408", Jr = "#2d0709", Qr = {
  10: zr,
  20: Fr,
  30: Wr,
  40: jr,
  50: Zr,
  60: Xr,
  70: Yr,
  80: qr,
  90: Kr,
  100: Jr
}, eo = "#fff0f7", to = "#ffd6e8", so = "#ffafd2", no = "#ff7eb6", ao = "#ee5396", io = "#d02670", ro = "#9f1853", oo = "#740937", lo = "#510224", co = "#2a0a18", ho = {
  10: eo,
  20: to,
  30: so,
  40: no,
  50: ao,
  60: io,
  70: ro,
  80: oo,
  90: lo,
  100: co
}, uo = "#f6f2ff", po = "#e8daff", go = "#d4bbff", mo = "#be95ff", fo = "#a56eff", vo = "#8a3ffc", yo = "#6929c4", bo = "#491d8b", Eo = "#31135e", So = "#1c0f30", xo = {
  10: uo,
  20: po,
  30: go,
  40: mo,
  50: fo,
  60: vo,
  70: yo,
  80: bo,
  90: Eo,
  100: So
}, Oo = "#edf5ff", To = "#d0e2ff", Lo = "#a6c8ff", wo = "#78a9ff", Mo = "#4589ff", Ao = "#0f62fe", Co = "#0043ce", ko = "#002d9c", Io = "#001d6c", Ro = "#001141", Do = {
  10: Oo,
  20: To,
  30: Lo,
  40: wo,
  50: Mo,
  60: Ao,
  70: Co,
  80: ko,
  90: Io,
  100: Ro
}, _o = "#e5f6ff", Po = "#bae6ff", Vo = "#82cfff", Bo = "#33b1ff", $o = "#1192e8", Go = "#0072c3", No = "#00539a", Ho = "#003a6d", Uo = "#012749", zo = "#061727", Fo = {
  10: _o,
  20: Po,
  30: Vo,
  40: Bo,
  50: $o,
  60: Go,
  70: No,
  80: Ho,
  90: Uo,
  100: zo
}, Wo = "#d9fbfb", jo = "#9ef0f0", Zo = "#3ddbd9", Xo = "#08bdba", Yo = "#009d9a", qo = "#007d79", Ko = "#005d5d", Jo = "#004144", Qo = "#022b30", el = "#081a1c", tl = {
  10: Wo,
  20: jo,
  30: Zo,
  40: Xo,
  50: Yo,
  60: qo,
  70: Ko,
  80: Jo,
  90: Qo,
  100: el
}, sl = "#defbe6", nl = "#a7f0ba", al = "#6fdc8c", il = "#42be65", rl = "#24a148", ol = "#198038", ll = "#0e6027", cl = "#044317", dl = "#022d0d", hl = "#071908", ul = {
  10: sl,
  20: nl,
  30: al,
  40: il,
  50: rl,
  60: ol,
  70: ll,
  80: cl,
  90: dl,
  100: hl
}, pl = "#f2f4f8", gl = "#dde1e6", ml = "#c1c7cd", fl = "#a2a9b0", vl = "#878d96", yl = "#697077", bl = "#4d5358", El = "#343a3f", Sl = "#21272a", xl = "#121619", Ol = {
  10: pl,
  20: gl,
  30: ml,
  40: fl,
  50: vl,
  60: yl,
  70: bl,
  80: El,
  90: Sl,
  100: xl
}, Tl = "#f4f4f4", Ll = "#e0e0e0", wl = "#c6c6c6", Ml = "#a8a8a8", Al = "#8d8d8d", Cl = "#6f6f6f", kl = "#525252", Il = "#393939", Rl = "#262626", Dl = "#161616", _l = {
  10: Tl,
  20: Ll,
  30: wl,
  40: Ml,
  50: Al,
  60: Cl,
  70: kl,
  80: Il,
  90: Rl,
  100: Dl
}, Pl = "#f7f3f2", Vl = "#e5e0df", Bl = "#cac5c4", $l = "#ada8a8", Gl = "#8f8b8b", Nl = "#726e6e", Hl = "#565151", Ul = "#3c3838", zl = "#272525", Fl = "#171414", Wl = {
  10: Pl,
  20: Vl,
  30: Bl,
  40: $l,
  50: Gl,
  60: Nl,
  70: Hl,
  80: Ul,
  90: zl,
  100: Fl
}, ps = {
  black: {
    100: br
  },
  blue: Do,
  coolGray: Ol,
  cyan: Fo,
  gray: _l,
  green: ul,
  magenta: ho,
  orange: Ur,
  purple: xo,
  red: Qr,
  teal: tl,
  warmGray: Wl,
  white: {
    0: Er
  },
  yellow: Ir
};
const jl = (o) => {
  if (!o)
    return null;
  for (const e of Object.keys(ps)) {
    const t = ps[e];
    for (const s of Object.keys(t))
      if (t[+s] === o)
        return s;
  }
  return null;
}, gs = function() {
  const o = x(this.parentNode).select("rect.leaf"), e = getComputedStyle(o.node(), null).getPropertyValue(
    "fill"
  ), t = bs(e);
  let s;
  if (t && (s = jl(t ? t.hex() : null)), s == null) {
    const n = ys(t).l;
    s = Math.abs(n * 100 - 100);
  }
  return s > 50 ? "white" : "black";
};
let Zl = 0;
class qc extends z {
  constructor() {
    super(...arguments), this.type = "treemap", this.renderType = H.SVG, this.handleLegendOnHover = (e) => {
      const { hoveredElement: t } = e.detail;
      this.parent.selectAll("g[data-name='leaf']").transition("legend-hover-treemap").call(
        (s) => this.services.transitions.setupTransition({
          transition: s,
          name: "legend-hover-treemap"
        })
      ).attr(
        "opacity",
        (s) => s.parent.data.name === t.datum().name ? 1 : 0.3
      );
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("g[data-name='leaf']").transition("legend-mouseout-treemap").call(
        (e) => this.services.transitions.setupTransition({
          transition: e,
          name: "legend-mouseout-treemap"
        })
      ).attr("opacity", 1);
    };
  }
  init() {
    const { events: e } = this.services;
    e.addEventListener(f.Legend.ITEM_HOVER, this.handleLegendOnHover), e.addEventListener(f.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(e = !0) {
    const t = this.getComponentContainer();
    this.model.getData();
    const s = this.model.getDisplayData(), n = this.model.getOptions(), a = y(window, "location"), { width: i, height: r } = E.getSVGElementSize(t, {
      useAttrs: !0
    }), l = Pt({
      name: n.title || "Treemap",
      children: s
    }).sum((m) => m.value).sort((m, b) => b.value - m.value), c = hn().size([i, r]).paddingInner(1).paddingOuter(0).round(!0)(
      l
    ), d = t.selectAll("g[data-name='leaf']").data(c.leaves(), (m) => m.data.name);
    d.exit().attr("opacity", 0).remove();
    const h = d.enter().append("g").attr("data-name", "leaf").attr("data-uid", () => Zl++).merge(d);
    h.attr("data-name", "leaf").transition().call(
      (m) => this.services.transitions.setupTransition({
        transition: m,
        name: "treemap-group-update",
        animate: e
      })
    ).attr("transform", (m) => `translate(${m.x0},${m.y0})`);
    const u = h.selectAll("rect.leaf").data((m) => [m]);
    u.exit().attr("width", 0).attr("height", 0).remove(), u.enter().append("rect").classed("leaf", !0).merge(u).attr("width", 0).attr("height", 0).attr("id", function() {
      const m = x(this.parentNode).attr("data-uid");
      return `${n.style.prefix}-leaf-${m}`;
    }).attr("class", (m) => {
      for (; m.depth > 1; )
        m = m.parent;
      return this.model.getColorClassName({
        classNameTypes: [$.FILL],
        dataGroupName: m.data.name,
        originalClassName: "leaf"
      });
    }).transition().call(
      (m) => this.services.transitions.setupTransition({
        transition: m,
        name: "treemap-leaf-update-enter",
        animate: e
      })
    ).attr("width", (m) => m.x1 - m.x0).attr("height", (m) => m.y1 - m.y0).style("fill", (m) => {
      for (; m.depth > 1; )
        m = m.parent;
      return this.model.getFillColor(m.data.name);
    }), h.selectAll("clipPath").data(
      (m) => m.data.showLabel !== !0 ? [] : [1],
      (m) => m
    ).join(
      (m) => m.append("clipPath").attr("id", function() {
        const b = x(this.parentNode).attr("data-uid");
        return `${n.style.prefix}-clip-${b}`;
      }).append("use").attr("xlink:href", function() {
        const b = x(this.parentNode.parentNode).attr("data-uid"), v = `${n.style.prefix}-leaf-${b}`;
        return new URL(`#${v}`, a) + "";
      }),
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      (m) => null,
      (m) => m.remove()
    ), h.selectAll("text").data(
      (m) => {
        if (m.data.showLabel !== !0)
          return [];
        let b = m;
        for (; b.depth > 1; )
          b = b.parent;
        const v = ys(this.model.getFillColor(b.data.name));
        return [
          {
            text: m.data.name,
            color: v.l < 0.5 ? "white" : "black"
          }
        ];
      },
      (m) => m
    ).join(
      (m) => {
        const b = m.append("text").text((v) => v.text).style("fill", gs).attr("x", 7).attr("y", 18);
        return a && b.attr("clip-path", function() {
          const v = x(this.parentNode).attr("data-uid"), S = `${n.style.prefix}-clip-${v}`;
          return `url(${new URL(`#${S}`, a) + ""})`;
        }), b;
      },
      (m) => m.text((b) => b.text).style("fill", gs),
      (m) => m.remove()
    ), this.addEventListeners();
  }
  addEventListeners() {
    const e = this;
    this.parent.selectAll("rect.leaf").on("mouseover", function(t, s) {
      const n = x(this);
      let a = getComputedStyle(this, null).getPropertyValue("fill"), i = s;
      for (; i.depth > 1; )
        i = i.parent;
      n.transition("graph_element_mouseover_fill_update").call(
        (r) => e.services.transitions.setupTransition({
          transition: r,
          name: "graph_element_mouseover_fill_update"
        })
      ).style("fill", (r) => {
        const l = e.model.getFillColor(r.parent.data.name);
        return l && (a = l), bs(a).darker(0.7).toString();
      }), e.services.events.dispatchEvent(f.Tooltip.SHOW, {
        event: t,
        hoveredElement: n,
        items: [
          {
            color: a,
            label: i.data.name,
            bold: !0
          },
          {
            label: s.data.name,
            value: s.data.value
          }
        ]
      }), e.services.events.dispatchEvent(f.Treemap.LEAF_MOUSEOVER, {
        event: t,
        element: n,
        datum: s
      });
    }).on("mousemove", function(t, s) {
      const n = x(this);
      e.services.events.dispatchEvent(f.Treemap.LEAF_MOUSEMOVE, {
        event: t,
        element: n,
        datum: s
      }), e.services.events.dispatchEvent(f.Tooltip.MOVE, {
        event: t
      });
    }).on("click", function(t, s) {
      e.services.events.dispatchEvent(f.Treemap.LEAF_CLICK, {
        event: t,
        element: x(this),
        datum: s
      });
    }).on("mouseout", function(t, s) {
      const n = x(this);
      n.classed("hovered", !1);
      let a = s;
      for (; a.depth > 1; )
        a = a.parent;
      n.transition().call(
        (i) => e.services.transitions.setupTransition({
          transition: i,
          name: "graph_element_mouseout_fill_update"
        })
      ).style("fill", (i) => e.model.getFillColor(i.parent.data.name)), e.services.events.dispatchEvent(f.Treemap.LEAF_MOUSEOUT, {
        event: t,
        element: n,
        datum: s
      }), e.services.events.dispatchEvent(f.Tooltip.HIDE, {
        hoveredElement: n
      });
    });
  }
}
class Kc extends z {
  constructor() {
    super(...arguments), this.type = "wordcloud", this.renderType = H.SVG, this.handleLegendOnHover = (e) => {
      const { hoveredElement: t } = e.detail, { groupMapsTo: s } = this.getOptions().data;
      this.parent.selectAll("text.word").transition("legend-hover-wordcloud").call(
        (n) => this.services.transitions.setupTransition({
          transition: n,
          name: "legend-hover-wordcloud"
        })
      ).attr("opacity", (n) => n[s] !== t.datum().name ? 0.3 : 1);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("text.word").transition("legend-mouseout-wordcloud").call(
        (e) => this.services.transitions.setupTransition({
          transition: e,
          name: "legend-mouseout-wordcloud"
        })
      ).attr("opacity", 1);
    };
  }
  init() {
    const e = this.services.events;
    e.addEventListener(f.Legend.ITEM_HOVER, this.handleLegendOnHover), e.addEventListener(f.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(e = !0) {
    const t = this, s = this.getComponentContainer().attr("width", "100%").attr("height", "100%"), n = this.model.getDisplayData(), a = this.getFontSizeScale(n), i = this.getOptions(), { fontSizeMapsTo: r, wordMapsTo: l } = i.wordCloud, { groupMapsTo: c } = i.data, { width: d, height: p } = E.getSVGElementSize(s, {
      useAttrs: !0
    });
    if (d === 0 || p === 0)
      return;
    const h = zn().size([d, p]).words(
      n.map(function(g) {
        const m = g[r];
        if (typeof g[r] != "number")
          throw Error(
            "Badly formatted WordCloud data. `value` should only be an integer or float"
          );
        return {
          [c]: g[c],
          text: g[l],
          size: m,
          value: m
        };
      })
    ).padding(5).rotate(0).fontSize((g) => a(g.size)).on("end", u);
    h.start();
    function u(g) {
      const m = E.appendOrSelect(s, "g.words");
      m.attr("transform", `translate(${h.size()[0] / 2}, ${h.size()[1] / 2})`);
      const b = m.selectAll("text").data(g, (S) => `${S[c]}-${S.text}`);
      b.exit().attr("opacity", 0).remove(), b.enter().append("text").attr("opacity", 0).merge(b).style("font-size", (S) => `${S.size}px`).text(function(S) {
        return S.text;
      }).attr(
        "class",
        (S) => t.model.getColorClassName({
          classNameTypes: [$.FILL],
          dataGroupName: S[c],
          originalClassName: `word ${S.size > 32 ? "light" : ""}`
        })
      ).style("fill", (S) => t.model.getFillColor(S[c], S.text, S)).attr("text-anchor", "middle").transition().call(
        (S) => t.services.transitions.setupTransition({
          transition: S,
          name: "wordcloud-text-update-enter",
          animate: e
        })
      ).attr("transform", (S) => `translate(${S.x}, ${S.y})`).attr("opacity", 1);
    }
    this.addEventListeners();
  }
  getFontSizeScale(e) {
    const t = this.getOptions(), { fontSizeMapsTo: s } = t.wordCloud, n = e.map((l) => l[s]).filter((l) => l), a = E.getHTMLElementSize(this.services.domUtils.getMainContainer()), i = n.length > 0, r = i ? Qe(n) : [1, 1];
    return Oe().domain(r).range(i ? t.wordCloud.fontSizeRange(a, e) : [4, 4]);
  }
  addEventListeners() {
    const e = this.getOptions(), { groupMapsTo: t } = e.data, s = this, n = gt((a) => {
      const i = s.parent.selectAll("text.word").transition("wordcloud-word-mouse-highlight").call(
        (r) => s.services.transitions.setupTransition({
          transition: r,
          name: "wordcloud-word-mouse-highlight"
        })
      );
      a === null ? i.attr("opacity", 1) : i.attr("opacity", function() {
        return a === this ? 1 : 0.3;
      });
    }, 6);
    this.parent.selectAll("text.word").on("mouseover", function(a, i) {
      const r = this;
      n(r), s.services.events.dispatchEvent(f.WordCloud.WORD_MOUSEOVER, {
        event: a,
        element: x(this),
        datum: i
      }), s.services.events.dispatchEvent(f.Tooltip.SHOW, {
        event: a,
        hoveredElement: r,
        items: [
          {
            label: e.tooltip.wordLabel,
            value: i.text
          },
          {
            label: e.tooltip.valueLabel,
            value: i.value
          },
          {
            label: e.tooltip.groupLabel,
            value: i[t],
            class: s.model.getColorClassName({
              classNameTypes: [$.TOOLTIP],
              dataGroupName: i[t]
            })
          }
        ]
      });
    }).on("mousemove", function(a, i) {
      const r = x(this);
      s.services.events.dispatchEvent(f.WordCloud.WORD_MOUSEMOVE, {
        element: r,
        datum: i
      }), s.services.events.dispatchEvent(f.Tooltip.MOVE, {
        event: a
      });
    }).on("click", function(a, i) {
      s.services.events.dispatchEvent(f.WordCloud.WORD_CLICK, {
        event: a,
        element: x(this),
        datum: i
      });
    }).on("mouseout", function(a, i) {
      const r = x(this);
      n(null), s.services.events.dispatchEvent(f.WordCloud.WORD_MOUSEOUT, {
        event: a,
        element: r,
        datum: i
      }), s.services.events.dispatchEvent(f.Tooltip.HIDE, {
        hoveredElement: r
      });
    });
  }
}
class Xl extends z {
  constructor() {
    super(...arguments), this.type = "geo", this.renderType = H.SVG;
  }
  render() {
    const e = this.getComponentContainer({ withinChartClip: !0 }), { width: t, height: s } = E.getSVGElementSize(e, {
      useAttrs: !0
    });
    if (t < 1 || s < 1)
      return;
    const n = this.getProjection(), a = y(this.getOptions(), "geoData"), i = this.model.getCombinedData(), r = {}, l = {};
    Object.keys(i).forEach((v) => {
      typeof i[v].value == "number" ? r[v] = i[v] : l[v] = i[v];
    });
    const c = mr(a, Object.values(l)), d = ur(a, {
      // We need to specify that we are converting geometry collections
      type: "GeometryCollection",
      geometries: Object.values(r)
    }), p = n.fitSize([t, s], d), h = un().projection(p);
    E.appendOrSelect(e, "g.geo").selectAll("path").data(d.features).join("path").attr("d", h);
    const g = this.services.domUtils.generateElementIDString("geo-pattern-stripes"), m = E.appendOrSelect(e, "defs");
    E.appendOrSelect(m, "pattern").attr("id", g).attr("width", 5).attr("height", 10).attr("patternUnits", "userSpaceOnUse").attr("patternTransform", "rotate(45)").append("path").classed("pattern-fill", !0).attr(
      "d",
      It()([
        [0, 0],
        [0, 10]
      ])
    );
    const b = E.appendOrSelect(e, "g.missing-data");
    E.appendOrSelect(b, "path").datum(c).attr("d", h).style("fill", `url(#${g})`);
  }
  /**
   * @info
   * Depending on projection, we may need to provide additional configuration
   * e.g. sizing
   *
   * In such case, function can be refactored so that
   * projection should return an object with the configuraiton & function
   */
  getProjection() {
    let e = null;
    switch (y(this.getOptions(), "thematic", "projection")) {
      case xe.geoEqualEarth:
        e = bn();
        break;
      case xe.geoAlbers:
        e = yn();
        break;
      case xe.geoConicEqualArea:
        e = vn();
        break;
      case xe.geoConicEquidistant:
        e = fn();
        break;
      case xe.geoEquirectangular:
        e = mn();
        break;
      case xe.geoMercator:
        e = gn();
        break;
      case xe.geoNaturalEarth1:
        e = pn();
        break;
      default:
        throw new Error("Projection is not supported.");
    }
    return e;
  }
}
class Jc extends Xl {
  constructor() {
    super(...arguments), this.type = "choropleth";
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(e = !0) {
    super.render();
    const t = this.model.getCombinedData();
    this.getComponentContainer({ withinChartClip: !0 }).select("g.geo").selectAll("path").classed("border", !0).attr("class", (a) => this.model.getColorClassName({
      value: t[a.properties.NAME].value,
      originalClassName: "border"
    })), this.addCountryAreaEventListener();
  }
  addCountryAreaEventListener() {
    const e = this, t = this.model.getCombinedData();
    this.parent.selectAll("path.border").on("mouseover", function(s, n) {
      const a = x(this);
      e.services.events.dispatchEvent(Fe.CHOROPLETH_MOUSEOVER, {
        event: s,
        element: a,
        datum: t[n.properties.NAME]
      }), e.services.events.dispatchEvent(lt.SHOW, {
        event: s,
        hoveredElement: a,
        items: [
          {
            label: n.properties.NAME,
            value: t[n.properties.NAME].value
          }
        ]
      });
    }).on("mousemove", function(s, n) {
      e.services.events.dispatchEvent(Fe.CHOROPLETH_MOUSEMOVE, {
        event: s,
        element: x(this),
        datum: t[n.properties.NAME]
      }), e.services.events.dispatchEvent(lt.MOVE, {
        event: s
      });
    }).on("click", function(s, n) {
      e.services.events.dispatchEvent(Fe.CHOROPLETH_CLICK, {
        event: s,
        element: x(this),
        datum: t[n.properties.NAME]
      });
    }).on("mouseout", function(s, n) {
      const a = x(this);
      e.services.events.dispatchEvent(Fe.CHOROPLETH_MOUSEOUT, {
        event: s,
        element: a,
        datum: t[n.properties.NAME]
      }), e.services.events.dispatchEvent(lt.HIDE, {
        event: s,
        hoveredElement: a
      });
    });
  }
}
export {
  Ac as $,
  uc as A,
  yc as B,
  oc as C,
  Vc as D,
  Gc as E,
  xc as F,
  gc as G,
  hc as H,
  Nc as I,
  Wc as J,
  Hc as K,
  nr as L,
  rc as M,
  _c as N,
  Uc as O,
  yr as P,
  zc as Q,
  Xs as R,
  ic as S,
  sr as T,
  Yc as U,
  qc as V,
  Kc as W,
  Ys as X,
  or as Y,
  cc as Z,
  Mc as _,
  nc as a,
  wc as a0,
  Lc as a1,
  Tc as a2,
  Cc as a3,
  kc as a4,
  Ic as a5,
  Rc as a6,
  Xl as a7,
  $t as a8,
  z as a9,
  ac as b,
  Da as c,
  ir as d,
  ar as e,
  lc as f,
  dc as g,
  pc as h,
  vc as i,
  fc as j,
  mc as k,
  Vt as l,
  lr as m,
  bc as n,
  Ec as o,
  Sc as p,
  Dc as q,
  Jc as r,
  Pc as s,
  jc as t,
  Xc as u,
  Oc as v,
  Fc as w,
  $c as x,
  Zc as y,
  Bc as z
};
//# sourceMappingURL=choropleth-17b85d55.mjs.map
