import { t as Y, g as l, m as a, o as r, e as J, f as V } from "./color-scale-utils-faf67b75.mjs";
import { T as Bt, j as It, l as Ht, n as Gt, p as Vt, q as Nt, s as Ut, d as Zt, u as _t, v as zt, L as Wt, h as jt, w as $t, M as Kt, N as Jt, O as qt, P as Xt, Q as Qt, x as Yt, y as eo, R as so, z as to, A as oo, B as no, C as io, D as ro, E as ao, F as ho, G as co, J as mo, H as lo, I as po, K as Co } from "./color-scale-utils-faf67b75.mjs";
import { i as vo } from "./index-ec554115.mjs";
import { ChartModel as Re, ChartModelCartesian as Te, AlluvialChartModel as be, BoxplotChartModel as Oe, BulletChartModel as fe, ChoroplethModel as Se, CirclePackChartModel as Ae, PieChartModel as xe, GaugeChartModel as ye, HeatmapModel as De, ChartModelBinned as Fe, MeterChartModel as Le, RadarChartModel as Pe, TreeChartModel as Me, TreemapChartModel as ke, WordCloudModel as Be } from "./model/index.mjs";
import { _ as j, r as i, q as c, L as Z, y as A, t as N, e as $, S as Ie, u as K, F as p, l as R } from "./enums-a96ef472.mjs";
import { A as wo, a as Eo, b as Ro, c as To, d as bo, f as Oo, B as fo, g as So, C as Ao, h as xo, i as yo, j as Do, k as Fo, m as Lo, n as Po, D as Mo, o as ko, G as Bo, p as Io, s as Ho, v as Go, M as Vo, w as No, P as Uo, x as Zo, R as _o, z as zo, H as Wo, T as jo, I as $o, J as Ko, K as Jo, N as qo, O as Xo, Q as Qo, U as Yo, V as en, W as sn, Z as tn, X as on, Y as nn } from "./enums-a96ef472.mjs";
import { c as He, L as ee, C as Ge, T as _, a as z, b as g, S as F, d as se, M as W, e as Ve, f as Ne, g as Ue, H as Ze, Z as _e, A as te, h as ze, i as d, G as w, R as B, j as k, k as oe, l as M, m as C, B as We, n as I, o as je, p as $e, q as ne, r as Ke, s as Je, t as ie, u as re, v as U, w as ae, x as he, y as ce, P as qe, D as Xe, z as Qe, E as Ye, F as es, I as ss, J as ts, K as os, N as ns, O as is, Q as rs, U as as, V as hs, W as cs } from "./choropleth-17b85d55.mjs";
import { X as an, a8 as hn, a9 as cn, a7 as mn, Y as ln, _ as pn, $ as dn, a0 as Cn, a1 as un, a2 as vn, a3 as gn, a4 as wn, a5 as En, a6 as Rn } from "./choropleth-17b85d55.mjs";
import { C as ms, E as ls, F as ps, T as ds, a as Cs, b as us, Z as vs, f as gs } from "./index-b0e98af9.mjs";
import { D as ws, G as Es } from "./angle-utils-6b17e95b.mjs";
import { S as bn, d as On, a as fn, p as Sn, b as An, r as xn } from "./angle-utils-6b17e95b.mjs";
import "d3";
import "./a11y-7bad4f48.mjs";
import "./_baseEach-76cda8a8.mjs";
import "d3-sankey";
import "d3-cloud";
function Rs(o, e, s) {
  var n = -1, t = o.length;
  e < 0 && (e = -e > t ? 0 : t + e), s = s > t ? t : s, s < 0 && (s += t), t = e > s ? 0 : s - e >>> 0, e >>>= 0;
  for (var h = Array(t); ++n < t; )
    h[n] = o[n + e];
  return h;
}
function Ts(o, e, s) {
  var n = o.length;
  return s = s === void 0 ? n : s, !e && s >= n ? o : Rs(o, e, s);
}
var bs = "\\ud800-\\udfff", Os = "\\u0300-\\u036f", fs = "\\ufe20-\\ufe2f", Ss = "\\u20d0-\\u20ff", As = Os + fs + Ss, xs = "\\ufe0e\\ufe0f", ys = "\\u200d", Ds = RegExp("[" + ys + bs + As + xs + "]");
function me(o) {
  return Ds.test(o);
}
function Fs(o) {
  return o.split("");
}
var le = "\\ud800-\\udfff", Ls = "\\u0300-\\u036f", Ps = "\\ufe20-\\ufe2f", Ms = "\\u20d0-\\u20ff", ks = Ls + Ps + Ms, Bs = "\\ufe0e\\ufe0f", Is = "[" + le + "]", q = "[" + ks + "]", X = "\\ud83c[\\udffb-\\udfff]", Hs = "(?:" + q + "|" + X + ")", pe = "[^" + le + "]", de = "(?:\\ud83c[\\udde6-\\uddff]){2}", Ce = "[\\ud800-\\udbff][\\udc00-\\udfff]", Gs = "\\u200d", ue = Hs + "?", ve = "[" + Bs + "]?", Vs = "(?:" + Gs + "(?:" + [pe, de, Ce].join("|") + ")" + ve + ue + ")*", Ns = ve + ue + Vs, Us = "(?:" + [pe + q + "?", q, de, Ce, Is].join("|") + ")", Zs = RegExp(X + "(?=" + X + ")|" + Us + Ns, "g");
function _s(o) {
  return o.match(Zs) || [];
}
function zs(o) {
  return me(o) ? _s(o) : Fs(o);
}
function Ws(o) {
  return function(e) {
    e = Y(e);
    var s = me(e) ? zs(e) : void 0, n = s ? s[0] : e.charAt(0), t = s ? Ts(s, 1).join("") : e.slice(1);
    return n[o]() + t;
  };
}
var js = Ws("toUpperCase");
const $s = js;
function Ks(o) {
  return $s(Y(o).toLowerCase());
}
var Js = He(function(o, e, s) {
  return e = e.toLowerCase(), o + (s ? Ks(e) : e);
});
const qs = Js;
class T {
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  constructor(e, s) {
    this.components = [], this.services = {
      canvasZoom: ms,
      domUtils: ws,
      events: ls,
      files: ps,
      gradientUtils: Es,
      transitions: ds
    }, this.model = new Re(this.services);
  }
  // Contains the code that uses properties that are overridable by the super-class
  init(e, s) {
    this.model.set({ holder: e }, { skipUpdate: !0 }), Object.keys(this.services).forEach((n) => {
      const t = this.services[n];
      this.services[n] = new t(this.model, this.services);
    }), this.services.events.addEventListener(j.Model.UPDATE, (n) => {
      const t = !!l(n, "detail", "animate");
      this.update(t);
    }), this.model.setData(s.data), this.services.events.addEventListener(j.Chart.RESIZE, () => {
      this.update(!1);
    }), this.components = this.getComponents(), this.update();
  }
  getComponents() {
    return console.error("getComponents() method is not implemented"), [];
  }
  update(e = !0) {
    if (!this.components)
      return;
    Object.keys(this.services).forEach((t) => {
      this.services[t].update();
    }), this.components.forEach((t) => t.render(e));
    const s = this.services.transitions.getPendingTransitions(), n = Object.keys(s).map((t) => s[t].end().catch((m) => m));
    Promise.all(n).then(
      () => this.services.events.dispatchEvent(j.Chart.RENDER_FINISHED)
    );
  }
  destroy() {
    this.components.forEach((e) => e.destroy()), this.services.domUtils.getHolder().remove(), this.model.set({ destroyed: !0 }, { skipUpdate: !0 });
  }
  getChartComponents(e, s) {
    const n = this.model.getOptions(), t = l(n, "toolbar", "enabled"), h = {
      id: "legend",
      components: [new ee(this.model, this.services)],
      growth: i.PREFERRED
    }, m = l(n, "canvasZoom", "enabled");
    m && m === !0 && e.push(new Ge(this.model, this.services));
    const b = !!this.model.getOptions().title, O = {
      id: "title",
      components: [new _(this.model, this.services)],
      growth: i.STRETCH
    }, x = {
      id: "toolbar",
      components: [new z(this.model, this.services)],
      growth: i.PREFERRED
    }, L = {
      id: "header",
      components: [
        new g(
          this.model,
          this.services,
          [
            // always add title to keep layout correct
            O,
            ...t ? [x] : []
          ],
          {
            direction: c.ROW,
            alignItems: Z.CENTER
          }
        )
      ],
      growth: i.PREFERRED
    }, y = {
      id: "graph-frame",
      components: e,
      growth: i.STRETCH,
      renderType: l(s, "graphFrameRenderType") || A.SVG
    }, D = l(s, "excludeLegend") !== !0 && n.legend.enabled !== !1;
    let f = c.COLUMN;
    if (D) {
      const S = l(n, "legend", "position");
      S === "left" ? (f = c.ROW, n.legend.orientation || (n.legend.orientation = N.VERTICAL)) : S === "right" ? (f = c.ROW_REVERSE, n.legend.orientation || (n.legend.orientation = N.VERTICAL)) : S === "bottom" && (f = c.COLUMN_REVERSE);
    }
    const P = {
      id: "spacer",
      components: [new F(this.model, this.services)],
      growth: i.PREFERRED
    }, v = {
      id: "full-frame",
      components: [
        new g(
          this.model,
          this.services,
          [
            ...D ? [h] : [],
            ...D ? [P] : [],
            y
          ],
          {
            direction: f
          }
        )
      ],
      growth: i.STRETCH
    }, E = [];
    if (b || t) {
      E.push(L);
      const S = {
        id: "spacer",
        components: [
          new F(this.model, this.services, t ? { size: 15 } : void 0)
        ],
        growth: i.PREFERRED
      };
      E.push(S);
    }
    return E.push(v), [
      new se(this.model, this.services),
      new W(this.model, this.services),
      new g(this.model, this.services, E, {
        direction: c.COLUMN
      })
    ];
  }
}
class u extends T {
  constructor(e, s) {
    super(e, s), this.services = Object.assign(this.services, {
      cartesianScales: Cs,
      curves: us,
      zoom: vs
    }), this.model = new Te(this.services);
  }
  getAxisChartComponents(e, s) {
    const n = this.model.getOptions(), t = l(n, "zoomBar", $.TOP, "enabled"), h = l(n, "toolbar", "enabled");
    this.services.cartesianScales.determineAxisDuality(), this.services.cartesianScales.findDomainAndRangeAxes(), this.services.cartesianScales.determineOrientation();
    const m = this.services.cartesianScales.getMainXAxisPosition(), b = l(n, "axes", m, "scaleType"), O = t && m === $.BOTTOM && b === Ie.TIME, x = this.services.zoom.isZoomBarLocked($.TOP), L = !!this.model.getOptions().title, y = {
      id: "title",
      components: [new _(this.model, this.services)],
      growth: i.STRETCH
    }, D = {
      id: "toolbar",
      components: [new z(this.model, this.services)],
      growth: i.PREFERRED
    }, f = {
      id: "header",
      components: [
        new g(
          this.model,
          this.services,
          [
            // always add title to keep layout correct
            y,
            ...h ? [D] : []
          ],
          {
            direction: c.ROW,
            alignItems: Z.CENTER
          }
        )
      ],
      growth: i.PREFERRED
    }, P = {
      id: "legend",
      components: [new ee(this.model, this.services)],
      growth: i.PREFERRED
    };
    O && !x && e.push(
      new Ve(this.model, this.services),
      new Ne(this.model, this.services)
    ), e.push(new Ue(this.model, this.services)), e.push(new Ze(this.model, this.services));
    const v = {
      id: "graph-frame",
      components: e,
      growth: i.STRETCH,
      renderType: A.SVG
    }, E = l(s, "legend", "enabled") !== !1 && this.model.getOptions().legend.enabled !== !1;
    let S = c.COLUMN;
    if (E) {
      const G = l(this.model.getOptions(), "legend", "position");
      G === K.LEFT ? (S = c.ROW, this.model.getOptions().legend.orientation || (this.model.getOptions().legend.orientation = N.VERTICAL)) : G === K.RIGHT ? (S = c.ROW_REVERSE, this.model.getOptions().legend.orientation || (this.model.getOptions().legend.orientation = N.VERTICAL)) : G === K.BOTTOM && (S = c.COLUMN_REVERSE);
    }
    const ge = {
      id: "spacer",
      components: [new F(this.model, this.services)],
      growth: i.PREFERRED
    }, we = {
      id: "full-frame",
      components: [
        new g(
          this.model,
          this.services,
          [
            ...E ? [P] : [],
            ...E ? [ge] : [],
            v
          ],
          {
            direction: S
          }
        )
      ],
      growth: i.STRETCH
    }, Ee = {
      id: "zoom-bar",
      components: [new _e(this.model, this.services)],
      growth: i.PREFERRED,
      renderType: A.SVG
    }, H = [];
    if (L || h) {
      H.push(f);
      const G = {
        id: "spacer",
        components: [
          new F(this.model, this.services, h ? { size: 15 } : void 0)
        ],
        growth: i.PREFERRED
      };
      H.push(G);
    }
    return O && H.push(Ee), H.push(we), [
      new te(this.model, this.services),
      new W(this.model, this.services),
      new g(this.model, this.services, H, {
        direction: c.COLUMN
      })
    ];
  }
}
class ct extends T {
  constructor(e, s) {
    super(e, s), this.model = new be(this.services), this.model.setOptions(a(r.alluvialChart, s.options)), this.init(e, s);
  }
  getComponents() {
    const e = [new ze(this.model, this.services)];
    return this.getChartComponents(e, {
      excludeLegend: !0
    });
  }
}
class mt extends u {
  constructor(e, s) {
    super(e, s), this.model.setOptions(a(J(r.areaChart), s.options)), this.init(e, s);
  }
  getComponents() {
    const e = [
      new d(this.model, this.services),
      new w(this.model, this.services),
      new B(this.model, this.services),
      new k(this.model, this.services),
      new oe(this.model, this.services),
      new M(this.model, this.services, {
        fadeInOnChartHolderMouseover: !0,
        handleThresholds: !0
      }),
      new C(this.model, this.services, {
        skeleton: p.GRID
      })
    ];
    return this.getAxisChartComponents(e);
  }
}
class lt extends u {
  constructor(e, s) {
    super(e, s), this.model = new Oe(this.services), this.model.setOptions(a(r.boxplotChart, s.options)), this.init(e, s);
  }
  getComponents() {
    const e = [
      new d(this.model, this.services),
      new w(this.model, this.services),
      new We(this.model, this.services),
      new I(this.model, this.services),
      new C(this.model, this.services, {
        skeleton: p.VERT_OR_HORIZ
      })
    ];
    return this.getAxisChartComponents(e, {
      legend: {
        enabled: !1
      }
    });
  }
}
class pt extends u {
  constructor(e, s) {
    super(e, s), this.model.setOptions(a(r.bubbleChart, s.options)), this.init(e, s);
  }
  getComponents() {
    const e = [
      new d(this.model, this.services),
      new w(this.model, this.services),
      new B(this.model, this.services),
      new je(this.model, this.services),
      new C(this.model, this.services, {
        skeleton: p.GRID
      })
    ];
    return this.getAxisChartComponents(e);
  }
}
class dt extends u {
  constructor(e, s) {
    super(e, s), this.model = new fe(this.services), this.model.setOptions(a(r.bulletChart, s.options)), this.init(e, s);
  }
  getComponents() {
    const e = [
      new d(this.model, this.services),
      new w(this.model, this.services),
      new $e(this.model, this.services),
      new C(this.model, this.services, {
        skeleton: p.GRID
      })
    ];
    return this.getAxisChartComponents(e);
  }
}
class Ct extends T {
  constructor(e, s) {
    super(e, s), this.model = new Se(this.services), this.model.setOptions(
      a(r.choroplethChart, s.options)
    ), this.init(e, s);
  }
  // Custom getChartComponents - Implements getChartComponents
  // Removes zoombar support and additional `features` that are not supported in heatmap
  getChartComponents(e, s) {
    const n = this.model.getOptions(), t = l(n, "toolbar", "enabled"), h = !!this.model.getOptions().title, m = {
      id: "title",
      components: [new _(this.model, this.services)],
      growth: i.STRETCH
    }, b = {
      id: "toolbar",
      components: [new z(this.model, this.services)],
      growth: i.PREFERRED
    }, O = {
      id: "header",
      components: [
        new g(
          this.model,
          this.services,
          [
            // always add title to keep layout correct
            m,
            ...t ? [b] : []
          ],
          {
            direction: c.ROW,
            alignItems: Z.CENTER
          }
        )
      ],
      growth: i.PREFERRED
    }, x = {
      id: "legend",
      components: [
        new ne(this.model, this.services, {
          chartType: "choropleth"
        })
      ],
      growth: i.PREFERRED,
      renderType: A.SVG
    }, L = {
      id: "graph-frame",
      components: e,
      growth: i.STRETCH,
      renderType: A.SVG
    }, y = l(s, "legend", "enabled") !== !1 && this.model.getOptions().legend.enabled !== !1, D = c.COLUMN_REVERSE, f = {
      id: "spacer",
      components: [new F(this.model, this.services, { size: 15 })],
      growth: i.PREFERRED
    }, P = {
      id: "full-frame",
      components: [
        new g(
          this.model,
          this.services,
          [
            ...y ? [x] : [],
            ...y ? [f] : [],
            L
          ],
          {
            direction: D
          }
        )
      ],
      growth: i.STRETCH
    }, v = [];
    if (h || t) {
      v.push(O);
      const E = {
        id: "spacer",
        components: [
          new F(this.model, this.services, t ? { size: 15 } : void 0)
        ],
        growth: i.PREFERRED
      };
      v.push(E);
    }
    return v.push(P), [
      new se(this.model, this.services),
      new W(this.model, this.services),
      new g(this.model, this.services, v, {
        direction: c.COLUMN
      })
    ];
  }
  getComponents() {
    const e = [new Ke(this.model, this.services)];
    return this.getChartComponents(e);
  }
}
class ut extends T {
  constructor(e, s) {
    super(e, s), this.model = new Ae(this.services), this.model.setOptions(a(r.circlePackChart, s.options)), this.init(e, s);
  }
  getComponents() {
    const e = [new Je(this.model, this.services)];
    return this.getChartComponents(e);
  }
}
const Q = {
  [R.LINE]: [k, M],
  [R.SCATTER]: [M],
  [R.AREA]: [oe, k, M],
  [R.STACKED_AREA]: [ie, k, re, U],
  [R.SIMPLE_BAR]: [ae],
  [R.GROUPED_BAR]: [he, I],
  [R.STACKED_BAR]: [ce, U]
};
class vt extends u {
  constructor(e, s) {
    super(e, s);
    const n = a(r.comboChart, s.options);
    s.options.comboChartTypes || (console.error("No comboChartTypes defined for the Combo Chart!"), n.comboChartTypes = [{ type: R.LINE, correspondingDatasets: [] }]), this.model.setOptions(n), this.init(e, s);
  }
  getGraphComponents() {
    const { comboChartTypes: e } = this.model.getOptions();
    let s = 0;
    const n = e.map((t) => {
      const h = t.type;
      let m;
      if (typeof t.type == "string") {
        if (!Object.keys(Q).includes(t.type))
          return console.error(
            `Invalid chart type "${t.type}" specified for combo chart. Please refer to the ComboChart tutorial for more guidance.`
          ), null;
        let b = !1;
        const O = `${qs(t.type)}Chart`;
        return m = V(
          {},
          r[O],
          this.model.getOptions(),
          t.options
        ), t.type === R.STACKED_AREA && (b = !0), Q[t.type].map(
          (x) => new x(this.model, this.services, {
            groups: t.correspondingDatasets,
            id: s++,
            options: m,
            stacked: b
          })
        );
      } else
        return m = V({}, this.model.getOptions(), t.options), new h(this.model, this.services, {
          groups: t.correspondingDatasets,
          id: s++,
          options: m
        });
    }).filter((t) => t !== null);
    return gs(n);
  }
  getComponents() {
    const { comboChartTypes: e } = this.model.getOptions(), s = e.some(
      (h) => h.type === R.STACKED_BAR || h.type === R.STACKED_AREA
    ), n = [
      new d(this.model, this.services),
      new w(this.model, this.services),
      new C(this.model, this.services, {
        skeleton: p.GRID
      }),
      ...s ? [] : [new B(this.model, this.services)],
      ...this.getGraphComponents()
    ];
    return this.getAxisChartComponents(n);
  }
}
class Xs extends T {
  // TODO - Optimize the use of "extending"
  constructor(e, s, n = !1) {
    super(e, s), this.model = new xe(this.services), !n && (this.model.setOptions(a(r.pieChart, s.options)), this.init(e, s));
  }
  getComponents() {
    const e = [
      new qe(this.model, this.services),
      new C(this.model, this.services, {
        skeleton: p.PIE
      })
    ];
    return this.getChartComponents(e);
  }
}
class gt extends Xs {
  constructor(e, s) {
    super(e, s, !0), this.model.setOptions(a(r.donutChart, s.options)), this.init(e, s);
  }
  getComponents() {
    const e = [
      new Xe(this.model, this.services),
      new C(this.model, this.services, {
        skeleton: p.DONUT
      })
    ];
    return this.getChartComponents(e);
  }
}
class wt extends T {
  constructor(e, s) {
    super(e, s), this.model = new ye(this.services), this.model.setOptions(a(r.gaugeChart, s.options)), this.init(e, s);
  }
  getComponents() {
    const e = [new Qe(this.model, this.services)];
    return this.getChartComponents(e);
  }
}
class Et extends u {
  constructor(e, s) {
    super(e, s), this.model.setOptions(a(r.groupedBarChart, s.options)), this.init(e, s);
  }
  getComponents() {
    const e = [
      new d(this.model, this.services),
      new w(this.model, this.services),
      new he(this.model, this.services),
      new I(this.model, this.services),
      new C(this.model, this.services, {
        skeleton: p.VERT_OR_HORIZ
      })
    ];
    return this.getAxisChartComponents(e);
  }
}
class Rt extends u {
  constructor(e, s) {
    super(e, s), this.model = new De(this.services), this.model.setOptions(a(r.heatmapChart, s.options)), this.init(e, s);
  }
  // Custom getChartComponents - Implements getChartComponents
  // Removes zoombar support and additional `features` that are not supported in heatmap
  getAxisChartComponents(e, s) {
    const n = this.model.getOptions(), t = l(n, "toolbar", "enabled");
    this.services.cartesianScales.determineAxisDuality(), this.services.cartesianScales.findDomainAndRangeAxes(), this.services.cartesianScales.determineOrientation();
    const h = !!this.model.getOptions().title, m = {
      id: "title",
      components: [new _(this.model, this.services)],
      growth: i.STRETCH
    }, b = {
      id: "toolbar",
      components: [new z(this.model, this.services)],
      growth: i.PREFERRED
    }, O = {
      id: "header",
      components: [
        new g(
          this.model,
          this.services,
          [
            // always add title to keep layout correct
            m,
            ...t ? [b] : []
          ],
          {
            direction: c.ROW,
            alignItems: Z.CENTER
          }
        )
      ],
      growth: i.PREFERRED
    }, x = {
      id: "legend",
      components: [
        new ne(this.model, this.services, {
          chartType: "heatmap"
        })
      ],
      growth: i.PREFERRED,
      renderType: A.SVG
    }, L = {
      id: "graph-frame",
      components: e,
      growth: i.STRETCH,
      renderType: A.SVG
    }, y = l(s, "legend", "enabled") !== !1 && this.model.getOptions().legend.enabled !== !1, D = c.COLUMN_REVERSE, f = {
      id: "spacer",
      components: [new F(this.model, this.services, { size: 15 })],
      growth: i.PREFERRED
    }, P = {
      id: "full-frame",
      components: [
        new g(
          this.model,
          this.services,
          [
            ...y ? [x] : [],
            ...y ? [f] : [],
            L
          ],
          {
            direction: D
          }
        )
      ],
      growth: i.STRETCH
    }, v = [];
    if (h || t) {
      v.push(O);
      const E = {
        id: "spacer",
        components: [
          new F(this.model, this.services, t ? { size: 15 } : void 0)
        ],
        growth: i.PREFERRED
      };
      v.push(E);
    }
    return v.push(P), [
      new te(this.model, this.services),
      new W(this.model, this.services),
      new g(this.model, this.services, v, {
        direction: c.COLUMN
      })
    ];
  }
  getComponents() {
    const e = [
      new d(this.model, this.services),
      new Ye(this.model, this.services)
    ];
    return this.getAxisChartComponents(e);
  }
}
class Tt extends u {
  constructor(e, s) {
    super(e, s), this.model = new Fe(this.services), this.model.setOptions(a(r.histogramChart, s.options)), this.init(e, s), this.update();
  }
  getComponents() {
    const e = [
      new d(this.model, this.services),
      new w(this.model, this.services),
      new es(this.model, this.services),
      new ss(this.model, this.services)
    ];
    return this.getAxisChartComponents(e);
  }
}
class bt extends u {
  constructor(e, s) {
    super(e, s), this.model.setOptions(a(r.lineChart, s.options)), this.init(e, s);
  }
  getComponents() {
    const e = [
      new d(this.model, this.services),
      new w(this.model, this.services),
      new B(this.model, this.services),
      new k(this.model, this.services),
      new M(this.model, this.services, { handleThresholds: !0 }),
      new ts(this.model, this.services),
      new I(this.model, this.services)
    ];
    return this.getAxisChartComponents(e);
  }
}
class Ot extends u {
  constructor(e, s) {
    super(e, s), this.model.setOptions(a(r.lollipopChart, s.options)), this.init(e, s);
  }
  getComponents() {
    const e = [
      new d(this.model, this.services),
      new w(this.model, this.services),
      new B(this.model, this.services),
      new os(this.model, this.services),
      new M(this.model, this.services),
      new C(this.model, this.services, {
        skeleton: p.GRID
      })
    ];
    return this.getAxisChartComponents(e);
  }
}
class ft extends T {
  constructor(e, s) {
    var t;
    super(e, s), this.model = new Le(this.services);
    const n = (t = s.options.meter) != null && t.proportional ? V(J(r.proportionalMeterChart), s.options) : V(J(r.meterChart), s.options);
    this.model.setOptions(n), this.init(e, s);
  }
  getComponents() {
    const s = [
      ...l(this.model.getOptions(), "meter", "showLabels") ? [
        // Meter has a unique dataset title within the graph
        {
          id: "meter-title",
          components: [new ns(this.model, this.services)],
          growth: i.STRETCH,
          renderType: A.SVG
        },
        // Create the title spacer
        {
          id: "spacer",
          components: [
            new F(this.model, this.services, {
              size: 8
            })
          ],
          growth: i.STRETCH
        }
      ] : [],
      // Specify what to render inside the graph only
      {
        id: "meter-graph",
        components: [new is(this.model, this.services)],
        growth: i.STRETCH,
        renderType: A.SVG
      }
    ], n = [
      new g(this.model, this.services, s, {
        direction: c.COLUMN
      })
    ];
    return this.getChartComponents(n, {
      graphFrameRenderType: A.HTML
    });
  }
}
class St extends T {
  constructor(e, s) {
    super(e, s), this.model = new Pe(this.services), this.model.setOptions(a(r.radarChart, s.options)), this.init(e, s);
  }
  getComponents() {
    const e = [new rs(this.model, this.services)];
    return this.getChartComponents(e);
  }
}
class At extends u {
  constructor(e, s) {
    super(e, s), this.model.setOptions(a(r.scatterChart, s.options)), this.init(e, s);
  }
  getComponents() {
    const e = [
      new d(this.model, this.services),
      new w(this.model, this.services),
      new B(this.model, this.services),
      new M(this.model, this.services),
      new C(this.model, this.services, {
        skeleton: p.GRID
      })
    ];
    return this.getAxisChartComponents(e);
  }
}
class xt extends T {
  constructor(e, s) {
    super(e, s), this.model = new Me(this.services), this.model.setOptions(a(r.treeChart, s.options)), this.init(e, s);
  }
  getComponents() {
    const e = [new as(this.model, this.services)];
    return this.getChartComponents(e, {
      excludeLegend: !0
    });
  }
}
class yt extends T {
  constructor(e, s) {
    super(e, s), this.model = new ke(this.services), this.model.setOptions(a(r.treemapChart, s.options)), this.init(e, s);
  }
  getComponents() {
    const e = [new hs(this.model, this.services)];
    return this.getChartComponents(e);
  }
}
class Dt extends u {
  constructor(e, s) {
    super(e, s), this.model.setOptions(a(r.simpleBarChart, s.options)), this.init(e, s);
  }
  getComponents() {
    const e = [
      new d(this.model, this.services),
      new w(this.model, this.services),
      new ae(this.model, this.services),
      new I(this.model, this.services),
      new C(this.model, this.services, {
        skeleton: p.VERT_OR_HORIZ
      })
    ];
    return this.getAxisChartComponents(e);
  }
}
class Ft extends u {
  constructor(e, s) {
    super(e, s), this.model.setOptions(a(r.stackedAreaChart, s.options)), this.init(e, s);
  }
  getComponents() {
    const e = [
      new d(this.model, this.services),
      new w(this.model, this.services),
      new U(this.model, this.services),
      new ie(this.model, this.services),
      new k(this.model, this.services, { stacked: !0 }),
      new re(this.model, this.services, {
        fadeInOnChartHolderMouseover: !0,
        handleThresholds: !0,
        stacked: !0
      }),
      new C(this.model, this.services, {
        skeleton: p.GRID
      })
    ];
    return this.getAxisChartComponents(e);
  }
}
class Lt extends u {
  constructor(e, s) {
    super(e, s), this.model.setOptions(a(r.stackedBarChart, s.options)), this.init(e, s);
  }
  getComponents() {
    const e = [
      new d(this.model, this.services),
      new w(this.model, this.services),
      new U(this.model, this.services),
      new ce(this.model, this.services),
      new C(this.model, this.services, {
        skeleton: p.VERT_OR_HORIZ
      }),
      new I(this.model, this.services)
    ];
    return this.getAxisChartComponents(e);
  }
}
class Pt extends T {
  constructor(e, s) {
    super(e, s), this.model = new Be(this.services), this.model.setOptions(a(r.wordCloudChart, s.options)), this.init(e, s);
  }
  getComponents() {
    const e = [
      new cs(this.model, this.services),
      new C(this.model, this.services, {
        skeleton: p.PIE
      })
    ];
    return this.getChartComponents(e);
  }
}
export {
  wo as Alignments,
  ze as Alluvial,
  ct as AlluvialChart,
  be as AlluvialChartModel,
  oe as Area,
  mt as AreaChart,
  Eo as AreaEvent,
  Ro as ArrowDirections,
  an as Axis,
  u as AxisChart,
  te as AxisChartsTooltip,
  To as AxisEvent,
  bo as AxisFlavor,
  $ as AxisPositions,
  Oo as AxisTitleOrientations,
  hn as Bar,
  fo as BarEvent,
  es as BinnedRuler,
  We as Boxplot,
  lt as BoxplotChart,
  Oe as BoxplotChartModel,
  So as BoxplotEvent,
  je as Bubble,
  pt as BubbleChart,
  $e as Bullet,
  dt as BulletChart,
  fe as BulletChartModel,
  Ao as CalloutDirections,
  Ge as CanvasChartClip,
  ms as CanvasZoom,
  xo as CanvasZoomEvent,
  yo as CartesianOrientations,
  Cs as CartesianScales,
  T as Chart,
  Ne as ChartBrush,
  Ve as ChartClip,
  Do as ChartEvent,
  Re as ChartModel,
  Fe as ChartModelBinned,
  Te as ChartModelCartesian,
  Fo as ChartTheme,
  R as ChartTypes,
  Ke as Choropleth,
  Se as ChoroplethModel,
  Je as CirclePack,
  ut as CirclePackChart,
  Ae as CirclePackChartModel,
  Lo as ColorClassNameTypes,
  Po as ColorLegendType,
  ne as ColorScaleLegend,
  vt as ComboChart,
  cn as Component,
  us as Curves,
  ws as DOMUtils,
  Mo as DividerStatus,
  ko as DominantBaseline,
  Xe as Donut,
  gt as DonutChart,
  ls as Events,
  Ct as ExperimentalChoroplethChart,
  ps as Files,
  Qe as Gauge,
  wt as GaugeChart,
  ye as GaugeChartModel,
  Bo as GaugeEvent,
  Io as GaugeTypes,
  mn as GeoProjection,
  Es as GradientUtils,
  w as Grid,
  he as GroupedBar,
  Et as GroupedBarChart,
  Ye as Heatmap,
  Rt as HeatmapChart,
  De as HeatmapModel,
  Ze as Highlight,
  ss as Histogram,
  Tt as HistogramChart,
  ln as HoverAxis,
  Z as LayoutAlignItems,
  g as LayoutComponent,
  c as LayoutDirection,
  i as LayoutGrowth,
  ee as Legend,
  Ho as LegendItemType,
  N as LegendOrientations,
  K as LegendPositions,
  k as Line,
  bt as LineChart,
  Go as LineEvent,
  os as Lollipop,
  Ot as LollipopChart,
  is as Meter,
  ft as MeterChart,
  Le as MeterChartModel,
  ns as MeterTitle,
  W as Modal,
  Vo as ModalEvent,
  No as ModelEvent,
  qe as Pie,
  Xs as PieChart,
  xe as PieChartModel,
  Uo as PieEvent,
  Zo as Projection,
  rs as Radar,
  St as RadarChart,
  Pe as RadarChartModel,
  _o as RadarEvent,
  A as RenderTypes,
  B as Ruler,
  Ie as ScaleTypes,
  M as Scatter,
  At as ScatterChart,
  zo as ScatterEvent,
  bn as Service,
  ae as SimpleBar,
  Dt as SimpleBarChart,
  C as Skeleton,
  ts as SkeletonLines,
  p as Skeletons,
  F as Spacer,
  ie as StackedArea,
  Ft as StackedAreaChart,
  ce as StackedBar,
  Lt as StackedBarChart,
  U as StackedRuler,
  re as StackedScatter,
  Wo as Statuses,
  Bt as TIME_INTERVALS,
  jo as TextAnchor,
  Ue as Threshold,
  $o as ThresholdEvent,
  Ko as TickRotations,
  _ as Title,
  z as Toolbar,
  Jo as ToolbarControlTypes,
  se as Tooltip,
  qo as TooltipEvent,
  ds as Transitions,
  as as Tree,
  xt as TreeChart,
  Me as TreeChartModel,
  Xo as TreeEvent,
  Qo as TreeTypes,
  hs as Treemap,
  yt as TreemapChart,
  ke as TreemapChartModel,
  Yo as TreemapEvent,
  en as TruncationTypes,
  d as TwoDimensionalAxes,
  cs as WordCloud,
  Pt as WordCloudChart,
  sn as WordCloudEvent,
  Be as WordCloudModel,
  I as ZeroLine,
  vs as Zoom,
  _e as ZoomBar,
  tn as ZoomBarTypes,
  on as ZoomDomainEvent,
  nn as ZoombarEvent,
  It as alluvial,
  Ht as area,
  pn as arrowLeft,
  dn as arrowRight,
  Gt as axis,
  Vt as baseTooltip,
  Nt as boxplot,
  Cn as buildBezierPathString,
  un as buildElbowPathString,
  vn as buildStraightPathString,
  Ut as canvasZoomSettings,
  Zt as carbonPrefix,
  gn as circle,
  _t as circlePack,
  zt as color,
  Wt as computeTimeIntervalName,
  jt as configurations,
  $t as defaultLegendAdditionalItems,
  On as degToRad,
  wn as diamond,
  fn as distanceBetweenPointOnCircAndVerticalDiameter,
  Kt as formatDateTillMilliSeconds,
  Jt as formatTick,
  qt as getColorScale,
  Xt as getDomain,
  Qt as getTimeformats,
  Yt as grid,
  eo as histogram,
  vo as interfaces,
  so as isTickPrimary,
  to as legend,
  oo as lines,
  no as meter,
  r as options,
  io as pie,
  Sn as polarToCartesianCoords,
  An as radToDeg,
  ro as radar,
  xn as radialLabelPlacement,
  ao as ruler,
  ho as spacers,
  En as square,
  Rn as tee,
  co as timeScale,
  mo as toolbar,
  lo as tooltips,
  po as transitions,
  Co as zoomBar
};
//# sourceMappingURL=index.mjs.map
