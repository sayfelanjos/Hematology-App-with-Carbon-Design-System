{"ast":null,"code":"/**\n * Copyright IBM Corp. 2016, 2023\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport { sortStates } from './sortStates.js';\nexport { sortStates } from './sortStates.js';\nimport { sortRows } from '../tools/sorting.js';\n\n// Our initialSortState should be `NONE`, unless a consumer has specified a\n// different initialSortState\nconst initialSortState = sortStates.NONE;\n\n/**\n * Utility used to get the next sort state given the following pieces of\n * information:\n *\n * @param {string} prevHeader the value of the previous header\n * @param {string} header the value of the currently selected header\n * @param {string} prevState the previous sort state of the table\n * @returns {string}\n */\nconst getNextSortDirection = (prevHeader, header, prevState) => {\n  // If the previous header is equivalent to the current header, we know that we\n  // have to derive the next sort state from the previous sort state\n  if (prevHeader === header) {\n    // When transitioning, we know that the sequence of states is as follows:\n    // NONE -> ASC -> DESC -> NONE\n    if (prevState === 'NONE') {\n      return sortStates.ASC;\n    }\n    if (prevState === 'ASC') {\n      return sortStates.DESC;\n    }\n    return sortStates.NONE;\n  }\n  // Otherwise, we have selected a new header and need to start off by sorting\n  // in descending order by default\n  return sortStates.ASC;\n};\nconst getNextSortState = (props, state, _ref) => {\n  let {\n    key\n  } = _ref;\n  const {\n    sortDirection,\n    sortHeaderKey\n  } = state;\n  const nextSortDirection = getNextSortDirection(key, sortHeaderKey, sortDirection);\n  return getSortedState(props, state, key, nextSortDirection);\n};\n\n/**\n * Derive the set of sorted state fields from props and state for the given\n * header key and sortDirection\n *\n * @param {object} props\n * @param {string} props.locale The current locale\n * @param {Function} props.sortRows Method to handle sorting a collection of\n * rows\n * @param {object} state\n * @param {Array<string>} state.rowIds Array of row ids\n * @param {object} state.cellsById Lookup object for cells by id\n * @param {Array<string>} state.initialRowOrder Initial row order for the\n * current set of rows\n * @param {string} key The key for the given header we are serving the\n * sorted state for\n * @param {string} sortDirection The sortState that we want to order by\n * @returns {object}\n */\nconst getSortedState = (props, state, key, sortDirection) => {\n  const {\n    rowIds,\n    cellsById,\n    initialRowOrder\n  } = state;\n  const {\n    locale,\n    sortRow\n  } = props;\n  const nextRowIds = sortDirection !== sortStates.NONE ? sortRows({\n    rowIds,\n    cellsById,\n    sortDirection,\n    key,\n    locale,\n    sortRow\n  }) : initialRowOrder;\n  return {\n    sortHeaderKey: key,\n    sortDirection: sortDirection,\n    rowIds: nextRowIds\n  };\n};\nexport { getNextSortDirection, getNextSortState, getSortedState, initialSortState };","map":{"version":3,"names":["sortStates","sortRows","initialSortState","NONE","getNextSortDirection","prevHeader","header","prevState","ASC","DESC","getNextSortState","props","state","_ref","key","sortDirection","sortHeaderKey","nextSortDirection","getSortedState","rowIds","cellsById","initialRowOrder","locale","sortRow","nextRowIds"],"sources":["/home/saymon/Backup/Portifolio/Hematology-App-with-Carbon-Design-System/frontend/node_modules/@carbon/react/es/components/DataTable/state/sorting.js"],"sourcesContent":["/**\n * Copyright IBM Corp. 2016, 2023\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport { sortStates } from './sortStates.js';\nexport { sortStates } from './sortStates.js';\nimport { sortRows } from '../tools/sorting.js';\n\n// Our initialSortState should be `NONE`, unless a consumer has specified a\n// different initialSortState\nconst initialSortState = sortStates.NONE;\n\n/**\n * Utility used to get the next sort state given the following pieces of\n * information:\n *\n * @param {string} prevHeader the value of the previous header\n * @param {string} header the value of the currently selected header\n * @param {string} prevState the previous sort state of the table\n * @returns {string}\n */\nconst getNextSortDirection = (prevHeader, header, prevState) => {\n  // If the previous header is equivalent to the current header, we know that we\n  // have to derive the next sort state from the previous sort state\n  if (prevHeader === header) {\n    // When transitioning, we know that the sequence of states is as follows:\n    // NONE -> ASC -> DESC -> NONE\n    if (prevState === 'NONE') {\n      return sortStates.ASC;\n    }\n    if (prevState === 'ASC') {\n      return sortStates.DESC;\n    }\n    return sortStates.NONE;\n  }\n  // Otherwise, we have selected a new header and need to start off by sorting\n  // in descending order by default\n  return sortStates.ASC;\n};\nconst getNextSortState = (props, state, _ref) => {\n  let {\n    key\n  } = _ref;\n  const {\n    sortDirection,\n    sortHeaderKey\n  } = state;\n  const nextSortDirection = getNextSortDirection(key, sortHeaderKey, sortDirection);\n  return getSortedState(props, state, key, nextSortDirection);\n};\n\n/**\n * Derive the set of sorted state fields from props and state for the given\n * header key and sortDirection\n *\n * @param {object} props\n * @param {string} props.locale The current locale\n * @param {Function} props.sortRows Method to handle sorting a collection of\n * rows\n * @param {object} state\n * @param {Array<string>} state.rowIds Array of row ids\n * @param {object} state.cellsById Lookup object for cells by id\n * @param {Array<string>} state.initialRowOrder Initial row order for the\n * current set of rows\n * @param {string} key The key for the given header we are serving the\n * sorted state for\n * @param {string} sortDirection The sortState that we want to order by\n * @returns {object}\n */\nconst getSortedState = (props, state, key, sortDirection) => {\n  const {\n    rowIds,\n    cellsById,\n    initialRowOrder\n  } = state;\n  const {\n    locale,\n    sortRow\n  } = props;\n  const nextRowIds = sortDirection !== sortStates.NONE ? sortRows({\n    rowIds,\n    cellsById,\n    sortDirection,\n    key,\n    locale,\n    sortRow\n  }) : initialRowOrder;\n  return {\n    sortHeaderKey: key,\n    sortDirection: sortDirection,\n    rowIds: nextRowIds\n  };\n};\n\nexport { getNextSortDirection, getNextSortState, getSortedState, initialSortState };\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASA,UAAU,QAAQ,iBAAiB;AAC5C,SAASA,UAAU,QAAQ,iBAAiB;AAC5C,SAASC,QAAQ,QAAQ,qBAAqB;;AAE9C;AACA;AACA,MAAMC,gBAAgB,GAAGF,UAAU,CAACG,IAAI;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,oBAAoB,GAAGA,CAACC,UAAU,EAAEC,MAAM,EAAEC,SAAS,KAAK;EAC9D;EACA;EACA,IAAIF,UAAU,KAAKC,MAAM,EAAE;IACzB;IACA;IACA,IAAIC,SAAS,KAAK,MAAM,EAAE;MACxB,OAAOP,UAAU,CAACQ,GAAG;IACvB;IACA,IAAID,SAAS,KAAK,KAAK,EAAE;MACvB,OAAOP,UAAU,CAACS,IAAI;IACxB;IACA,OAAOT,UAAU,CAACG,IAAI;EACxB;EACA;EACA;EACA,OAAOH,UAAU,CAACQ,GAAG;AACvB,CAAC;AACD,MAAME,gBAAgB,GAAGA,CAACC,KAAK,EAAEC,KAAK,EAAEC,IAAI,KAAK;EAC/C,IAAI;IACFC;EACF,CAAC,GAAGD,IAAI;EACR,MAAM;IACJE,aAAa;IACbC;EACF,CAAC,GAAGJ,KAAK;EACT,MAAMK,iBAAiB,GAAGb,oBAAoB,CAACU,GAAG,EAAEE,aAAa,EAAED,aAAa,CAAC;EACjF,OAAOG,cAAc,CAACP,KAAK,EAAEC,KAAK,EAAEE,GAAG,EAAEG,iBAAiB,CAAC;AAC7D,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,cAAc,GAAGA,CAACP,KAAK,EAAEC,KAAK,EAAEE,GAAG,EAAEC,aAAa,KAAK;EAC3D,MAAM;IACJI,MAAM;IACNC,SAAS;IACTC;EACF,CAAC,GAAGT,KAAK;EACT,MAAM;IACJU,MAAM;IACNC;EACF,CAAC,GAAGZ,KAAK;EACT,MAAMa,UAAU,GAAGT,aAAa,KAAKf,UAAU,CAACG,IAAI,GAAGF,QAAQ,CAAC;IAC9DkB,MAAM;IACNC,SAAS;IACTL,aAAa;IACbD,GAAG;IACHQ,MAAM;IACNC;EACF,CAAC,CAAC,GAAGF,eAAe;EACpB,OAAO;IACLL,aAAa,EAAEF,GAAG;IAClBC,aAAa,EAAEA,aAAa;IAC5BI,MAAM,EAAEK;EACV,CAAC;AACH,CAAC;AAED,SAASpB,oBAAoB,EAAEM,gBAAgB,EAAEQ,cAAc,EAAEhB,gBAAgB"},"metadata":{},"sourceType":"module","externalDependencies":[]}