{"ast":null,"code":"/**\n * Copyright IBM Corp. 2016, 2023\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport { createScope, FeatureFlags as FeatureFlags$1 } from '@carbon/feature-flags';\nimport PropTypes from 'prop-types';\nimport React__default, { useContext, useState, useRef, useEffect, createContext } from 'react';\n\n/**\n * Our FeatureFlagContext is used alongside the FeatureFlags component to enable\n * or disable feature flags in a given React tree\n */\nconst FeatureFlagContext = /*#__PURE__*/createContext(FeatureFlags$1);\n\n/**\n * Supports an object of feature flag values with the `flags` prop, merging them\n * along with the current `FeatureFlagContext` to provide consumers to check if\n * a feature flag is enabled or disabled in a given React tree\n */\nfunction FeatureFlags(_ref) {\n  let {\n    children,\n    flags = {}\n  } = _ref;\n  const parentScope = useContext(FeatureFlagContext);\n  const [prevParentScope, setPrevParentScope] = useState(parentScope);\n  const [scope, updateScope] = useState(() => {\n    const scope = createScope(flags);\n    scope.mergeWithScope(parentScope);\n    return scope;\n  });\n  if (parentScope !== prevParentScope) {\n    const scope = createScope(flags);\n    scope.mergeWithScope(parentScope);\n    updateScope(scope);\n    setPrevParentScope(parentScope);\n  }\n\n  // We use a custom hook to detect if any of the keys or their values change\n  // for flags that are passed in. If they have changed, then we re-create the\n  // FeatureFlagScope using the new flags\n  useChangedValue(flags, isEqual, changedFlags => {\n    const scope = createScope(changedFlags);\n    scope.mergeWithScope(parentScope);\n    updateScope(scope);\n  });\n  return /*#__PURE__*/React__default.createElement(FeatureFlagContext.Provider, {\n    value: scope\n  }, children);\n}\nFeatureFlags.propTypes = {\n  children: PropTypes.node,\n  /**\n   * Provide the feature flags to enabled or disabled in the current React tree\n   */\n  flags: PropTypes.objectOf(PropTypes.bool)\n};\n\n/**\n * This hook will store previous versions of the given `value` and compare the\n * current value to the previous one using the `compare` function. If the\n * compare function returns true, then the given `callback` is invoked in an\n * effect.\n *\n * @param {any} value\n * @param {Function} compare\n * @param {Function} callback\n */\nfunction useChangedValue(value, compare, callback) {\n  const initialRender = useRef(false);\n  const savedCallback = useRef(callback);\n  const [prevValue, setPrevValue] = useState(value);\n  if (!compare(prevValue, value)) {\n    setPrevValue(value);\n  }\n  useEffect(() => {\n    savedCallback.current = callback;\n  });\n  useEffect(() => {\n    // We only want the callback triggered after the first render\n    if (initialRender.current) {\n      savedCallback.current(prevValue);\n    }\n  }, [prevValue]);\n  useEffect(() => {\n    initialRender.current = true;\n  }, []);\n}\n\n/**\n * Access whether a given flag is enabled or disabled in a given\n * FeatureFlagContext\n *\n * @returns {boolean}\n */\nfunction useFeatureFlag(flag) {\n  const scope = useContext(FeatureFlagContext);\n  return scope.enabled(flag);\n}\n\n/**\n * Access all feature flag information for the given FeatureFlagContext\n *\n * @returns {FeatureFlagScope}\n */\nfunction useFeatureFlags() {\n  return useContext(FeatureFlagContext);\n}\n\n/**\n * Compare two objects and determine if they are equal. This is a shallow\n * comparison since the objects we are comparing are objects with boolean flags\n * from the flags prop in the `FeatureFlags` component\n *\n * @param {object} a\n * @param {object} b\n * @returns {boolean}\n */\nfunction isEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n  for (const key of Object.keys(a)) {\n    if (a[key] !== b[key]) {\n      return false;\n    }\n  }\n  for (const key of Object.keys(b)) {\n    if (b[key] !== a[key]) {\n      return false;\n    }\n  }\n  return true;\n}\nexport { FeatureFlagContext, FeatureFlags, useFeatureFlag, useFeatureFlags };","map":{"version":3,"names":["createScope","FeatureFlags","FeatureFlags$1","PropTypes","React__default","useContext","useState","useRef","useEffect","createContext","FeatureFlagContext","_ref","children","flags","parentScope","prevParentScope","setPrevParentScope","scope","updateScope","mergeWithScope","useChangedValue","isEqual","changedFlags","createElement","Provider","value","propTypes","node","objectOf","bool","compare","callback","initialRender","savedCallback","prevValue","setPrevValue","current","useFeatureFlag","flag","enabled","useFeatureFlags","a","b","key","Object","keys"],"sources":["/home/saymon/Backup/Portifolio/Hematology-App-with-Carbon-Design-System/frontend/node_modules/@carbon/react/es/components/FeatureFlags/index.js"],"sourcesContent":["/**\n * Copyright IBM Corp. 2016, 2023\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport { createScope, FeatureFlags as FeatureFlags$1 } from '@carbon/feature-flags';\nimport PropTypes from 'prop-types';\nimport React__default, { useContext, useState, useRef, useEffect, createContext } from 'react';\n\n/**\n * Our FeatureFlagContext is used alongside the FeatureFlags component to enable\n * or disable feature flags in a given React tree\n */\nconst FeatureFlagContext = /*#__PURE__*/createContext(FeatureFlags$1);\n\n/**\n * Supports an object of feature flag values with the `flags` prop, merging them\n * along with the current `FeatureFlagContext` to provide consumers to check if\n * a feature flag is enabled or disabled in a given React tree\n */\nfunction FeatureFlags(_ref) {\n  let {\n    children,\n    flags = {}\n  } = _ref;\n  const parentScope = useContext(FeatureFlagContext);\n  const [prevParentScope, setPrevParentScope] = useState(parentScope);\n  const [scope, updateScope] = useState(() => {\n    const scope = createScope(flags);\n    scope.mergeWithScope(parentScope);\n    return scope;\n  });\n  if (parentScope !== prevParentScope) {\n    const scope = createScope(flags);\n    scope.mergeWithScope(parentScope);\n    updateScope(scope);\n    setPrevParentScope(parentScope);\n  }\n\n  // We use a custom hook to detect if any of the keys or their values change\n  // for flags that are passed in. If they have changed, then we re-create the\n  // FeatureFlagScope using the new flags\n  useChangedValue(flags, isEqual, changedFlags => {\n    const scope = createScope(changedFlags);\n    scope.mergeWithScope(parentScope);\n    updateScope(scope);\n  });\n  return /*#__PURE__*/React__default.createElement(FeatureFlagContext.Provider, {\n    value: scope\n  }, children);\n}\nFeatureFlags.propTypes = {\n  children: PropTypes.node,\n  /**\n   * Provide the feature flags to enabled or disabled in the current React tree\n   */\n  flags: PropTypes.objectOf(PropTypes.bool)\n};\n\n/**\n * This hook will store previous versions of the given `value` and compare the\n * current value to the previous one using the `compare` function. If the\n * compare function returns true, then the given `callback` is invoked in an\n * effect.\n *\n * @param {any} value\n * @param {Function} compare\n * @param {Function} callback\n */\nfunction useChangedValue(value, compare, callback) {\n  const initialRender = useRef(false);\n  const savedCallback = useRef(callback);\n  const [prevValue, setPrevValue] = useState(value);\n  if (!compare(prevValue, value)) {\n    setPrevValue(value);\n  }\n  useEffect(() => {\n    savedCallback.current = callback;\n  });\n  useEffect(() => {\n    // We only want the callback triggered after the first render\n    if (initialRender.current) {\n      savedCallback.current(prevValue);\n    }\n  }, [prevValue]);\n  useEffect(() => {\n    initialRender.current = true;\n  }, []);\n}\n\n/**\n * Access whether a given flag is enabled or disabled in a given\n * FeatureFlagContext\n *\n * @returns {boolean}\n */\nfunction useFeatureFlag(flag) {\n  const scope = useContext(FeatureFlagContext);\n  return scope.enabled(flag);\n}\n\n/**\n * Access all feature flag information for the given FeatureFlagContext\n *\n * @returns {FeatureFlagScope}\n */\nfunction useFeatureFlags() {\n  return useContext(FeatureFlagContext);\n}\n\n/**\n * Compare two objects and determine if they are equal. This is a shallow\n * comparison since the objects we are comparing are objects with boolean flags\n * from the flags prop in the `FeatureFlags` component\n *\n * @param {object} a\n * @param {object} b\n * @returns {boolean}\n */\nfunction isEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n  for (const key of Object.keys(a)) {\n    if (a[key] !== b[key]) {\n      return false;\n    }\n  }\n  for (const key of Object.keys(b)) {\n    if (b[key] !== a[key]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport { FeatureFlagContext, FeatureFlags, useFeatureFlag, useFeatureFlags };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}