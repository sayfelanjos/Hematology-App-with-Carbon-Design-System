{"ast":null,"code":"/**\n * Copyright IBM Corp. 2016, 2023\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport { defineProperty as _defineProperty } from '../_virtual/_rollupPluginBabelHelpers.js';\nimport PropTypes from 'prop-types';\nimport React__default from 'react';\nimport ReactDOM from 'react-dom';\nimport window from 'window-or-global';\nimport OptimizedResize from './OptimizedResize.js';\nimport { selectorTabbable, selectorFocusable } from './keyboard/navigation.js';\nimport { warning } from './warning.js';\nimport wrapFocus from './wrapFocus.js';\nimport { PrefixContext } from './usePrefix.js';\n\n/**\n * The structure for the position of floating menu.\n * @typedef {object} FloatingMenu~position\n * @property {number} left The left position.\n * @property {number} top The top position.\n * @property {number} right The right position.\n * @property {number} bottom The bottom position.\n */\n\n/**\n * The structure for the size of floating menu.\n * @typedef {object} FloatingMenu~size\n * @property {number} width The width.\n * @property {number} height The height.\n */\n\n/**\n * The structure for the position offset of floating menu.\n * @typedef {object} FloatingMenu~offset\n * @property {number} top The top position.\n * @property {number} left The left position.\n */\n\n/**\n * The structure for the target container.\n * @typedef {object} FloatingMenu~container\n * @property {DOMRect} rect Return of element.getBoundingClientRect()\n * @property {string} position Position style (static, absolute, relative...)\n */\n\nconst DIRECTION_LEFT = 'left';\nconst DIRECTION_TOP = 'top';\nconst DIRECTION_RIGHT = 'right';\nconst DIRECTION_BOTTOM = 'bottom';\n\n/**\n * @param {FloatingMenu~offset} [oldMenuOffset={}] The old value.\n * @param {FloatingMenu~offset} [menuOffset={}] The new value.\n * @returns `true` if the parent component wants to change in the adjustment of the floating menu position.\n * @private\n */\nconst hasChangeInOffset = function () {\n  let oldMenuOffset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let menuOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (typeof oldMenuOffset !== typeof menuOffset) {\n    return true;\n  }\n  if (Object(menuOffset) === menuOffset && typeof menuOffset !== 'function') {\n    return oldMenuOffset.top !== menuOffset.top || oldMenuOffset.left !== menuOffset.left;\n  }\n  return oldMenuOffset !== menuOffset;\n};\n\n/**\n * @param {object} params The parameters.\n * @param {FloatingMenu~size} params.menuSize The size of the menu.\n * @param {FloatingMenu~position} params.refPosition The position of the triggering element.\n * @param {FloatingMenu~offset} [params.offset={ left: 0, top: 0 }] The position offset of the menu.\n * @param {string} [params.direction=bottom] The menu direction.\n * @param {number} [params.scrollX=0] The scroll position of the viewport.\n * @param {number} [params.scrollY=0] The scroll position of the viewport.\n * @param {FloatingMenu~container} [params.container] The size and position type of target element.\n * @returns {FloatingMenu~offset} The position of the menu, relative to the top-left corner of the viewport.\n * @private\n */\nconst getFloatingPosition = _ref => {\n  let {\n    menuSize,\n    refPosition = {},\n    offset = {},\n    direction = DIRECTION_BOTTOM,\n    scrollX: pageXOffset = 0,\n    scrollY: pageYOffset = 0,\n    container\n  } = _ref;\n  const {\n    left: refLeft = 0,\n    top: refTop = 0,\n    right: refRight = 0,\n    bottom: refBottom = 0\n  } = refPosition;\n  const scrollX = container.position !== 'static' ? 0 : pageXOffset;\n  const scrollY = container.position !== 'static' ? 0 : pageYOffset;\n  const relativeDiff = {\n    top: container.position !== 'static' ? container.rect.top : 0,\n    left: container.position !== 'static' ? container.rect.left : 0\n  };\n  const {\n    width,\n    height\n  } = menuSize;\n  const {\n    top = 0,\n    left = 0\n  } = offset;\n  const refCenterHorizontal = (refLeft + refRight) / 2;\n  const refCenterVertical = (refTop + refBottom) / 2;\n  return {\n    [DIRECTION_LEFT]: () => ({\n      left: refLeft - width + scrollX - left - relativeDiff.left,\n      top: refCenterVertical - height / 2 + scrollY + top - 9 - relativeDiff.top\n    }),\n    [DIRECTION_TOP]: () => ({\n      left: refCenterHorizontal - width / 2 + scrollX + left - relativeDiff.left,\n      top: refTop - height + scrollY - top - relativeDiff.top\n    }),\n    [DIRECTION_RIGHT]: () => ({\n      left: refRight + scrollX + left - relativeDiff.left,\n      top: refCenterVertical - height / 2 + scrollY + top + 3 - relativeDiff.top\n    }),\n    [DIRECTION_BOTTOM]: () => ({\n      left: refCenterHorizontal - width / 2 + scrollX + left - relativeDiff.left,\n      top: refBottom + scrollY + top - relativeDiff.top\n    })\n  }[direction]();\n};\n\n/**\n * A menu that is detached from the triggering element.\n * Useful when the container of the triggering element cannot have `overflow:visible` style, etc.\n */\nclass FloatingMenu extends React__default.Component {\n  constructor() {\n    var _this;\n    super(...arguments);\n    _this = this;\n    // `true` if the menu body is mounted and calculation of the position is in progress.\n    _defineProperty(this, \"_placeInProgress\", false);\n    _defineProperty(this, \"state\", {\n      /**\n       * The position of the menu, relative to the top-left corner of the viewport.\n       * @type {FloatingMenu~offset}\n       */\n      floatingPosition: undefined\n    });\n    /**\n     * The cached reference to the menu container.\n     * Only used if React portal API is not available.\n     * @type {Element}\n     * @private\n     */\n    _defineProperty(this, \"_menuContainer\", null);\n    /**\n     * The cached reference to the menu body.\n     * The reference is set via callback ref instead of object ref,\n     * in order to hook the event when the element ref gets available,\n     * which can be at a different timing from `cDM()`, presumably with SSR scenario.\n     * @type {Element}\n     * @private\n     */\n    _defineProperty(this, \"_menuBody\", null);\n    /**\n     * Focus sentinel refs for focus trap behavior\n     */\n    _defineProperty(this, \"startSentinel\", /*#__PURE__*/React__default.createRef());\n    _defineProperty(this, \"endSentinel\", /*#__PURE__*/React__default.createRef());\n    /**\n     * Calculates the position in the viewport of floating menu,\n     * once this component is mounted or updated upon change in the following props:\n     *\n     * * `menuOffset` (The adjustment that should be applied to the calculated floating menu's position)\n     * * `menuDirection` (Where the floating menu menu should be placed relative to the trigger button)\n     *\n     * @private\n     */\n    _defineProperty(this, \"_updateMenuSize\", function () {\n      let prevProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      let isAdjustment = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      const menuBody = _this._menuBody;\n      process.env.NODE_ENV !== \"production\" ? warning(menuBody, 'The DOM node for menu body for calculating its position is not available. Skipping...') : void 0;\n      if (!menuBody) {\n        return;\n      }\n      const {\n        menuOffset: oldMenuOffset = {},\n        menuDirection: oldMenuDirection\n      } = prevProps;\n      const {\n        menuOffset = {},\n        menuDirection\n      } = _this.props;\n      if (hasChangeInOffset(oldMenuOffset, menuOffset) || oldMenuDirection !== menuDirection || isAdjustment) {\n        const {\n          flipped,\n          triggerRef,\n          updateOrientation\n        } = _this.props;\n        const {\n          current: triggerEl\n        } = triggerRef;\n        const menuSize = menuBody.getBoundingClientRect();\n        const refPosition = triggerEl && triggerEl.getBoundingClientRect();\n        const offset = typeof menuOffset !== 'function' ? menuOffset : menuOffset(menuBody, menuDirection, triggerEl, flipped);\n\n        // Optional function to allow parent component to check\n        // if the orientation needs to be changed based on params\n        if (updateOrientation) {\n          updateOrientation({\n            menuSize,\n            refPosition,\n            direction: menuDirection,\n            offset,\n            scrollX: window.pageXOffset,\n            scrollY: window.pageYOffset,\n            container: {\n              rect: _this.props.target().getBoundingClientRect(),\n              position: getComputedStyle(_this.props.target()).position\n            }\n          });\n        }\n        // Skips if either in the following condition:\n        // a) Menu body has `display:none`\n        // b) `menuOffset` as a callback returns `undefined` (The callback saw that it couldn't calculate the value)\n        if (menuSize.width > 0 && menuSize.height > 0 || !offset) {\n          _this.setState({\n            floatingPosition: getFloatingPosition({\n              menuSize,\n              refPosition,\n              direction: menuDirection,\n              offset,\n              scrollX: window.pageXOffset,\n              scrollY: window.pageYOffset,\n              container: {\n                rect: _this.props.target().getBoundingClientRect(),\n                position: getComputedStyle(_this.props.target()).position\n              }\n            })\n          }, () => {\n            if (!isAdjustment) {\n              const newMenuSize = menuBody.getBoundingClientRect();\n              if (newMenuSize !== menuSize) {\n                _this._updateMenuSize(_this.props, true);\n              }\n            }\n          });\n        }\n      }\n    });\n    /**\n     * Set focus on floating menu content after menu placement.\n     * @param {Element} menuBody The DOM element of the menu body.\n     * @private\n     */\n    _defineProperty(this, \"_focusMenuContent\", menuBody => {\n      const primaryFocusNode = menuBody.querySelector(this.props.selectorPrimaryFocus || null);\n      const tabbableNode = menuBody.querySelector(selectorTabbable);\n      const focusableNode = menuBody.querySelector(selectorFocusable);\n      const focusTarget = primaryFocusNode ||\n      // User defined focusable node\n      tabbableNode ||\n      // First sequentially focusable node\n      focusableNode ||\n      // First programmatic focusable node\n      menuBody;\n      focusTarget.focus();\n      if (focusTarget === menuBody && process.env.NODE_ENV !== \"production\") {\n        process.env.NODE_ENV !== \"production\" ? warning(focusableNode === null, 'Floating Menus must have at least a programmatically focusable child. ' + 'This can be accomplished by adding tabIndex=\"-1\" to the content element.') : void 0;\n      }\n    });\n    /**\n     * A callback for called when menu body is mounted or unmounted.\n     * @param {Element} menuBody The menu body being mounted. `null` if the menu body is being unmounted.\n     */\n    _defineProperty(this, \"_menuRef\", menuBody => {\n      const {\n        menuRef\n      } = this.props;\n      this._placeInProgress = !!menuBody;\n      menuRef && menuRef(this._menuBody = menuBody);\n      if (menuBody) {\n        this._updateMenuSize();\n      }\n    });\n    /**\n     * @returns The child nodes, with styles containing the floating menu position.\n     * @private\n     */\n    _defineProperty(this, \"_getChildrenWithProps\", () => {\n      const {\n        styles,\n        children\n      } = this.props;\n      const {\n        floatingPosition: pos\n      } = this.state;\n      // If no pos available, we need to hide the element (offscreen to the left)\n      // This is done so we can measure the content before positioning it correctly.\n      const positioningStyle = pos ? {\n        left: `${pos.left}px`,\n        top: `${pos.top}px`,\n        right: 'auto'\n      } : {\n        visibility: 'hidden',\n        top: '0px'\n      };\n      return /*#__PURE__*/React__default.cloneElement(children, {\n        ref: this._menuRef,\n        style: {\n          ...styles,\n          ...positioningStyle,\n          position: 'absolute',\n          opacity: 1\n        }\n      });\n    });\n    /**\n     * Blur handler for when focus wrap behavior is enabled\n     * @param {Event} event\n     * @param {Element} event.target previously focused node\n     * @param {Element} event.relatedTarget current focused node\n     */\n    _defineProperty(this, \"handleBlur\", _ref2 => {\n      let {\n        target: oldActiveNode,\n        relatedTarget: currentActiveNode\n      } = _ref2;\n      if (currentActiveNode && oldActiveNode) {\n        const {\n          current: startSentinelNode\n        } = this.startSentinel;\n        const {\n          current: endSentinelNode\n        } = this.endSentinel;\n        wrapFocus({\n          bodyNode: this._menuBody,\n          startSentinelNode,\n          endSentinelNode,\n          currentActiveNode,\n          oldActiveNode\n        });\n      }\n    });\n  }\n  componentWillUnmount() {\n    this.hResize.release();\n  }\n  componentDidMount() {\n    this.hResize = OptimizedResize.add(() => {\n      this._updateMenuSize();\n    });\n  }\n  componentDidUpdate(prevProps) {\n    this._updateMenuSize(prevProps);\n    const {\n      onPlace\n    } = this.props;\n    if (this._placeInProgress && this.state.floatingPosition) {\n      if (this._menuBody && !this._menuBody.contains(document.activeElement)) {\n        this._focusMenuContent(this._menuBody);\n      }\n      if (typeof onPlace === 'function') {\n        onPlace(this._menuBody);\n        this._placeInProgress = false;\n      }\n    }\n  }\n  render() {\n    const {\n      context: prefix\n    } = this;\n    if (typeof document !== 'undefined') {\n      const {\n        focusTrap,\n        target\n      } = this.props;\n      return /*#__PURE__*/ReactDOM.createPortal( /*#__PURE__*/React__default.createElement(\"div\", {\n        onBlur: focusTrap ? this.handleBlur : null\n      }, /*#__PURE__*/React__default.createElement(\"span\", {\n        ref: this.startSentinel,\n        tabIndex: \"0\",\n        role: \"link\",\n        className: `${prefix}--visually-hidden`\n      }, \"Focus sentinel\"), this._getChildrenWithProps(), /*#__PURE__*/React__default.createElement(\"span\", {\n        ref: this.endSentinel,\n        tabIndex: \"0\",\n        role: \"link\",\n        className: `${prefix}--visually-hidden`\n      }, \"Focus sentinel\")), !target ? document.body : target());\n    }\n    return null;\n  }\n}\n_defineProperty(FloatingMenu, \"contextType\", PrefixContext);\n_defineProperty(FloatingMenu, \"propTypes\", {\n  /**\n   * Contents to put into the floating menu.\n   */\n  children: PropTypes.object,\n  /**\n   * `true` if the menu alignment should be flipped.\n   */\n  flipped: PropTypes.bool,\n  /**\n   * Enable or disable focus trap behavior\n   */\n  focusTrap: PropTypes.bool,\n  /**\n   * Where to put the tooltip, relative to the trigger button.\n   */\n  menuDirection: PropTypes.oneOf([DIRECTION_LEFT, DIRECTION_TOP, DIRECTION_RIGHT, DIRECTION_BOTTOM]),\n  /**\n   * The adjustment of the floating menu position, considering the position of dropdown arrow, etc.\n   */\n  menuOffset: PropTypes.oneOfType([PropTypes.shape({\n    top: PropTypes.number,\n    left: PropTypes.number\n  }), PropTypes.func]),\n  /**\n   * The callback called when the menu body has been mounted to/will be unmounted from the DOM.\n   */\n  menuRef: PropTypes.func,\n  /**\n   * The callback called when the menu body has been mounted and positioned.\n   */\n  onPlace: PropTypes.func,\n  /**\n   * Specify a CSS selector that matches the DOM element that should\n   * be focused when the Modal opens\n   */\n  selectorPrimaryFocus: PropTypes.string,\n  /**\n   * The additional styles to put to the floating menu.\n   */\n  styles: PropTypes.object,\n  /**\n   * The query selector indicating where the floating menu body should be placed.\n   */\n  target: PropTypes.func,\n  /**\n   * The element ref of the tooltip's trigger button.\n   */\n  triggerRef: PropTypes.oneOfType([PropTypes.func, PropTypes.shape({\n    current: PropTypes.any\n  })]),\n  /**\n   * Optional function to change orientation of tooltip based on parent\n   */\n  updateOrientation: PropTypes.func\n});\n_defineProperty(FloatingMenu, \"defaultProps\", {\n  menuOffset: {},\n  menuDirection: DIRECTION_BOTTOM,\n  updateOrientation: null\n});\nvar FloatingMenu$1 = FloatingMenu;\nexport { DIRECTION_BOTTOM, DIRECTION_LEFT, DIRECTION_RIGHT, DIRECTION_TOP, FloatingMenu$1 as default };","map":{"version":3,"names":["defineProperty","_defineProperty","PropTypes","React__default","ReactDOM","window","OptimizedResize","selectorTabbable","selectorFocusable","warning","wrapFocus","PrefixContext","DIRECTION_LEFT","DIRECTION_TOP","DIRECTION_RIGHT","DIRECTION_BOTTOM","hasChangeInOffset","oldMenuOffset","arguments","length","undefined","menuOffset","Object","top","left","getFloatingPosition","_ref","menuSize","refPosition","offset","direction","scrollX","pageXOffset","scrollY","pageYOffset","container","refLeft","refTop","right","refRight","bottom","refBottom","position","relativeDiff","rect","width","height","refCenterHorizontal","refCenterVertical","FloatingMenu","Component","constructor","_this","floatingPosition","createRef","prevProps","isAdjustment","menuBody","_menuBody","process","env","NODE_ENV","menuDirection","oldMenuDirection","props","flipped","triggerRef","updateOrientation","current","triggerEl","getBoundingClientRect","target","getComputedStyle","setState","newMenuSize","_updateMenuSize","primaryFocusNode","querySelector","selectorPrimaryFocus","tabbableNode","focusableNode","focusTarget","focus","menuRef","_placeInProgress","styles","children","pos","state","positioningStyle","visibility","cloneElement","ref","_menuRef","style","opacity","_ref2","oldActiveNode","relatedTarget","currentActiveNode","startSentinelNode","startSentinel","endSentinelNode","endSentinel","bodyNode","componentWillUnmount","hResize","release","componentDidMount","add","componentDidUpdate","onPlace","contains","document","activeElement","_focusMenuContent","render","context","prefix","focusTrap","createPortal","createElement","onBlur","handleBlur","tabIndex","role","className","_getChildrenWithProps","body","object","bool","oneOf","oneOfType","shape","number","func","string","any","FloatingMenu$1","default"],"sources":["/home/saymon/Backup/Portifolio/Hematology-App-with-Carbon-Design-System/frontend/node_modules/@carbon/react/es/internal/FloatingMenu.js"],"sourcesContent":["/**\n * Copyright IBM Corp. 2016, 2023\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport { defineProperty as _defineProperty } from '../_virtual/_rollupPluginBabelHelpers.js';\nimport PropTypes from 'prop-types';\nimport React__default from 'react';\nimport ReactDOM from 'react-dom';\nimport window from 'window-or-global';\nimport OptimizedResize from './OptimizedResize.js';\nimport { selectorTabbable, selectorFocusable } from './keyboard/navigation.js';\nimport { warning } from './warning.js';\nimport wrapFocus from './wrapFocus.js';\nimport { PrefixContext } from './usePrefix.js';\n\n/**\n * The structure for the position of floating menu.\n * @typedef {object} FloatingMenu~position\n * @property {number} left The left position.\n * @property {number} top The top position.\n * @property {number} right The right position.\n * @property {number} bottom The bottom position.\n */\n\n/**\n * The structure for the size of floating menu.\n * @typedef {object} FloatingMenu~size\n * @property {number} width The width.\n * @property {number} height The height.\n */\n\n/**\n * The structure for the position offset of floating menu.\n * @typedef {object} FloatingMenu~offset\n * @property {number} top The top position.\n * @property {number} left The left position.\n */\n\n/**\n * The structure for the target container.\n * @typedef {object} FloatingMenu~container\n * @property {DOMRect} rect Return of element.getBoundingClientRect()\n * @property {string} position Position style (static, absolute, relative...)\n */\n\nconst DIRECTION_LEFT = 'left';\nconst DIRECTION_TOP = 'top';\nconst DIRECTION_RIGHT = 'right';\nconst DIRECTION_BOTTOM = 'bottom';\n\n/**\n * @param {FloatingMenu~offset} [oldMenuOffset={}] The old value.\n * @param {FloatingMenu~offset} [menuOffset={}] The new value.\n * @returns `true` if the parent component wants to change in the adjustment of the floating menu position.\n * @private\n */\nconst hasChangeInOffset = function () {\n  let oldMenuOffset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let menuOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (typeof oldMenuOffset !== typeof menuOffset) {\n    return true;\n  }\n  if (Object(menuOffset) === menuOffset && typeof menuOffset !== 'function') {\n    return oldMenuOffset.top !== menuOffset.top || oldMenuOffset.left !== menuOffset.left;\n  }\n  return oldMenuOffset !== menuOffset;\n};\n\n/**\n * @param {object} params The parameters.\n * @param {FloatingMenu~size} params.menuSize The size of the menu.\n * @param {FloatingMenu~position} params.refPosition The position of the triggering element.\n * @param {FloatingMenu~offset} [params.offset={ left: 0, top: 0 }] The position offset of the menu.\n * @param {string} [params.direction=bottom] The menu direction.\n * @param {number} [params.scrollX=0] The scroll position of the viewport.\n * @param {number} [params.scrollY=0] The scroll position of the viewport.\n * @param {FloatingMenu~container} [params.container] The size and position type of target element.\n * @returns {FloatingMenu~offset} The position of the menu, relative to the top-left corner of the viewport.\n * @private\n */\nconst getFloatingPosition = _ref => {\n  let {\n    menuSize,\n    refPosition = {},\n    offset = {},\n    direction = DIRECTION_BOTTOM,\n    scrollX: pageXOffset = 0,\n    scrollY: pageYOffset = 0,\n    container\n  } = _ref;\n  const {\n    left: refLeft = 0,\n    top: refTop = 0,\n    right: refRight = 0,\n    bottom: refBottom = 0\n  } = refPosition;\n  const scrollX = container.position !== 'static' ? 0 : pageXOffset;\n  const scrollY = container.position !== 'static' ? 0 : pageYOffset;\n  const relativeDiff = {\n    top: container.position !== 'static' ? container.rect.top : 0,\n    left: container.position !== 'static' ? container.rect.left : 0\n  };\n  const {\n    width,\n    height\n  } = menuSize;\n  const {\n    top = 0,\n    left = 0\n  } = offset;\n  const refCenterHorizontal = (refLeft + refRight) / 2;\n  const refCenterVertical = (refTop + refBottom) / 2;\n  return {\n    [DIRECTION_LEFT]: () => ({\n      left: refLeft - width + scrollX - left - relativeDiff.left,\n      top: refCenterVertical - height / 2 + scrollY + top - 9 - relativeDiff.top\n    }),\n    [DIRECTION_TOP]: () => ({\n      left: refCenterHorizontal - width / 2 + scrollX + left - relativeDiff.left,\n      top: refTop - height + scrollY - top - relativeDiff.top\n    }),\n    [DIRECTION_RIGHT]: () => ({\n      left: refRight + scrollX + left - relativeDiff.left,\n      top: refCenterVertical - height / 2 + scrollY + top + 3 - relativeDiff.top\n    }),\n    [DIRECTION_BOTTOM]: () => ({\n      left: refCenterHorizontal - width / 2 + scrollX + left - relativeDiff.left,\n      top: refBottom + scrollY + top - relativeDiff.top\n    })\n  }[direction]();\n};\n\n/**\n * A menu that is detached from the triggering element.\n * Useful when the container of the triggering element cannot have `overflow:visible` style, etc.\n */\nclass FloatingMenu extends React__default.Component {\n  constructor() {\n    var _this;\n    super(...arguments);\n    _this = this;\n    // `true` if the menu body is mounted and calculation of the position is in progress.\n    _defineProperty(this, \"_placeInProgress\", false);\n    _defineProperty(this, \"state\", {\n      /**\n       * The position of the menu, relative to the top-left corner of the viewport.\n       * @type {FloatingMenu~offset}\n       */\n      floatingPosition: undefined\n    });\n    /**\n     * The cached reference to the menu container.\n     * Only used if React portal API is not available.\n     * @type {Element}\n     * @private\n     */\n    _defineProperty(this, \"_menuContainer\", null);\n    /**\n     * The cached reference to the menu body.\n     * The reference is set via callback ref instead of object ref,\n     * in order to hook the event when the element ref gets available,\n     * which can be at a different timing from `cDM()`, presumably with SSR scenario.\n     * @type {Element}\n     * @private\n     */\n    _defineProperty(this, \"_menuBody\", null);\n    /**\n     * Focus sentinel refs for focus trap behavior\n     */\n    _defineProperty(this, \"startSentinel\", /*#__PURE__*/React__default.createRef());\n    _defineProperty(this, \"endSentinel\", /*#__PURE__*/React__default.createRef());\n    /**\n     * Calculates the position in the viewport of floating menu,\n     * once this component is mounted or updated upon change in the following props:\n     *\n     * * `menuOffset` (The adjustment that should be applied to the calculated floating menu's position)\n     * * `menuDirection` (Where the floating menu menu should be placed relative to the trigger button)\n     *\n     * @private\n     */\n    _defineProperty(this, \"_updateMenuSize\", function () {\n      let prevProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      let isAdjustment = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      const menuBody = _this._menuBody;\n      process.env.NODE_ENV !== \"production\" ? warning(menuBody, 'The DOM node for menu body for calculating its position is not available. Skipping...') : void 0;\n      if (!menuBody) {\n        return;\n      }\n      const {\n        menuOffset: oldMenuOffset = {},\n        menuDirection: oldMenuDirection\n      } = prevProps;\n      const {\n        menuOffset = {},\n        menuDirection\n      } = _this.props;\n      if (hasChangeInOffset(oldMenuOffset, menuOffset) || oldMenuDirection !== menuDirection || isAdjustment) {\n        const {\n          flipped,\n          triggerRef,\n          updateOrientation\n        } = _this.props;\n        const {\n          current: triggerEl\n        } = triggerRef;\n        const menuSize = menuBody.getBoundingClientRect();\n        const refPosition = triggerEl && triggerEl.getBoundingClientRect();\n        const offset = typeof menuOffset !== 'function' ? menuOffset : menuOffset(menuBody, menuDirection, triggerEl, flipped);\n\n        // Optional function to allow parent component to check\n        // if the orientation needs to be changed based on params\n        if (updateOrientation) {\n          updateOrientation({\n            menuSize,\n            refPosition,\n            direction: menuDirection,\n            offset,\n            scrollX: window.pageXOffset,\n            scrollY: window.pageYOffset,\n            container: {\n              rect: _this.props.target().getBoundingClientRect(),\n              position: getComputedStyle(_this.props.target()).position\n            }\n          });\n        }\n        // Skips if either in the following condition:\n        // a) Menu body has `display:none`\n        // b) `menuOffset` as a callback returns `undefined` (The callback saw that it couldn't calculate the value)\n        if (menuSize.width > 0 && menuSize.height > 0 || !offset) {\n          _this.setState({\n            floatingPosition: getFloatingPosition({\n              menuSize,\n              refPosition,\n              direction: menuDirection,\n              offset,\n              scrollX: window.pageXOffset,\n              scrollY: window.pageYOffset,\n              container: {\n                rect: _this.props.target().getBoundingClientRect(),\n                position: getComputedStyle(_this.props.target()).position\n              }\n            })\n          }, () => {\n            if (!isAdjustment) {\n              const newMenuSize = menuBody.getBoundingClientRect();\n              if (newMenuSize !== menuSize) {\n                _this._updateMenuSize(_this.props, true);\n              }\n            }\n          });\n        }\n      }\n    });\n    /**\n     * Set focus on floating menu content after menu placement.\n     * @param {Element} menuBody The DOM element of the menu body.\n     * @private\n     */\n    _defineProperty(this, \"_focusMenuContent\", menuBody => {\n      const primaryFocusNode = menuBody.querySelector(this.props.selectorPrimaryFocus || null);\n      const tabbableNode = menuBody.querySelector(selectorTabbable);\n      const focusableNode = menuBody.querySelector(selectorFocusable);\n      const focusTarget = primaryFocusNode ||\n      // User defined focusable node\n      tabbableNode ||\n      // First sequentially focusable node\n      focusableNode ||\n      // First programmatic focusable node\n      menuBody;\n      focusTarget.focus();\n      if (focusTarget === menuBody && process.env.NODE_ENV !== \"production\") {\n        process.env.NODE_ENV !== \"production\" ? warning(focusableNode === null, 'Floating Menus must have at least a programmatically focusable child. ' + 'This can be accomplished by adding tabIndex=\"-1\" to the content element.') : void 0;\n      }\n    });\n    /**\n     * A callback for called when menu body is mounted or unmounted.\n     * @param {Element} menuBody The menu body being mounted. `null` if the menu body is being unmounted.\n     */\n    _defineProperty(this, \"_menuRef\", menuBody => {\n      const {\n        menuRef\n      } = this.props;\n      this._placeInProgress = !!menuBody;\n      menuRef && menuRef(this._menuBody = menuBody);\n      if (menuBody) {\n        this._updateMenuSize();\n      }\n    });\n    /**\n     * @returns The child nodes, with styles containing the floating menu position.\n     * @private\n     */\n    _defineProperty(this, \"_getChildrenWithProps\", () => {\n      const {\n        styles,\n        children\n      } = this.props;\n      const {\n        floatingPosition: pos\n      } = this.state;\n      // If no pos available, we need to hide the element (offscreen to the left)\n      // This is done so we can measure the content before positioning it correctly.\n      const positioningStyle = pos ? {\n        left: `${pos.left}px`,\n        top: `${pos.top}px`,\n        right: 'auto'\n      } : {\n        visibility: 'hidden',\n        top: '0px'\n      };\n      return /*#__PURE__*/React__default.cloneElement(children, {\n        ref: this._menuRef,\n        style: {\n          ...styles,\n          ...positioningStyle,\n          position: 'absolute',\n          opacity: 1\n        }\n      });\n    });\n    /**\n     * Blur handler for when focus wrap behavior is enabled\n     * @param {Event} event\n     * @param {Element} event.target previously focused node\n     * @param {Element} event.relatedTarget current focused node\n     */\n    _defineProperty(this, \"handleBlur\", _ref2 => {\n      let {\n        target: oldActiveNode,\n        relatedTarget: currentActiveNode\n      } = _ref2;\n      if (currentActiveNode && oldActiveNode) {\n        const {\n          current: startSentinelNode\n        } = this.startSentinel;\n        const {\n          current: endSentinelNode\n        } = this.endSentinel;\n        wrapFocus({\n          bodyNode: this._menuBody,\n          startSentinelNode,\n          endSentinelNode,\n          currentActiveNode,\n          oldActiveNode\n        });\n      }\n    });\n  }\n  componentWillUnmount() {\n    this.hResize.release();\n  }\n  componentDidMount() {\n    this.hResize = OptimizedResize.add(() => {\n      this._updateMenuSize();\n    });\n  }\n  componentDidUpdate(prevProps) {\n    this._updateMenuSize(prevProps);\n    const {\n      onPlace\n    } = this.props;\n    if (this._placeInProgress && this.state.floatingPosition) {\n      if (this._menuBody && !this._menuBody.contains(document.activeElement)) {\n        this._focusMenuContent(this._menuBody);\n      }\n      if (typeof onPlace === 'function') {\n        onPlace(this._menuBody);\n        this._placeInProgress = false;\n      }\n    }\n  }\n  render() {\n    const {\n      context: prefix\n    } = this;\n    if (typeof document !== 'undefined') {\n      const {\n        focusTrap,\n        target\n      } = this.props;\n      return /*#__PURE__*/ReactDOM.createPortal( /*#__PURE__*/React__default.createElement(\"div\", {\n        onBlur: focusTrap ? this.handleBlur : null\n      }, /*#__PURE__*/React__default.createElement(\"span\", {\n        ref: this.startSentinel,\n        tabIndex: \"0\",\n        role: \"link\",\n        className: `${prefix}--visually-hidden`\n      }, \"Focus sentinel\"), this._getChildrenWithProps(), /*#__PURE__*/React__default.createElement(\"span\", {\n        ref: this.endSentinel,\n        tabIndex: \"0\",\n        role: \"link\",\n        className: `${prefix}--visually-hidden`\n      }, \"Focus sentinel\")), !target ? document.body : target());\n    }\n    return null;\n  }\n}\n_defineProperty(FloatingMenu, \"contextType\", PrefixContext);\n_defineProperty(FloatingMenu, \"propTypes\", {\n  /**\n   * Contents to put into the floating menu.\n   */\n  children: PropTypes.object,\n  /**\n   * `true` if the menu alignment should be flipped.\n   */\n  flipped: PropTypes.bool,\n  /**\n   * Enable or disable focus trap behavior\n   */\n  focusTrap: PropTypes.bool,\n  /**\n   * Where to put the tooltip, relative to the trigger button.\n   */\n  menuDirection: PropTypes.oneOf([DIRECTION_LEFT, DIRECTION_TOP, DIRECTION_RIGHT, DIRECTION_BOTTOM]),\n  /**\n   * The adjustment of the floating menu position, considering the position of dropdown arrow, etc.\n   */\n  menuOffset: PropTypes.oneOfType([PropTypes.shape({\n    top: PropTypes.number,\n    left: PropTypes.number\n  }), PropTypes.func]),\n  /**\n   * The callback called when the menu body has been mounted to/will be unmounted from the DOM.\n   */\n  menuRef: PropTypes.func,\n  /**\n   * The callback called when the menu body has been mounted and positioned.\n   */\n  onPlace: PropTypes.func,\n  /**\n   * Specify a CSS selector that matches the DOM element that should\n   * be focused when the Modal opens\n   */\n  selectorPrimaryFocus: PropTypes.string,\n  /**\n   * The additional styles to put to the floating menu.\n   */\n  styles: PropTypes.object,\n  /**\n   * The query selector indicating where the floating menu body should be placed.\n   */\n  target: PropTypes.func,\n  /**\n   * The element ref of the tooltip's trigger button.\n   */\n  triggerRef: PropTypes.oneOfType([PropTypes.func, PropTypes.shape({\n    current: PropTypes.any\n  })]),\n  /**\n   * Optional function to change orientation of tooltip based on parent\n   */\n  updateOrientation: PropTypes.func\n});\n_defineProperty(FloatingMenu, \"defaultProps\", {\n  menuOffset: {},\n  menuDirection: DIRECTION_BOTTOM,\n  updateOrientation: null\n});\nvar FloatingMenu$1 = FloatingMenu;\n\nexport { DIRECTION_BOTTOM, DIRECTION_LEFT, DIRECTION_RIGHT, DIRECTION_TOP, FloatingMenu$1 as default };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}